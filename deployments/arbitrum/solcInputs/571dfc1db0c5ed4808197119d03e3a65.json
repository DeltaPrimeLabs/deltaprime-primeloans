{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/interfaces/VRFV2WrapperInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface VRFV2WrapperInterface {\n  /**\n   * @return the request ID of the most recent VRF V2 request made by this wrapper. This should only\n   * be relied option within the same transaction that the request was made.\n   */\n  function lastRequestId() external view returns (uint256);\n\n  /**\n   * @notice Calculates the price of a VRF request with the given callbackGasLimit at the current\n   * @notice block.\n   *\n   * @dev This function relies on the transaction gas price which is not automatically set during\n   * @dev simulation. To estimate the price at a specific gas price, use the estimatePrice function.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   */\n  function calculateRequestPrice(uint32 _callbackGasLimit) external view returns (uint256);\n\n  /**\n   * @notice Estimates the price of a VRF request with a specific gas limit and gas price.\n   *\n   * @dev This is a convenience function that can be called in simulation to better understand\n   * @dev pricing.\n   *\n   * @param _callbackGasLimit is the gas limit used to estimate the price.\n   * @param _requestGasPriceWei is the gas price in wei used for the estimation.\n   */\n  function estimateRequestPrice(uint32 _callbackGasLimit, uint256 _requestGasPriceWei) external view returns (uint256);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ConfirmedOwnerWithProposal.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IOwnable.sol\";\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n */\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /**\n   * @notice Allows an owner to begin transferring ownership to a new address,\n   * pending.\n   */\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /**\n   * @notice Allows an ownership transfer to be completed by the recipient.\n   */\n  function acceptOwnership() external override {\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /**\n   * @notice Get the current owner\n   */\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /**\n   * @notice validate, transfer ownership, and emit relevant events\n   */\n  function _transferOwnership(address to) private {\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /**\n   * @notice validate access\n   */\n  function _validateOwnership() internal view {\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /**\n   * @notice Reverts if called by anyone other than the contract owner.\n   */\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface LinkTokenInterface {\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  function approve(address spender, uint256 value) external returns (bool success);\n\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  function decimals() external view returns (uint8 decimalPlaces);\n\n  function decreaseApproval(address spender, uint256 addedValue) external returns (bool success);\n\n  function increaseApproval(address spender, uint256 subtractedValue) external;\n\n  function name() external view returns (string memory tokenName);\n\n  function symbol() external view returns (string memory tokenSymbol);\n\n  function totalSupply() external view returns (uint256 totalTokensIssued);\n\n  function transfer(address to, uint256 value) external returns (bool success);\n\n  function transferAndCall(address to, uint256 value, bytes calldata data) external returns (bool success);\n\n  function transferFrom(address from, address to, uint256 value) external returns (bool success);\n}\n"
    },
    "@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../shared/interfaces/LinkTokenInterface.sol\";\nimport \"../interfaces/VRFV2WrapperInterface.sol\";\n\n/** *******************************************************************************\n * @notice Interface for contracts using VRF randomness through the VRF V2 wrapper\n * ********************************************************************************\n * @dev PURPOSE\n *\n * @dev Create VRF V2 requests without the need for subscription management. Rather than creating\n * @dev and funding a VRF V2 subscription, a user can use this wrapper to create one off requests,\n * @dev paying up front rather than at fulfillment.\n *\n * @dev Since the price is determined using the gas price of the request transaction rather than\n * @dev the fulfillment transaction, the wrapper charges an additional premium on callback gas\n * @dev usage, in addition to some extra overhead costs associated with the VRFV2Wrapper contract.\n * *****************************************************************************\n * @dev USAGE\n *\n * @dev Calling contracts must inherit from VRFV2WrapperConsumerBase. The consumer must be funded\n * @dev with enough LINK to make the request, otherwise requests will revert. To request randomness,\n * @dev call the 'requestRandomness' function with the desired VRF parameters. This function handles\n * @dev paying for the request based on the current pricing.\n *\n * @dev Consumers must implement the fullfillRandomWords function, which will be called during\n * @dev fulfillment with the randomness result.\n */\nabstract contract VRFV2WrapperConsumerBase {\n  LinkTokenInterface internal immutable LINK;\n  VRFV2WrapperInterface internal immutable VRF_V2_WRAPPER;\n\n  /**\n   * @param _link is the address of LinkToken\n   * @param _vrfV2Wrapper is the address of the VRFV2Wrapper contract\n   */\n  constructor(address _link, address _vrfV2Wrapper) {\n    LINK = LinkTokenInterface(_link);\n    VRF_V2_WRAPPER = VRFV2WrapperInterface(_vrfV2Wrapper);\n  }\n\n  /**\n   * @dev Requests randomness from the VRF V2 wrapper.\n   *\n   * @param _callbackGasLimit is the gas limit that should be used when calling the consumer's\n   *        fulfillRandomWords function.\n   * @param _requestConfirmations is the number of confirmations to wait before fulfilling the\n   *        request. A higher number of confirmations increases security by reducing the likelihood\n   *        that a chain re-org changes a published randomness outcome.\n   * @param _numWords is the number of random words to request.\n   *\n   * @return requestId is the VRF V2 request ID of the newly created randomness request.\n   */\n  function requestRandomness(\n    uint32 _callbackGasLimit,\n    uint16 _requestConfirmations,\n    uint32 _numWords\n  ) internal returns (uint256 requestId) {\n    LINK.transferAndCall(\n      address(VRF_V2_WRAPPER),\n      VRF_V2_WRAPPER.calculateRequestPrice(_callbackGasLimit),\n      abi.encode(_callbackGasLimit, _requestConfirmations, _numWords)\n    );\n    return VRF_V2_WRAPPER.lastRequestId();\n  }\n\n  /**\n   * @notice fulfillRandomWords handles the VRF V2 wrapper response. The consuming contract must\n   * @notice implement it.\n   *\n   * @param _requestId is the VRF V2 request ID.\n   * @param _randomWords is the randomness result.\n   */\n  function fulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) internal virtual;\n\n  function rawFulfillRandomWords(uint256 _requestId, uint256[] memory _randomWords) external {\n    require(msg.sender == address(VRF_V2_WRAPPER), \"only VRF V2 wrapper can fulfill\");\n    fulfillRandomWords(_requestId, _randomWords);\n  }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes memory) {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(\n                0x40,\n                and(\n                    add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n                    not(31) // Round down to the nearest 32 bytes.\n                )\n            )\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(and(fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00), and(mload(mc), mask)))\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint _start,\n        uint _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1, \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint _start) internal pure returns (uint) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                    // the next line is the loop condition:\n                    // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {\n\n                        } eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/libraries/ExcessivelySafeCall.sol": {
      "content": "// SPDX-License-Identifier: MIT OR Apache-2.0\npragma solidity >=0.7.6;\n\nlibrary ExcessivelySafeCall {\n    uint constant LOW_28_MASK = 0x00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeCall(\n        address _target,\n        uint _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal returns (bool, bytes memory) {\n        // set up for assembly call\n        uint _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := call(\n                _gas, // gas\n                _target, // recipient\n                0, // ether value\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /// @notice Use when you _really_ really _really_ don't trust the called\n    /// contract. This prevents the called contract from causing reversion of\n    /// the caller in as many ways as we can.\n    /// @dev The main difference between this and a solidity low-level call is\n    /// that we limit the number of bytes that the callee can cause to be\n    /// copied to caller memory. This prevents stupid things like malicious\n    /// contracts returning 10,000,000 bytes causing a local OOG when copying\n    /// to memory.\n    /// @param _target The address to call\n    /// @param _gas The amount of gas to forward to the remote contract\n    /// @param _maxCopy The maximum number of bytes of returndata to copy\n    /// to memory.\n    /// @param _calldata The data to send to the remote contract\n    /// @return success and returndata, as `.call()`. Returndata is capped to\n    /// `_maxCopy` bytes.\n    function excessivelySafeStaticCall(\n        address _target,\n        uint _gas,\n        uint16 _maxCopy,\n        bytes memory _calldata\n    ) internal view returns (bool, bytes memory) {\n        // set up for assembly call\n        uint _toCopy;\n        bool _success;\n        bytes memory _returnData = new bytes(_maxCopy);\n        // dispatch message to recipient\n        // by assembly calling \"handle\" function\n        // we call via assembly to avoid memcopying a very large returndata\n        // returned by a malicious contract\n        assembly {\n            _success := staticcall(\n                _gas, // gas\n                _target, // recipient\n                add(_calldata, 0x20), // inloc\n                mload(_calldata), // inlen\n                0, // outloc\n                0 // outlen\n            )\n            // limit our copy to 256 bytes\n            _toCopy := returndatasize()\n            if gt(_toCopy, _maxCopy) {\n                _toCopy := _maxCopy\n            }\n            // Store the length of the copied bytes\n            mstore(_returnData, _toCopy)\n            // copy the bytes from returndata[0:_toCopy]\n            returndatacopy(add(_returnData, 0x20), 0, _toCopy)\n        }\n        return (_success, _returnData);\n    }\n\n    /**\n     * @notice Swaps function selectors in encoded contract calls\n     * @dev Allows reuse of encoded calldata for functions with identical\n     * argument types but different names. It simply swaps out the first 4 bytes\n     * for the new selector. This function modifies memory in place, and should\n     * only be used with caution.\n     * @param _newSelector The new 4-byte selector\n     * @param _buf The encoded contract args\n     */\n    function swapSelector(bytes4 _newSelector, bytes memory _buf) internal pure {\n        require(_buf.length >= 4);\n        uint _mask = LOW_28_MASK;\n        assembly {\n            // load the first word of\n            let _word := mload(add(_buf, 0x20))\n            // mask out the top 4 bytes\n            // /x\n            _word := and(_word, _mask)\n            _word := or(_newSelector, _word)\n            mstore(add(_buf, 0x20), _word)\n        }\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroEndpoint.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ILayerZeroUserApplicationConfig.sol\";\n\ninterface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {\n    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.\n    // @param _dstChainId - the destination chain identifier\n    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains\n    // @param _payload - a custom bytes payload to send to the destination contract\n    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address\n    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction\n    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination\n    function send(\n        uint16 _dstChainId,\n        bytes calldata _destination,\n        bytes calldata _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes calldata _adapterParams\n    ) external payable;\n\n    // @notice used by the messaging library to publish verified payload\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source contract (as bytes) at the source chain\n    // @param _dstAddress - the address on destination chain\n    // @param _nonce - the unbound message ordering nonce\n    // @param _gasLimit - the gas limit for external contract execution\n    // @param _payload - verified payload to send to the destination contract\n    function receivePayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        address _dstAddress,\n        uint64 _nonce,\n        uint _gasLimit,\n        bytes calldata _payload\n    ) external;\n\n    // @notice get the inboundNonce of a lzApp from a source chain which could be EVM or non-EVM chain\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);\n\n    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM\n    // @param _srcAddress - the source chain contract address\n    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);\n\n    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery\n    // @param _dstChainId - the destination chain identifier\n    // @param _userApplication - the user app address on this EVM chain\n    // @param _payload - the custom message to send over LayerZero\n    // @param _payInZRO - if false, user app pays the protocol fee in native token\n    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain\n    function estimateFees(\n        uint16 _dstChainId,\n        address _userApplication,\n        bytes calldata _payload,\n        bool _payInZRO,\n        bytes calldata _adapterParam\n    ) external view returns (uint nativeFee, uint zroFee);\n\n    // @notice get this Endpoint's immutable source identifier\n    function getChainId() external view returns (uint16);\n\n    // @notice the interface to retry failed message on this Endpoint destination\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    // @param _payload - the payload to be retried\n    function retryPayload(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        bytes calldata _payload\n    ) external;\n\n    // @notice query if any STORED payload (message blocking) at the endpoint.\n    // @param _srcChainId - the source chain identifier\n    // @param _srcAddress - the source chain contract address\n    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);\n\n    // @notice query if the _libraryAddress is valid for sending msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getSendLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the _libraryAddress is valid for receiving msgs.\n    // @param _userApplication - the user app address on this EVM chain\n    function getReceiveLibraryAddress(address _userApplication) external view returns (address);\n\n    // @notice query if the non-reentrancy guard for send() is on\n    // @return true if the guard is on. false otherwise\n    function isSendingPayload() external view returns (bool);\n\n    // @notice query if the non-reentrancy guard for receive() is on\n    // @return true if the guard is on. false otherwise\n    function isReceivingPayload() external view returns (bool);\n\n    // @notice get the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _userApplication - the contract address of the user application\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address _userApplication,\n        uint _configType\n    ) external view returns (bytes memory);\n\n    // @notice get the send() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getSendVersion(address _userApplication) external view returns (uint16);\n\n    // @notice get the lzReceive() LayerZero messaging library version\n    // @param _userApplication - the contract address of the user application\n    function getReceiveVersion(address _userApplication) external view returns (uint16);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroReceiver {\n    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination\n    // @param _srcChainId - the source endpoint identifier\n    // @param _srcAddress - the source sending contract address from the source chain\n    // @param _nonce - the ordered message nonce\n    // @param _payload - the signed payload is the UA bytes has encoded to be sent\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/interfaces/ILayerZeroUserApplicationConfig.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\ninterface ILayerZeroUserApplicationConfig {\n    // @notice set the configuration of the LayerZero messaging library of the specified version\n    // @param _version - messaging library version\n    // @param _chainId - the chainId for the pending config change\n    // @param _configType - type of configuration. every messaging library has its own convention.\n    // @param _config - configuration in the bytes. can encode arbitrary content.\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external;\n\n    // @notice set the send() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setSendVersion(uint16 _version) external;\n\n    // @notice set the lzReceive() LayerZero messaging library version to _version\n    // @param _version - new messaging library version\n    function setReceiveVersion(uint16 _version) external;\n\n    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload\n    // @param _srcChainId - the chainId of the source chain\n    // @param _srcAddress - the contract address of the source contract at the source chain\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/LzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"./interfaces/ILayerZeroReceiver.sol\";\nimport \"./interfaces/ILayerZeroUserApplicationConfig.sol\";\nimport \"./interfaces/ILayerZeroEndpoint.sol\";\nimport \"../libraries/BytesLib.sol\";\n\n/*\n * a generic LzReceiver implementation\n */\nabstract contract LzApp is Ownable, ILayerZeroReceiver, ILayerZeroUserApplicationConfig {\n    using BytesLib for bytes;\n\n    // ua can not send payload larger than this by default, but it can be changed by the ua owner\n    uint public constant DEFAULT_PAYLOAD_SIZE_LIMIT = 10000;\n\n    ILayerZeroEndpoint public immutable lzEndpoint;\n    mapping(uint16 => bytes) public trustedRemoteLookup;\n    mapping(uint16 => mapping(uint16 => uint)) public minDstGasLookup;\n    mapping(uint16 => uint) public payloadSizeLimitLookup;\n    address public precrime;\n\n    event SetPrecrime(address precrime);\n    event SetTrustedRemote(uint16 _remoteChainId, bytes _path);\n    event SetTrustedRemoteAddress(uint16 _remoteChainId, bytes _remoteAddress);\n    event SetMinDstGas(uint16 _dstChainId, uint16 _type, uint _minDstGas);\n\n    constructor(address _endpoint) {\n        lzEndpoint = ILayerZeroEndpoint(_endpoint);\n    }\n\n    function lzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public virtual override {\n        // lzReceive must be called by the endpoint for security\n        require(_msgSender() == address(lzEndpoint), \"LzApp: invalid endpoint caller\");\n\n        bytes memory trustedRemote = trustedRemoteLookup[_srcChainId];\n        // if will still block the message pathway from (srcChainId, srcAddress). should not receive message from untrusted remote.\n        require(\n            _srcAddress.length == trustedRemote.length && trustedRemote.length > 0 && keccak256(_srcAddress) == keccak256(trustedRemote),\n            \"LzApp: invalid source sending contract\"\n        );\n\n        _blockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    // abstract function - the default behaviour of LayerZero is blocking. See: NonblockingLzApp if you dont need to enforce ordered messaging\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    function _lzSend(\n        uint16 _dstChainId,\n        bytes memory _payload,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams,\n        uint _nativeFee\n    ) internal virtual {\n        bytes memory trustedRemote = trustedRemoteLookup[_dstChainId];\n        require(trustedRemote.length != 0, \"LzApp: destination chain is not a trusted source\");\n        _checkPayloadSize(_dstChainId, _payload.length);\n        lzEndpoint.send{value: _nativeFee}(_dstChainId, trustedRemote, _payload, _refundAddress, _zroPaymentAddress, _adapterParams);\n    }\n\n    function _checkGasLimit(\n        uint16 _dstChainId,\n        uint16 _type,\n        bytes memory _adapterParams,\n        uint _extraGas\n    ) internal view virtual {\n        uint providedGasLimit = _getGasLimit(_adapterParams);\n        uint minGasLimit = minDstGasLookup[_dstChainId][_type];\n        require(minGasLimit > 0, \"LzApp: minGasLimit not set\");\n        require(providedGasLimit >= minGasLimit + _extraGas, \"LzApp: gas limit is too low\");\n    }\n\n    function _getGasLimit(bytes memory _adapterParams) internal pure virtual returns (uint gasLimit) {\n        require(_adapterParams.length >= 34, \"LzApp: invalid adapterParams\");\n        assembly {\n            gasLimit := mload(add(_adapterParams, 34))\n        }\n    }\n\n    function _checkPayloadSize(uint16 _dstChainId, uint _payloadSize) internal view virtual {\n        uint payloadSizeLimit = payloadSizeLimitLookup[_dstChainId];\n        if (payloadSizeLimit == 0) {\n            // use default if not set\n            payloadSizeLimit = DEFAULT_PAYLOAD_SIZE_LIMIT;\n        }\n        require(_payloadSize <= payloadSizeLimit, \"LzApp: payload size is too large\");\n    }\n\n    //---------------------------UserApplication config----------------------------------------\n    function getConfig(\n        uint16 _version,\n        uint16 _chainId,\n        address,\n        uint _configType\n    ) external view returns (bytes memory) {\n        return lzEndpoint.getConfig(_version, _chainId, address(this), _configType);\n    }\n\n    // generic config for LayerZero user Application\n    function setConfig(\n        uint16 _version,\n        uint16 _chainId,\n        uint _configType,\n        bytes calldata _config\n    ) external override onlyOwner {\n        lzEndpoint.setConfig(_version, _chainId, _configType, _config);\n    }\n\n    function setSendVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setSendVersion(_version);\n    }\n\n    function setReceiveVersion(uint16 _version) external override onlyOwner {\n        lzEndpoint.setReceiveVersion(_version);\n    }\n\n    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {\n        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);\n    }\n\n    // _path = abi.encodePacked(remoteAddress, localAddress)\n    // this function set the trusted path for the cross-chain communication\n    function setTrustedRemote(uint16 _remoteChainId, bytes calldata _path) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = _path;\n        emit SetTrustedRemote(_remoteChainId, _path);\n    }\n\n    function setTrustedRemoteAddress(uint16 _remoteChainId, bytes calldata _remoteAddress) external onlyOwner {\n        trustedRemoteLookup[_remoteChainId] = abi.encodePacked(_remoteAddress, address(this));\n        emit SetTrustedRemoteAddress(_remoteChainId, _remoteAddress);\n    }\n\n    function getTrustedRemoteAddress(uint16 _remoteChainId) external view returns (bytes memory) {\n        bytes memory path = trustedRemoteLookup[_remoteChainId];\n        require(path.length != 0, \"LzApp: no trusted path record\");\n        return path.slice(0, path.length - 20); // the last 20 bytes should be address(this)\n    }\n\n    function setPrecrime(address _precrime) external onlyOwner {\n        precrime = _precrime;\n        emit SetPrecrime(_precrime);\n    }\n\n    function setMinDstGas(\n        uint16 _dstChainId,\n        uint16 _packetType,\n        uint _minGas\n    ) external onlyOwner {\n        minDstGasLookup[_dstChainId][_packetType] = _minGas;\n        emit SetMinDstGas(_dstChainId, _packetType, _minGas);\n    }\n\n    // if the size is 0, it means default size limit\n    function setPayloadSizeLimit(uint16 _dstChainId, uint _size) external onlyOwner {\n        payloadSizeLimitLookup[_dstChainId] = _size;\n    }\n\n    //--------------------------- VIEW FUNCTION ----------------------------------------\n    function isTrustedRemote(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool) {\n        bytes memory trustedSource = trustedRemoteLookup[_srcChainId];\n        return keccak256(trustedSource) == keccak256(_srcAddress);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/lzApp/NonblockingLzApp.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./LzApp.sol\";\nimport \"../libraries/ExcessivelySafeCall.sol\";\n\n/*\n * the default LayerZero messaging behaviour is blocking, i.e. any failed message will block the channel\n * this abstract class try-catch all fail messages and store locally for future retry. hence, non-blocking\n * NOTE: if the srcAddress is not configured properly, it will still block the message pathway from (srcChainId, srcAddress)\n */\nabstract contract NonblockingLzApp is LzApp {\n    using ExcessivelySafeCall for address;\n\n    constructor(address _endpoint) LzApp(_endpoint) {}\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bytes32))) public failedMessages;\n\n    event MessageFailed(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes _payload, bytes _reason);\n    event RetryMessageSuccess(uint16 _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _payloadHash);\n\n    // overriding the virtual function in LzReceiver\n    function _blockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.nonblockingLzReceive.selector, _srcChainId, _srcAddress, _nonce, _payload)\n        );\n        if (!success) {\n            _storeFailedMessage(_srcChainId, _srcAddress, _nonce, _payload, reason);\n        }\n    }\n\n    function _storeFailedMessage(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload,\n        bytes memory _reason\n    ) internal virtual {\n        failedMessages[_srcChainId][_srcAddress][_nonce] = keccak256(_payload);\n        emit MessageFailed(_srcChainId, _srcAddress, _nonce, _payload, _reason);\n    }\n\n    function nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public virtual {\n        // only internal transaction\n        require(_msgSender() == address(this), \"NonblockingLzApp: caller must be LzApp\");\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n    }\n\n    //@notice override this function\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual;\n\n    function retryMessage(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes calldata _payload\n    ) public payable virtual {\n        // assert there is message to retry\n        bytes32 payloadHash = failedMessages[_srcChainId][_srcAddress][_nonce];\n        require(payloadHash != bytes32(0), \"NonblockingLzApp: no stored message\");\n        require(keccak256(_payload) == payloadHash, \"NonblockingLzApp: invalid payload\");\n        // clear the stored message\n        failedMessages[_srcChainId][_srcAddress][_nonce] = bytes32(0);\n        // execute the message. revert if it fails again\n        _nonblockingLzReceive(_srcChainId, _srcAddress, _nonce, _payload);\n        emit RetryMessageSuccess(_srcChainId, _srcAddress, _nonce, payloadHash);\n    }\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/BaseOFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./OFTCoreV2.sol\";\nimport \"./interfaces/IOFTV2.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nabstract contract BaseOFTV2 is OFTCoreV2, ERC165, IOFTV2 {\n    constructor(uint8 _sharedDecimals, address _lzEndpoint) OFTCoreV2(_sharedDecimals, _lzEndpoint) {}\n\n    /************************************************************************\n     * public functions\n     ************************************************************************/\n    function sendFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        LzCallParams calldata _callParams\n    ) public payable virtual override {\n        _send(_from, _dstChainId, _toAddress, _amount, _callParams.refundAddress, _callParams.zroPaymentAddress, _callParams.adapterParams);\n    }\n\n    function sendAndCall(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes calldata _payload,\n        uint64 _dstGasForCall,\n        LzCallParams calldata _callParams\n    ) public payable virtual override {\n        _sendAndCall(\n            _from,\n            _dstChainId,\n            _toAddress,\n            _amount,\n            _payload,\n            _dstGasForCall,\n            _callParams.refundAddress,\n            _callParams.zroPaymentAddress,\n            _callParams.adapterParams\n        );\n    }\n\n    /************************************************************************\n     * public view functions\n     ************************************************************************/\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return interfaceId == type(IOFTV2).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    function estimateSendFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return _estimateSendFee(_dstChainId, _toAddress, _amount, _useZro, _adapterParams);\n    }\n\n    function estimateSendAndCallFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes calldata _payload,\n        uint64 _dstGasForCall,\n        bool _useZro,\n        bytes calldata _adapterParams\n    ) public view virtual override returns (uint nativeFee, uint zroFee) {\n        return _estimateSendAndCallFee(_dstChainId, _toAddress, _amount, _payload, _dstGasForCall, _useZro, _adapterParams);\n    }\n\n    function circulatingSupply() public view virtual override returns (uint);\n\n    function token() public view virtual override returns (address);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/ICommonOFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface ICommonOFT is IERC165 {\n\n    struct LzCallParams {\n        address payable refundAddress;\n        address zroPaymentAddress;\n        bytes adapterParams;\n    }\n\n    /**\n     * @dev estimate send token `_tokenId` to (`_dstChainId`, `_toAddress`)\n     * _dstChainId - L0 defined chain id to send tokens too\n     * _toAddress - dynamic bytes array which contains the address to whom you are sending tokens to on the dstChain\n     * _amount - amount of the tokens to transfer\n     * _useZro - indicates to use zro to pay L0 fees\n     * _adapterParam - flexible bytes array to indicate messaging adapter services in L0\n     */\n    function estimateSendFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    function estimateSendAndCallFee(uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, bool _useZro, bytes calldata _adapterParams) external view returns (uint nativeFee, uint zroFee);\n\n    /**\n     * @dev returns the circulating amount of tokens on current chain\n     */\n    function circulatingSupply() external view returns (uint);\n\n    /**\n     * @dev returns the address of the ERC20 token\n     */\n    function token() external view returns (address);\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/IOFTReceiverV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity >=0.5.0;\n\ninterface IOFTReceiverV2 {\n    /**\n     * @dev Called by the OFT contract when tokens are received from source chain.\n     * @param _srcChainId The chain id of the source chain.\n     * @param _srcAddress The address of the OFT token contract on the source chain.\n     * @param _nonce The nonce of the transaction on the source chain.\n     * @param _from The address of the account who calls the sendAndCall() on the source chain.\n     * @param _amount The amount of tokens to transfer.\n     * @param _payload Additional data with no specified format.\n     */\n    function onOFTReceived(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes32 _from, uint _amount, bytes calldata _payload) external;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/interfaces/IOFTV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"./ICommonOFT.sol\";\n\n/**\n * @dev Interface of the IOFT core standard\n */\ninterface IOFTV2 is ICommonOFT {\n\n    /**\n     * @dev send `_amount` amount of token to (`_dstChainId`, `_toAddress`) from `_from`\n     * `_from` the owner of token\n     * `_dstChainId` the destination chain identifier\n     * `_toAddress` can be any size depending on the `dstChainId`.\n     * `_amount` the quantity of tokens in wei\n     * `_refundAddress` the address LayerZero refunds if too much message fee is sent\n     * `_zroPaymentAddress` set to address(0x0) if not paying in ZRO (LayerZero Token)\n     * `_adapterParams` is a flexible bytes array to indicate messaging adapter services\n     */\n    function sendFrom(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, LzCallParams calldata _callParams) external payable;\n\n    function sendAndCall(address _from, uint16 _dstChainId, bytes32 _toAddress, uint _amount, bytes calldata _payload, uint64 _dstGasForCall, LzCallParams calldata _callParams) external payable;\n}\n"
    },
    "@layerzerolabs/solidity-examples/contracts/token/oft/v2/OFTCoreV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../../../lzApp/NonblockingLzApp.sol\";\nimport \"../../../libraries/ExcessivelySafeCall.sol\";\nimport \"./interfaces/ICommonOFT.sol\";\nimport \"./interfaces/IOFTReceiverV2.sol\";\n\nabstract contract OFTCoreV2 is NonblockingLzApp {\n    using BytesLib for bytes;\n    using ExcessivelySafeCall for address;\n\n    uint public constant NO_EXTRA_GAS = 0;\n\n    // packet type\n    uint8 public constant PT_SEND = 0;\n    uint8 public constant PT_SEND_AND_CALL = 1;\n\n    uint8 public immutable sharedDecimals;\n\n    mapping(uint16 => mapping(bytes => mapping(uint64 => bool))) public creditedPackets;\n\n    /**\n     * @dev Emitted when `_amount` tokens are moved from the `_sender` to (`_dstChainId`, `_toAddress`)\n     * `_nonce` is the outbound nonce\n     */\n    event SendToChain(uint16 indexed _dstChainId, address indexed _from, bytes32 indexed _toAddress, uint _amount);\n\n    /**\n     * @dev Emitted when `_amount` tokens are received from `_srcChainId` into the `_toAddress` on the local chain.\n     * `_nonce` is the inbound nonce.\n     */\n    event ReceiveFromChain(uint16 indexed _srcChainId, address indexed _to, uint _amount);\n\n    event CallOFTReceivedSuccess(uint16 indexed _srcChainId, bytes _srcAddress, uint64 _nonce, bytes32 _hash);\n\n    event NonContractAddress(address _address);\n\n    // _sharedDecimals should be the minimum decimals on all chains\n    constructor(uint8 _sharedDecimals, address _lzEndpoint) NonblockingLzApp(_lzEndpoint) {\n        sharedDecimals = _sharedDecimals;\n    }\n\n    /************************************************************************\n     * public functions\n     ************************************************************************/\n    function callOnOFTReceived(\n        uint16 _srcChainId,\n        bytes calldata _srcAddress,\n        uint64 _nonce,\n        bytes32 _from,\n        address _to,\n        uint _amount,\n        bytes calldata _payload,\n        uint _gasForCall\n    ) public virtual {\n        require(_msgSender() == address(this), \"OFTCore: caller must be OFTCore\");\n\n        // send\n        _amount = _transferFrom(address(this), _to, _amount);\n        emit ReceiveFromChain(_srcChainId, _to, _amount);\n\n        // call\n        IOFTReceiverV2(_to).onOFTReceived{gas: _gasForCall}(_srcChainId, _srcAddress, _nonce, _from, _amount, _payload);\n    }\n\n    /************************************************************************\n     * internal functions\n     ************************************************************************/\n    function _estimateSendFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) internal view virtual returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendFrom()\n        bytes memory payload = _encodeSendPayload(_toAddress, _ld2sd(_amount));\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function _estimateSendAndCallFee(\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes memory _payload,\n        uint64 _dstGasForCall,\n        bool _useZro,\n        bytes memory _adapterParams\n    ) internal view virtual returns (uint nativeFee, uint zroFee) {\n        // mock the payload for sendAndCall()\n        bytes memory payload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(_amount), _payload, _dstGasForCall);\n        return lzEndpoint.estimateFees(_dstChainId, address(this), payload, _useZro, _adapterParams);\n    }\n\n    function _nonblockingLzReceive(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual override {\n        uint8 packetType = _payload.toUint8(0);\n\n        if (packetType == PT_SEND) {\n            _sendAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else if (packetType == PT_SEND_AND_CALL) {\n            _sendAndCallAck(_srcChainId, _srcAddress, _nonce, _payload);\n        } else {\n            revert(\"OFTCore: unknown packet type\");\n        }\n    }\n\n    function _send(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal virtual returns (uint amount) {\n        _checkGasLimit(_dstChainId, PT_SEND, _adapterParams, NO_EXTRA_GAS);\n\n        (amount, ) = _removeDust(_amount);\n        amount = _debitFrom(_from, _dstChainId, _toAddress, amount); // amount returned should not have dust\n        require(amount > 0, \"OFTCore: amount too small\");\n\n        bytes memory lzPayload = _encodeSendPayload(_toAddress, _ld2sd(amount));\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAck(\n        uint16 _srcChainId,\n        bytes memory,\n        uint64,\n        bytes memory _payload\n    ) internal virtual {\n        (address to, uint64 amountSD) = _decodeSendPayload(_payload);\n        if (to == address(0)) {\n            to = address(0xdead);\n        }\n\n        uint amount = _sd2ld(amountSD);\n        amount = _creditTo(_srcChainId, to, amount);\n\n        emit ReceiveFromChain(_srcChainId, to, amount);\n    }\n\n    function _sendAndCall(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount,\n        bytes memory _payload,\n        uint64 _dstGasForCall,\n        address payable _refundAddress,\n        address _zroPaymentAddress,\n        bytes memory _adapterParams\n    ) internal virtual returns (uint amount) {\n        _checkGasLimit(_dstChainId, PT_SEND_AND_CALL, _adapterParams, _dstGasForCall);\n\n        (amount, ) = _removeDust(_amount);\n        amount = _debitFrom(_from, _dstChainId, _toAddress, amount);\n        require(amount > 0, \"OFTCore: amount too small\");\n\n        // encode the msg.sender into the payload instead of _from\n        bytes memory lzPayload = _encodeSendAndCallPayload(msg.sender, _toAddress, _ld2sd(amount), _payload, _dstGasForCall);\n        _lzSend(_dstChainId, lzPayload, _refundAddress, _zroPaymentAddress, _adapterParams, msg.value);\n\n        emit SendToChain(_dstChainId, _from, _toAddress, amount);\n    }\n\n    function _sendAndCallAck(\n        uint16 _srcChainId,\n        bytes memory _srcAddress,\n        uint64 _nonce,\n        bytes memory _payload\n    ) internal virtual {\n        (bytes32 from, address to, uint64 amountSD, bytes memory payloadForCall, uint64 gasForCall) = _decodeSendAndCallPayload(_payload);\n\n        bool credited = creditedPackets[_srcChainId][_srcAddress][_nonce];\n        uint amount = _sd2ld(amountSD);\n\n        // credit to this contract first, and then transfer to receiver only if callOnOFTReceived() succeeds\n        if (!credited) {\n            amount = _creditTo(_srcChainId, address(this), amount);\n            creditedPackets[_srcChainId][_srcAddress][_nonce] = true;\n        }\n\n        if (!_isContract(to)) {\n            emit NonContractAddress(to);\n            return;\n        }\n\n        // workaround for stack too deep\n        uint16 srcChainId = _srcChainId;\n        bytes memory srcAddress = _srcAddress;\n        uint64 nonce = _nonce;\n        bytes memory payload = _payload;\n        bytes32 from_ = from;\n        address to_ = to;\n        uint amount_ = amount;\n        bytes memory payloadForCall_ = payloadForCall;\n\n        // no gas limit for the call if retry\n        uint gas = credited ? gasleft() : gasForCall;\n        (bool success, bytes memory reason) = address(this).excessivelySafeCall(\n            gasleft(),\n            150,\n            abi.encodeWithSelector(this.callOnOFTReceived.selector, srcChainId, srcAddress, nonce, from_, to_, amount_, payloadForCall_, gas)\n        );\n\n        if (success) {\n            bytes32 hash = keccak256(payload);\n            emit CallOFTReceivedSuccess(srcChainId, srcAddress, nonce, hash);\n        } else {\n            // store the failed message into the nonblockingLzApp\n            _storeFailedMessage(srcChainId, srcAddress, nonce, payload, reason);\n        }\n    }\n\n    function _isContract(address _account) internal view returns (bool) {\n        return _account.code.length > 0;\n    }\n\n    function _ld2sd(uint _amount) internal view virtual returns (uint64) {\n        uint amountSD = _amount / _ld2sdRate();\n        require(amountSD <= type(uint64).max, \"OFTCore: amountSD overflow\");\n        return uint64(amountSD);\n    }\n\n    function _sd2ld(uint64 _amountSD) internal view virtual returns (uint) {\n        return _amountSD * _ld2sdRate();\n    }\n\n    function _removeDust(uint _amount) internal view virtual returns (uint amountAfter, uint dust) {\n        dust = _amount % _ld2sdRate();\n        amountAfter = _amount - dust;\n    }\n\n    function _encodeSendPayload(bytes32 _toAddress, uint64 _amountSD) internal view virtual returns (bytes memory) {\n        return abi.encodePacked(PT_SEND, _toAddress, _amountSD);\n    }\n\n    function _decodeSendPayload(bytes memory _payload) internal view virtual returns (address to, uint64 amountSD) {\n        require(_payload.toUint8(0) == PT_SEND && _payload.length == 41, \"OFTCore: invalid payload\");\n\n        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32\n        amountSD = _payload.toUint64(33);\n    }\n\n    function _encodeSendAndCallPayload(\n        address _from,\n        bytes32 _toAddress,\n        uint64 _amountSD,\n        bytes memory _payload,\n        uint64 _dstGasForCall\n    ) internal view virtual returns (bytes memory) {\n        return abi.encodePacked(PT_SEND_AND_CALL, _toAddress, _amountSD, _addressToBytes32(_from), _dstGasForCall, _payload);\n    }\n\n    function _decodeSendAndCallPayload(bytes memory _payload)\n        internal\n        view\n        virtual\n        returns (\n            bytes32 from,\n            address to,\n            uint64 amountSD,\n            bytes memory payload,\n            uint64 dstGasForCall\n        )\n    {\n        require(_payload.toUint8(0) == PT_SEND_AND_CALL, \"OFTCore: invalid payload\");\n\n        to = _payload.toAddress(13); // drop the first 12 bytes of bytes32\n        amountSD = _payload.toUint64(33);\n        from = _payload.toBytes32(41);\n        dstGasForCall = _payload.toUint64(73);\n        payload = _payload.slice(81, _payload.length - 81);\n    }\n\n    function _addressToBytes32(address _address) internal pure virtual returns (bytes32) {\n        return bytes32(uint(uint160(_address)));\n    }\n\n    function _debitFrom(\n        address _from,\n        uint16 _dstChainId,\n        bytes32 _toAddress,\n        uint _amount\n    ) internal virtual returns (uint);\n\n    function _creditTo(\n        uint16 _srcChainId,\n        address _toAddress,\n        uint _amount\n    ) internal virtual returns (uint);\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal virtual returns (uint);\n\n    function _ld2sdRate() internal view virtual returns (uint);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/utils/ERC721Holder.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721ReceiverUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC721Receiver} interface.\n *\n * Accepts all token transfers.\n * Make sure the contract is able to use its token with {IERC721-safeTransferFrom}, {IERC721-approve} or {IERC721-setApprovalForAll}.\n */\ncontract ERC721HolderUpgradeable is Initializable, IERC721ReceiverUpgradeable {\n    function __ERC721Holder_init() internal onlyInitializing {\n    }\n\n    function __ERC721Holder_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     *\n     * Always returns `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(address, address, uint256, bytes memory) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC1967.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC1967.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC-1967: Proxy Storage Slots. This interface contains the events defined in the ERC.\n *\n * _Available since v4.8.3._\n */\ninterface IERC1967 {\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Emitted when the beacon is changed.\n     */\n    event BeaconUpgraded(address indexed beacon);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/beacon/BeaconProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IBeacon.sol\";\nimport \"../Proxy.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements a proxy that gets the implementation address for each call from an {UpgradeableBeacon}.\n *\n * The beacon address is stored in storage slot `uint256(keccak256('eip1967.proxy.beacon')) - 1`, so that it doesn't\n * conflict with the storage layout of the implementation behind the proxy.\n *\n * _Available since v3.4._\n */\ncontract BeaconProxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializing the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IBeacon(_getBeacon()).implementation();\n    }\n\n    /**\n     * @dev Changes the proxy to use a new beacon. Deprecated: see {_upgradeBeaconToAndCall}.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract.\n     * - The implementation returned by `beacon` must be a contract.\n     */\n    function _setBeacon(address beacon, bytes memory data) internal virtual {\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/IERC1967.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n */\nabstract contract ERC1967Upgrade is IERC1967 {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(address newImplementation, bytes memory data, bool forceCall) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(address newImplementation, bytes memory data, bool forceCall) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(address newBeacon, bytes memory data, bool forceCall) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev Interface for {TransparentUpgradeableProxy}. In order to implement transparency, {TransparentUpgradeableProxy}\n * does not implement this interface directly, and some of its functions are implemented by an internal dispatch\n * mechanism. The compiler is unaware that these functions are implemented by {TransparentUpgradeableProxy} and will not\n * include them in the ABI so this interface must be used to interact with it.\n */\ninterface ITransparentUpgradeableProxy is IERC1967 {\n    function admin() external view returns (address);\n\n    function implementation() external view returns (address);\n\n    function changeAdmin(address) external;\n\n    function upgradeTo(address) external;\n\n    function upgradeToAndCall(address, bytes memory) external payable;\n}\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n *\n * NOTE: The real interface of this proxy is that defined in `ITransparentUpgradeableProxy`. This contract does not\n * inherit from that interface, and instead the admin functions are implicitly implemented using a custom dispatch\n * mechanism in `_fallback`. Consequently, the compiler will not produce an ABI for this contract. This is necessary to\n * fully implement transparency without decoding reverts caused by selector clashes between the proxy and the\n * implementation.\n *\n * WARNING: It is not recommended to extend this contract to add additional external functions. If you do so, the compiler\n * will not check that there are no selector conflicts, due to the note above. A selector clash between any new function\n * and the functions declared in {ITransparentUpgradeableProxy} will be resolved in favor of the new one. This could\n * render the admin operations inaccessible, which could prevent upgradeability. Transparency may also be compromised.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(address _logic, address admin_, bytes memory _data) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     *\n     * CAUTION: This modifier is deprecated, as it could cause issues if the modified function has arguments, and the\n     * implementation provides a function with the same selector.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev If caller is the admin process the call internally, otherwise transparently fallback to the proxy behavior\n     */\n    function _fallback() internal virtual override {\n        if (msg.sender == _getAdmin()) {\n            bytes memory ret;\n            bytes4 selector = msg.sig;\n            if (selector == ITransparentUpgradeableProxy.upgradeTo.selector) {\n                ret = _dispatchUpgradeTo();\n            } else if (selector == ITransparentUpgradeableProxy.upgradeToAndCall.selector) {\n                ret = _dispatchUpgradeToAndCall();\n            } else if (selector == ITransparentUpgradeableProxy.changeAdmin.selector) {\n                ret = _dispatchChangeAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.admin.selector) {\n                ret = _dispatchAdmin();\n            } else if (selector == ITransparentUpgradeableProxy.implementation.selector) {\n                ret = _dispatchImplementation();\n            } else {\n                revert(\"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n            }\n            assembly {\n                return(add(ret, 0x20), mload(ret))\n            }\n        } else {\n            super._fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function _dispatchAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address admin = _getAdmin();\n        return abi.encode(admin);\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function _dispatchImplementation() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address implementation = _implementation();\n        return abi.encode(implementation);\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _dispatchChangeAdmin() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newAdmin = abi.decode(msg.data[4:], (address));\n        _changeAdmin(newAdmin);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     */\n    function _dispatchUpgradeTo() private returns (bytes memory) {\n        _requireZeroValue();\n\n        address newImplementation = abi.decode(msg.data[4:], (address));\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     */\n    function _dispatchUpgradeToAndCall() private returns (bytes memory) {\n        (address newImplementation, bytes memory data) = abi.decode(msg.data[4:], (address, bytes));\n        _upgradeToAndCall(newImplementation, data, true);\n\n        return \"\";\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * CAUTION: This function is deprecated. Use {ERC1967Upgrade-_getAdmin} instead.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev To keep this contract fully transparent, all `ifAdmin` functions must be payable. This helper is here to\n     * emulate some proxy functions being non-payable while still allowing value to pass through.\n     */\n    function _requireZeroValue() private {\n        require(msg.value == 0);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../ERC1967/ERC1967Upgrade.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is IERC1822Proxiable, ERC1967Upgrade {\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate the implementation's compatibility when performing an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeTo(address newImplementation) public virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     *\n     * @custom:oz-upgrades-unsafe-allow-reachable delegatecall\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) public payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _ownerOf(tokenId);\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner or approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner or approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _ownerOf(tokenId) != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId, 1);\n\n        // Check that tokenId was not minted by `_beforeTokenTransfer` hook\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        unchecked {\n            // Will not overflow unless all 2**256 token ids are minted to the same owner.\n            // Given that tokens are minted one by one, it is impossible in practice that\n            // this ever happens. Might change if we allow batch minting.\n            // The ERC fails to describe this case.\n            _balances[to] += 1;\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId, 1);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId, 1);\n\n        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook\n        owner = ERC721.ownerOf(tokenId);\n\n        // Clear approvals\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // Cannot overflow, as that would require more tokens to be burned/transferred\n            // out than the owner initially received through minting and transferring in.\n            _balances[owner] -= 1;\n        }\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId, 1);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId, 1);\n\n        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n\n        // Clear approvals from the previous owner\n        delete _tokenApprovals[tokenId];\n\n        unchecked {\n            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:\n            // `from`'s balance is the number of token held, which is at least one before the current\n            // transfer.\n            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require\n            // all 2**256 token ids to be minted, which in practice is impossible.\n            _balances[from] -= 1;\n            _balances[to] += 1;\n        }\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId, 1);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.\n     * - When `from` is zero, the tokens will be minted for `to`.\n     * - When `to` is zero, ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is\n     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.\n     * - When `from` is zero, the tokens were minted for `to`.\n     * - When `to` is zero, ``from``'s tokens were burned.\n     * - `from` and `to` are never both zero.\n     * - `batchSize` is non-zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant\n     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such\n     * that `ownerOf(tokenId)` is `a`.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function __unsafe_increaseBalance(address account, uint256 amount) internal {\n        _balances[account] += amount;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev See {ERC721-_beforeTokenTransfer}.\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n\n        if (batchSize > 1) {\n            // Will only trigger during construction. Batch transferring (minting) is not available afterwards.\n            revert(\"ERC721Enumerable: consecutive transfers not supported\");\n        }\n\n        uint256 tokenId = firstTokenId;\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n  using SafeMath for uint256;\n\n  error DataPackageTimestampMustNotBeZero();\n  error DataPackageTimestampsMustBeEqual();\n  error RedstonePayloadMustHaveAtLeastOneDataPackage();\n\n  function extractTimestampsAndAssertAllAreEqual() public pure returns (uint256 extractedTimestamp) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    if (dataPackagesCount == 0) {\n      revert RedstonePayloadMustHaveAtLeastOneDataPackage();\n    }\n\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n\n      // Extracting timestamp for the current data package\n      uint48 dataPackageTimestamp; // uint48, because timestamp uses 6 bytes\n      uint256 timestampNegativeOffset = (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n      uint256 timestampOffset = msg.data.length - timestampNegativeOffset;\n      assembly {\n        dataPackageTimestamp := calldataload(timestampOffset)\n      }\n\n      if (dataPackageTimestamp == 0) {\n        revert DataPackageTimestampMustNotBeZero();\n      }\n\n      if (extractedTimestamp == 0) {\n        extractedTimestamp = dataPackageTimestamp;\n      } else if (dataPackageTimestamp != extractedTimestamp) {\n        revert DataPackageTimestampsMustBeEqual();\n      }\n\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) internal pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return dataPackagesCount;\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 calldataNegativeOffsetForDataPackage,\n    uint256 defaultDataPointValueByteSize,\n    uint256 dataPointIndex\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n    uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n      (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n    );\n    uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n    uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\nimport \"./CalldataExtractor.sol\";\n\n/**\n * @title The base contract for forwarding redstone payload to other contracts\n * @author The Redstone Oracles team\n */\ncontract ProxyConnector is RedstoneConstants, CalldataExtractor {\n  error ProxyCalldataFailedWithoutErrMsg();\n  error ProxyCalldataFailedWithStringMessage(string message);\n  error ProxyCalldataFailedWithCustomError(bytes result);\n\n  function proxyCalldata(\n    address contractAddress,\n    bytes memory encodedFunction,\n    bool forwardValue\n  ) internal returns (bytes memory) {\n    bytes memory message = _prepareMessage(encodedFunction);\n\n    (bool success, bytes memory result) =\n      contractAddress.call{value: forwardValue ? msg.value : 0}(message);\n\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyDelegateCalldata(address contractAddress, bytes memory encodedFunction)\n    internal\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.delegatecall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyCalldataView(address contractAddress, bytes memory encodedFunction)\n    internal\n    view\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.staticcall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function _prepareMessage(bytes memory encodedFunction) private pure returns (bytes memory) {\n    uint256 encodedFunctionBytesCount = encodedFunction.length;\n    uint256 redstonePayloadByteSize = _getRedstonePayloadByteSize();\n    uint256 resultMessageByteSize = encodedFunctionBytesCount + redstonePayloadByteSize;\n\n    if (redstonePayloadByteSize > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n\n    bytes memory message;\n\n    assembly {\n      message := mload(FREE_MEMORY_PTR) // sets message pointer to first free place in memory\n\n      // Saving the byte size of the result message (it's a standard in EVM)\n      mstore(message, resultMessageByteSize)\n\n      // Copying function and its arguments\n      for {\n        let from := add(BYTES_ARR_LEN_VAR_BS, encodedFunction)\n        let fromEnd := add(from, encodedFunctionBytesCount)\n        let to := add(BYTES_ARR_LEN_VAR_BS, message)\n      } lt (from, fromEnd) {\n        from := add(from, STANDARD_SLOT_BS)\n        to := add(to, STANDARD_SLOT_BS)\n      } {\n        // Copying data from encodedFunction to message (32 bytes at a time)\n        mstore(to, mload(from))\n      }\n\n      // Copying redstone payload to the message bytes\n      calldatacopy(\n        add(message, add(BYTES_ARR_LEN_VAR_BS, encodedFunctionBytesCount)), // address\n        sub(calldatasize(), redstonePayloadByteSize), // offset\n        redstonePayloadByteSize // bytes length to copy\n      )\n\n      // Updating free memory pointer\n      mstore(\n        FREE_MEMORY_PTR,\n        add(\n          add(message, add(redstonePayloadByteSize, encodedFunctionBytesCount)),\n          BYTES_ARR_LEN_VAR_BS\n        )\n      )\n    }\n\n    return message;\n  }\n\n  function _getRedstonePayloadByteSize() private pure returns (uint256) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n\n    return calldataNegativeOffset;\n  }\n\n  function _prepareReturnValue(bool success, bytes memory result)\n    internal\n    pure\n    returns (bytes memory)\n  {\n    if (!success) {\n\n      if (result.length == 0) {\n        revert ProxyCalldataFailedWithoutErrMsg();\n      } else {\n        bool isStringErrorMessage;\n        assembly {\n          let first32BytesOfResult := mload(add(result, BYTES_ARR_LEN_VAR_BS))\n          isStringErrorMessage := eq(first32BytesOfResult, STRING_ERR_MESSAGE_MASK)\n        }\n\n        if (isStringErrorMessage) {\n          string memory receivedErrMsg;\n          assembly {\n            receivedErrMsg := add(result, REVERT_MSG_OFFSET)\n          }\n          revert ProxyCalldataFailedWithStringMessage(receivedErrMsg);\n        } else {\n          revert ProxyCalldataFailedWithCustomError(result);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\nimport \"./RedstoneDefaultsLib.sol\";\nimport \"./CalldataExtractor.sol\";\nimport \"../libs/BitmapLib.sol\";\nimport \"../libs/SignatureLib.sol\";\n\n/**\n * @title The base contract with the main Redstone logic\n * @author The Redstone Oracles team\n * @dev Do not use this contract directly in consumer contracts, take a\n * look at `RedstoneConsumerNumericBase` and `RedstoneConsumerBytesBase` instead\n */\nabstract contract RedstoneConsumerBase is CalldataExtractor {\n  using SafeMath for uint256;\n\n  error GetDataServiceIdNotImplemented();\n\n  /* ========== VIRTUAL FUNCTIONS (MAY BE OVERRIDDEN IN CHILD CONTRACTS) ========== */\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return dataServiceId which DataServiceWrapper will use if not provided explicitly .\n   * If not overridden, value will always have to be provided explicitly in DataServiceWrapper.\n   * @return dataServiceId being consumed by contract\n   */\n  function getDataServiceId() public view virtual returns (string memory) {\n    revert GetDataServiceIdNotImplemented();\n  }\n\n  /**\n   * @dev This function must be implemented by the child consumer contract.\n   * It should return a unique index for a given signer address if the signer\n   * is authorised, otherwise it should revert\n   * @param receivedSigner The address of a signer, recovered from ECDSA signature\n   * @return Unique index for a signer in the range [0..255]\n   */\n  function getAuthorisedSignerIndex(address receivedSigner) public view virtual returns (uint8);\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should validate the timestamp against the current time (block.timestamp)\n   * It should revert with a helpful message if the timestamp is not valid\n   * @param receivedTimestampMilliseconds Timestamp extracted from calldata\n   */\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual {\n    RedstoneDefaultsLib.validateTimestamp(receivedTimestampMilliseconds);\n  }\n\n  /**\n   * @dev This function should be overridden by the child consumer contract.\n   * @return The minimum required value of unique authorised signers\n   */\n  function getUniqueSignersThreshold() public view virtual returns (uint8) {\n    return 1;\n  }\n\n  /**\n   * @dev This function may be overridden by the child consumer contract.\n   * It should aggregate values from different signers to a single uint value.\n   * By default, it calculates the median value\n   * @param values An array of uint256 values from different signers\n   * @return Result of the aggregation in the form of a single number\n   */\n  function aggregateValues(uint256[] memory values) public view virtual returns (uint256) {\n    return RedstoneDefaultsLib.aggregateValues(values);\n  }\n\n  /* ========== FUNCTIONS WITH IMPLEMENTATION (CAN NOT BE OVERRIDDEN) ========== */\n\n  /**\n   * @dev This is an internal helpful function for secure extraction oracle values\n   * from the tx calldata. Security is achieved by signatures verification, timestamp\n   * validation, and aggregating values from different authorised signers into a\n   * single numeric value. If any of the required conditions (e.g. too old timestamp or\n   * insufficient number of authorised signers) do not match, the function will revert.\n   *\n   * Note! You should not call this function in a consumer contract. You can use\n   * `getOracleNumericValuesFromTxMsg` or `getOracleNumericValueFromTxMsg` instead.\n   *\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in dataFeedIds array\n   */\n  function _securelyExtractOracleValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    returns (uint256[] memory)\n  {\n    // Initializing helpful variables and allocating memory\n    uint256[] memory uniqueSignerCountForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[] memory signersBitmapForDataFeedIds = new uint256[](dataFeedIds.length);\n    uint256[][] memory valuesForDataFeeds = new uint256[][](dataFeedIds.length);\n    for (uint256 i = 0; i < dataFeedIds.length; i++) {\n      // The line below is commented because newly allocated arrays are filled with zeros\n      // But we left it for better readability\n      // signersBitmapForDataFeedIds[i] = 0; // <- setting to an empty bitmap\n      valuesForDataFeeds[i] = new uint256[](getUniqueSignersThreshold());\n    }\n\n    // Extracting the number of data packages from calldata\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n\n    // Saving current free memory pointer\n    uint256 freeMemPtr;\n    assembly {\n      freeMemPtr := mload(FREE_MEMORY_PTR)\n    }\n\n    // Data packages extraction in a loop\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      // Extract data package details and update calldata offset\n      uint256 dataPackageByteSize = _extractDataPackage(\n        dataFeedIds,\n        uniqueSignerCountForDataFeedIds,\n        signersBitmapForDataFeedIds,\n        valuesForDataFeeds,\n        calldataNegativeOffset\n      );\n      calldataNegativeOffset += dataPackageByteSize;\n\n      // Shifting memory pointer back to the \"safe\" value\n      assembly {\n        mstore(FREE_MEMORY_PTR, freeMemPtr)\n      }\n    }\n\n    // Validating numbers of unique signers and calculating aggregated values for each dataFeedId\n    return _getAggregatedValues(valuesForDataFeeds, uniqueSignerCountForDataFeedIds);\n  }\n\n  /**\n   * @dev This is a private helpful function, which extracts data for a data package based\n   * on the given negative calldata offset, verifies them, and in the case of successful\n   * verification updates the corresponding data package values in memory\n   *\n   * @param dataFeedIds an array of unique data feed identifiers\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   * @param signersBitmapForDataFeedIds an array of signer bitmaps for data feeds\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param calldataNegativeOffset negative calldata offset for the given data package\n   *\n   * @return An array of the aggregated values\n   */\n  function _extractDataPackage(\n    bytes32[] memory dataFeedIds,\n    uint256[] memory uniqueSignerCountForDataFeedIds,\n    uint256[] memory signersBitmapForDataFeedIds,\n    uint256[][] memory valuesForDataFeeds,\n    uint256 calldataNegativeOffset\n  ) private view returns (uint256) {\n    uint256 signerIndex;\n\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    // We use scopes to resolve problem with too deep stack\n    {\n      uint48 extractedTimestamp;\n      address signerAddress;\n      bytes32 signedHash;\n      bytes memory signedMessage;\n      uint256 signedMessageBytesCount;\n\n      signedMessageBytesCount = dataPointsCount.mul(eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS)\n        + DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS; //DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n\n      uint256 timestampCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n\n      uint256 signedMessageCalldataOffset = msg.data.length.sub(\n        calldataNegativeOffset + SIG_BS + signedMessageBytesCount);\n\n      assembly {\n        // Extracting the signed message\n        signedMessage := extractBytesFromCalldata(\n          signedMessageCalldataOffset,\n          signedMessageBytesCount\n        )\n\n        // Hashing the signed message\n        signedHash := keccak256(add(signedMessage, BYTES_ARR_LEN_VAR_BS), signedMessageBytesCount)\n\n        // Extracting timestamp\n        extractedTimestamp := calldataload(timestampCalldataOffset)\n\n        function initByteArray(bytesCount) -> ptr {\n          ptr := mload(FREE_MEMORY_PTR)\n          mstore(ptr, bytesCount)\n          ptr := add(ptr, BYTES_ARR_LEN_VAR_BS)\n          mstore(FREE_MEMORY_PTR, add(ptr, bytesCount))\n        }\n\n        function extractBytesFromCalldata(offset, bytesCount) -> extractedBytes {\n          let extractedBytesStartPtr := initByteArray(bytesCount)\n          calldatacopy(\n            extractedBytesStartPtr,\n            offset,\n            bytesCount\n          )\n          extractedBytes := sub(extractedBytesStartPtr, BYTES_ARR_LEN_VAR_BS)\n        }\n      }\n\n      // Validating timestamp\n      validateTimestamp(extractedTimestamp);\n\n      // Verifying the off-chain signature against on-chain hashed data\n      signerAddress = SignatureLib.recoverSignerAddress(\n        signedHash,\n        calldataNegativeOffset + SIG_BS\n      );\n      signerIndex = getAuthorisedSignerIndex(signerAddress);\n    }\n\n    // Updating helpful arrays\n    {\n      bytes32 dataPointDataFeedId;\n      uint256 dataPointValue;\n      for (uint256 dataPointIndex = 0; dataPointIndex < dataPointsCount; dataPointIndex++) {\n        // Extracting data feed id and value for the current data point\n        (dataPointDataFeedId, dataPointValue) = _extractDataPointValueAndDataFeedId(\n          calldataNegativeOffset,\n          eachDataPointValueByteSize,\n          dataPointIndex\n        );\n\n        for (\n          uint256 dataFeedIdIndex = 0;\n          dataFeedIdIndex < dataFeedIds.length;\n          dataFeedIdIndex++\n        ) {\n          if (dataPointDataFeedId == dataFeedIds[dataFeedIdIndex]) {\n            uint256 bitmapSignersForDataFeedId = signersBitmapForDataFeedIds[dataFeedIdIndex];\n\n            if (\n              !BitmapLib.getBitFromBitmap(bitmapSignersForDataFeedId, signerIndex) && /* current signer was not counted for current dataFeedId */\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex] < getUniqueSignersThreshold()\n            ) {\n              // Increase unique signer counter\n              uniqueSignerCountForDataFeedIds[dataFeedIdIndex]++;\n\n              // Add new value\n              valuesForDataFeeds[dataFeedIdIndex][\n                uniqueSignerCountForDataFeedIds[dataFeedIdIndex] - 1\n              ] = dataPointValue;\n\n              // Update signers bitmap\n              signersBitmapForDataFeedIds[dataFeedIdIndex] = BitmapLib.setBitInBitmap(\n                bitmapSignersForDataFeedId,\n                signerIndex\n              );\n            }\n\n            // Breaking, as there couldn't be several indexes for the same feed ID\n            break;\n          }\n        }\n      }\n    }\n\n    // Return total data package byte size\n    return\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS +\n      (eachDataPointValueByteSize + DATA_POINT_SYMBOL_BS) *\n      dataPointsCount;\n  }\n\n  /**\n   * @dev This is a private helpful function, which aggregates values from different\n   * authorised signers for the given arrays of values for each data feed\n   *\n   * @param valuesForDataFeeds 2-dimensional array, valuesForDataFeeds[i][j] contains\n   * j-th value for the i-th data feed\n   * @param uniqueSignerCountForDataFeedIds an array with the numbers of unique signers\n   * for each data feed\n   *\n   * @return An array of the aggregated values\n   */\n  function _getAggregatedValues(\n    uint256[][] memory valuesForDataFeeds,\n    uint256[] memory uniqueSignerCountForDataFeedIds\n  ) private view returns (uint256[] memory) {\n    uint256[] memory aggregatedValues = new uint256[](valuesForDataFeeds.length);\n    uint256 uniqueSignersThreshold = getUniqueSignersThreshold();\n\n    for (uint256 dataFeedIndex = 0; dataFeedIndex < valuesForDataFeeds.length; dataFeedIndex++) {\n      if (uniqueSignerCountForDataFeedIds[dataFeedIndex] < uniqueSignersThreshold) {\n        revert InsufficientNumberOfUniqueSigners(\n          uniqueSignerCountForDataFeedIds[dataFeedIndex],\n          uniqueSignersThreshold);\n      }\n      uint256 aggregatedValueForDataFeedId = aggregateValues(valuesForDataFeeds[dataFeedIndex]);\n      aggregatedValues[dataFeedIndex] = aggregatedValueForDataFeedId;\n    }\n\n    return aggregatedValues;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConsumerBase.sol\";\n\n/**\n * @title The base contract for Redstone consumers' contracts that allows to\n * securely calculate numeric redstone oracle values\n * @author The Redstone Oracles team\n * @dev This contract can extend other contracts to allow them\n * securely fetch Redstone oracle data from transactions calldata\n */\nabstract contract RedstoneConsumerNumericBase is RedstoneConsumerBase {\n  /**\n   * @dev This function can be used in a consumer contract to securely extract an\n   * oracle value for a given data feed id. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedId bytes32 value that uniquely identifies the data feed\n   * @return Extracted and verified numeric oracle value for the given data feed id\n   */\n  function getOracleNumericValueFromTxMsg(bytes32 dataFeedId)\n    internal\n    view\n    virtual\n    returns (uint256)\n  {\n    bytes32[] memory dataFeedIds = new bytes32[](1);\n    dataFeedIds[0] = dataFeedId;\n    return getOracleNumericValuesFromTxMsg(dataFeedIds)[0];\n  }\n\n  /**\n   * @dev This function can be used in a consumer contract to securely extract several\n   * numeric oracle values for a given array of data feed ids. Security is achieved by\n   * signatures verification, timestamp validation, and aggregating values\n   * from different authorised signers into a single numeric value. If any of the\n   * required conditions do not match, the function will revert.\n   * Note! This function expects that tx calldata contains redstone payload in the end\n   * Learn more about redstone payload here: https://github.com/redstone-finance/redstone-oracles-monorepo/tree/main/packages/evm-connector#readme\n   * @param dataFeedIds An array of unique data feed identifiers\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIds array\n   */\n  function getOracleNumericValuesFromTxMsg(bytes32[] memory dataFeedIds)\n    internal\n    view\n    virtual\n    returns (uint256[] memory)\n  {\n    return _securelyExtractOracleValuesFromTxMsg(dataFeedIds);\n  }\n\n  /**\n   * @dev This function works similarly to the `getOracleNumericValuesFromTxMsg` with the\n   * only difference that it allows to request oracle data for an array of data feeds\n   * that may contain duplicates\n   * \n   * @param dataFeedIdsWithDuplicates An array of data feed identifiers (duplicates are allowed)\n   * @return An array of the extracted and verified oracle values in the same order\n   * as they are requested in the dataFeedIdsWithDuplicates array\n   */\n  function getOracleNumericValuesWithDuplicatesFromTxMsg(bytes32[] memory dataFeedIdsWithDuplicates) internal view returns (uint256[] memory) {\n    // Building an array without duplicates\n    bytes32[] memory dataFeedIdsWithoutDuplicates = new bytes32[](dataFeedIdsWithDuplicates.length);\n    bool alreadyIncluded;\n    uint256 uniqueDataFeedIdsCount = 0;\n\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      // Checking if current element is already included in `dataFeedIdsWithoutDuplicates`\n      alreadyIncluded = false;\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < uniqueDataFeedIdsCount; indexWithoutDup++) {\n        if (dataFeedIdsWithoutDuplicates[indexWithoutDup] == dataFeedIdsWithDuplicates[indexWithDup]) {\n          alreadyIncluded = true;\n          break;\n        }\n      }\n\n      // Adding if not included\n      if (!alreadyIncluded) {\n        dataFeedIdsWithoutDuplicates[uniqueDataFeedIdsCount] = dataFeedIdsWithDuplicates[indexWithDup];\n        uniqueDataFeedIdsCount++;\n      }\n    }\n\n    // Overriding dataFeedIdsWithoutDuplicates.length\n    // Equivalent to: dataFeedIdsWithoutDuplicates.length = uniqueDataFeedIdsCount;\n    assembly {\n      mstore(dataFeedIdsWithoutDuplicates, uniqueDataFeedIdsCount)\n    }\n\n    // Requesting oracle values (without duplicates)\n    uint256[] memory valuesWithoutDuplicates = getOracleNumericValuesFromTxMsg(dataFeedIdsWithoutDuplicates);\n\n    // Preparing result values array\n    uint256[] memory valuesWithDuplicates = new uint256[](dataFeedIdsWithDuplicates.length);\n    for (uint256 indexWithDup = 0; indexWithDup < dataFeedIdsWithDuplicates.length; indexWithDup++) {\n      for (uint256 indexWithoutDup = 0; indexWithoutDup < dataFeedIdsWithoutDuplicates.length; indexWithoutDup++) {\n        if (dataFeedIdsWithDuplicates[indexWithDup] == dataFeedIdsWithoutDuplicates[indexWithoutDup]) {\n          valuesWithDuplicates[indexWithDup] = valuesWithoutDuplicates[indexWithoutDup];\n          break;\n        }\n      }\n    }\n\n    return valuesWithDuplicates;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneDefaultsLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../libs/NumericArrayLib.sol\";\n\n/**\n * @title Default implementations of virtual redstone consumer base functions\n * @author The Redstone Oracles team\n */\nlibrary RedstoneDefaultsLib {\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 3 minutes;\n  uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS = 1 minutes;\n\n  error TimestampFromTooLongFuture(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n  error TimestampIsTooOld(uint256 receivedTimestampSeconds, uint256 blockTimestamp);\n\n  function validateTimestamp(uint256 receivedTimestampMilliseconds) internal view {\n    // Getting data timestamp from future seems quite unlikely\n    // But we've already spent too much time with different cases\n    // Where block.timestamp was less than dataPackage.timestamp.\n    // Some blockchains may case this problem as well.\n    // That's why we add MAX_BLOCK_TIMESTAMP_DELAY\n    // and allow data \"from future\" but with a small delay\n    uint256 receivedTimestampSeconds = receivedTimestampMilliseconds / 1000;\n\n    if (block.timestamp < receivedTimestampSeconds) {\n      if ((receivedTimestampSeconds - block.timestamp) > DEFAULT_MAX_DATA_TIMESTAMP_AHEAD_SECONDS) {\n        revert TimestampFromTooLongFuture(receivedTimestampSeconds, block.timestamp);\n      }\n    } else if ((block.timestamp - receivedTimestampSeconds) > DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS) {\n      revert TimestampIsTooOld(receivedTimestampSeconds, block.timestamp);\n    }\n  }\n\n  function aggregateValues(uint256[] memory values) internal pure returns (uint256) {\n    return NumericArrayLib.pickMedian(values);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/data-services/ArbitrumProdDataServiceConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConsumerNumericBase.sol\";\n\ncontract ArbitrumProdDataServiceConsumerBase is RedstoneConsumerNumericBase {\n  function getDataServiceId() public view virtual override returns (string memory) {\n    return \"redstone-arbitrum-prod\";\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 3;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x345Efd26098e173F811e3B9Af1B0e0a11872B38b) {\n      return 0;\n    } else if (signerAddress == 0xbD0c5ccd85D5831B10E3e49527B8Cd67e2EFAf39) {\n      return 1;\n    } else if (signerAddress == 0x2F3E8EC88C01593d10ca9461c807660fF2D8DB28) {\n      return 2;\n    } else if (signerAddress == 0xb7f154bB5491565D215F4EB1c3fe3e84960627aF) {\n      return 3;\n    } else if (signerAddress == 0xE6b0De8F4B31F137d3c59b5a0A71e66e7D504Ef9) {\n      return 4;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/data-services/AvalancheDataServiceConsumerBase.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConsumerNumericBase.sol\";\n\ncontract AvalancheDataServiceConsumerBase is RedstoneConsumerNumericBase {\n  function getDataServiceId() public view virtual override returns (string memory) {\n    return \"redstone-avalanche-prod\";\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 3;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x1eA62d73EdF8AC05DfceA1A34b9796E937a29EfF) {\n      return 0;\n    } else if (signerAddress == 0x2c59617248994D12816EE1Fa77CE0a64eEB456BF) {\n      return 1;\n    } else if (signerAddress == 0x12470f7aBA85c8b81D63137DD5925D6EE114952b) {\n      return 2;\n    } else if (signerAddress == 0x109B4a318A4F5ddcbCA6349B45f881B4137deaFB) {\n      return 3;\n    } else if (signerAddress == 0x83cbA8c619fb629b81A65C2e67fE15cf3E3C9747) {\n      return 4;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/BitmapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary BitmapLib {\n  function setBitInBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (uint256) {\n    return bitmap | (1 << bitIndex);\n  }\n\n  function getBitFromBitmap(uint256 bitmap, uint256 bitIndex) internal pure returns (bool) {\n    uint256 bitAtIndex = bitmap & (1 << bitIndex);\n    return bitAtIndex > 0;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/NumericArrayLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nlibrary NumericArrayLib {\n  // This function sort array in memory using bubble sort algorithm,\n  // which performs even better than quick sort for small arrays\n\n  uint256 constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 constant UINT256_VALUE_BS = 32;\n\n  error CanNotPickMedianOfEmptyArray();\n\n  // This function modifies the array\n  function pickMedian(uint256[] memory arr) internal pure returns (uint256) {\n    if (arr.length == 0) {\n      revert CanNotPickMedianOfEmptyArray();\n    }\n    sort(arr);\n    uint256 middleIndex = arr.length / 2;\n    if (arr.length % 2 == 0) {\n      uint256 sum = SafeMath.add(arr[middleIndex - 1], arr[middleIndex]);\n      return sum / 2;\n    } else {\n      return arr[middleIndex];\n    }\n  }\n\n  function sort(uint256[] memory arr) internal pure {\n    assembly {\n      let arrLength := mload(arr)\n      let valuesPtr := add(arr, BYTES_ARR_LEN_VAR_BS)\n      let endPtr := add(valuesPtr, mul(arrLength, UINT256_VALUE_BS))\n      for {\n        let arrIPtr := valuesPtr\n      } lt(arrIPtr, endPtr) {\n        arrIPtr := add(arrIPtr, UINT256_VALUE_BS) // arrIPtr += 32\n      } {\n        for {\n          let arrJPtr := valuesPtr\n        } lt(arrJPtr, arrIPtr) {\n          arrJPtr := add(arrJPtr, UINT256_VALUE_BS) // arrJPtr += 32\n        } {\n          let arrI := mload(arrIPtr)\n          let arrJ := mload(arrJPtr)\n          if lt(arrI, arrJ) {\n            mstore(arrIPtr, arrJ)\n            mstore(arrJPtr, arrI)\n          }\n        }\n      }\n    }\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/libs/SignatureLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nlibrary SignatureLib {\n  uint256 constant ECDSA_SIG_R_BS = 32;\n  uint256 constant ECDSA_SIG_S_BS = 32;\n\n  function recoverSignerAddress(bytes32 signedHash, uint256 signatureCalldataNegativeOffset)\n    internal\n    pure\n    returns (address)\n  {\n    bytes32 r;\n    bytes32 s;\n    uint8 v;\n    assembly {\n      let signatureCalldataStartPos := sub(calldatasize(), signatureCalldataNegativeOffset)\n      r := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_R_BS)\n      s := calldataload(signatureCalldataStartPos)\n      signatureCalldataStartPos := add(signatureCalldataStartPos, ECDSA_SIG_S_BS)\n      v := byte(0, calldataload(signatureCalldataStartPos)) // last byte of the signature memory array\n    }\n    return ecrecover(signedHash, v, r, s);\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\nimport \"../core/RedstoneConstants.sol\";\n\nabstract contract AuthorisedMockSignersBase is RedstoneConstants {\n  function getAuthorisedMockSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    returns (uint8)\n  {\n    return getAllMockExceptLastOneAuthorised(signerAddress);\n  }\n\n  function getAllMockExceptLastOneAuthorised(address signerAddress)\n    public\n    view\n    virtual\n    returns (uint8)\n  {\n    if (signerAddress == 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199) {\n      revert SignerNotAuthorised(signerAddress);\n    } else {\n      return getAllMockAuthorised(signerAddress);\n    }\n  }\n\n  function getAllMockAuthorised(address signerAddress) public view virtual returns (uint8) {\n    // Looks like an array but consumes less gas\n    if (signerAddress == 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) {\n      return 0;\n    } else if (signerAddress == 0x70997970C51812dc3A010C7d01b50e0d17dc79C8) {\n      return 1;\n    } else if (signerAddress == 0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC) {\n      return 2;\n    } else if (signerAddress == 0x90F79bf6EB2c4f870365E785982E1f101E93b906) {\n      return 3;\n    } else if (signerAddress == 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65) {\n      return 4;\n    } else if (signerAddress == 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc) {\n      return 5;\n    } else if (signerAddress == 0x976EA74026E726554dB657fA54763abd0C3a0aa9) {\n      return 6;\n    } else if (signerAddress == 0x14dC79964da2C08b23698B3D3cc7Ca32193d9955) {\n      return 7;\n    } else if (signerAddress == 0x23618e81E3f5cdF7f54C3d65f7FBc0aBf5B21E8f) {\n      return 8;\n    } else if (signerAddress == 0xa0Ee7A142d267C1f36714E4a8F75612F20a79720) {\n      return 9;\n    } else if (signerAddress == 0xBcd4042DE499D14e55001CcbB24a551F3b954096) {\n      return 10;\n    } else if (signerAddress == 0x71bE63f3384f5fb98995898A86B02Fb2426c5788) {\n      return 11;\n    } else if (signerAddress == 0xFABB0ac9d68B0B445fB7357272Ff202C5651694a) {\n      return 12;\n    } else if (signerAddress == 0x1CBd3b2770909D4e10f157cABC84C7264073C9Ec) {\n      return 13;\n    } else if (signerAddress == 0xdF3e18d64BC6A983f673Ab319CCaE4f1a57C7097) {\n      return 14;\n    } else if (signerAddress == 0xcd3B766CCDd6AE721141F452C550Ca635964ce71) {\n      return 15;\n    } else if (signerAddress == 0x2546BcD3c84621e976D8185a91A922aE77ECEc30) {\n      return 16;\n    } else if (signerAddress == 0xbDA5747bFD65F08deb54cb465eB87D40e51B197E) {\n      return 17;\n    } else if (signerAddress == 0xdD2FD4581271e230360230F9337D5c0430Bf44C0) {\n      return 18;\n    } else if (signerAddress == 0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199) {\n      return 19;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "@uniswap/lib/contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n\npragma solidity >=0.6.0;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeApprove: approve failed'\n        );\n    }\n\n    function safeTransfer(\n        address token,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::safeTransfer: transfer failed'\n        );\n    }\n\n    function safeTransferFrom(\n        address token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            'TransferHelper::transferFrom: transferFrom failed'\n        );\n    }\n\n    function safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'TransferHelper::safeTransferETH: ETH transfer failed');\n    }\n}\n"
    },
    "@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol": {
      "content": "pragma solidity >=0.5.0;\n\ninterface IUniswapV2Factory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n    function feeTo() external view returns (address);\n    function feeToSetter() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n    function allPairs(uint) external view returns (address pair);\n    function allPairsLength() external view returns (uint);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n    function setFeeToSetter(address) external;\n}\n"
    },
    "@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol": {
      "content": "pragma solidity >=0.6.2;\n\ninterface IUniswapV2Router01 {\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityETH(\n        address token,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETH(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityETHWithPermit(\n        address token,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountETHMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountETH);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "contracts/abstract/ECDSAVerify.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\nabstract contract ECDSAVerify {\n    using ECDSA for bytes32;\n\n    function verifyMessage(address signer, string memory message, bytes memory signature) public pure returns (bool) {\n        bytes32 messageHash = keccak256(bytes(message));\n        address signerAddress = messageHash.toEthSignedMessageHash().recover(signature);\n\n        return signerAddress == signer;\n    }\n}\n"
    },
    "contracts/abstract/NFTAccess.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nabstract contract NFTAccess is OwnableUpgradeable {\n    bytes32 internal constant ACCESS_NFT_SLOT = bytes32(uint256(keccak256('ACCESS_NFT_SLOT')) - 1);\n\n    function setAccessNFT(ERC721 nftAddress) external onlyOwner {\n        // Setting nftAddress to a address(0) removes the lock\n        if (address(nftAddress) != address(0)) {\n            require(AddressUpgradeable.isContract(address(nftAddress)), \"Cannot set nftAddress to a non-contract instance\");\n            (bool success, bytes memory result) = address(nftAddress).call(\n                abi.encodeWithSignature(\"balanceOf(address)\", msg.sender)\n            );\n            require(success && result.length > 0, \"Contract has to support the ERC721 balanceOf() interface\");\n        }\n\n        bytes32 slot = ACCESS_NFT_SLOT;\n        assembly {\n            sstore(slot, nftAddress)\n        }\n    }\n\n    function getAccessNFT() external view returns (ERC721 accessNFT) {\n        bytes32 slot = ACCESS_NFT_SLOT;\n        assembly {\n            accessNFT := sload(slot)\n        }\n    }\n\n    modifier hasAccessNFT {\n        bytes32 slot = ACCESS_NFT_SLOT;\n        ERC721 accessNFT;\n        assembly {\n            accessNFT := sload(slot)\n        }\n        if (address(accessNFT) != address(0)) {\n            require(accessNFT.balanceOf(msg.sender) > 0, \"Access NFT required\");\n        }\n        _;\n    }\n}\n"
    },
    "contracts/abstract/PendingOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../interfaces/IPendingOwnableUpgradeable.sol\";\n\nabstract contract PendingOwnableUpgradeable is OwnableUpgradeable, IPendingOwnableUpgradeable {\n    // keccak256(\"pending.owner.slot\") = 0x63a0d9df49fae3f1b9d24f8dc819a568c429a1b11d0d8e9de63df53a0194acb2\n    bytes32 private constant _PENDING_OWNER_SLOT = 0x63a0d9df49fae3f1b9d24f8dc819a568c429a1b11d0d8e9de63df53a0194acb2;\n\n    event OwnershipTransferRequested(address indexed from, address indexed to);\n\n    function __PendingOwnable_init() internal onlyInitializing {\n        __Ownable_init();\n    }\n\n    function transferOwnership(address newOwner) public virtual override(OwnableUpgradeable, IPendingOwnableUpgradeable) onlyOwner {\n        require(newOwner != address(0), \"PendingOwnable: new owner is the zero address\");\n        _setPendingOwner(newOwner);\n        emit OwnershipTransferRequested(owner(), newOwner);\n    }\n\n    function acceptOwnership() public virtual override {\n        address pendingOwner = _getPendingOwner();\n        require(msg.sender == pendingOwner, \"PendingOwnable: caller is not the pending owner\");\n        _transferOwnership(pendingOwner);\n        _setPendingOwner(address(0));\n    }\n\n    function pendingOwner() public view virtual override returns (address) {\n        return _getPendingOwner();\n    }\n\n    function _getPendingOwner() internal view returns (address) {\n        address pendingOwner;\n        bytes32 slot = _PENDING_OWNER_SLOT;\n        assembly {\n            pendingOwner := sload(slot)\n        }\n        return pendingOwner;\n    }\n\n    function _setPendingOwner(address newOwner) private {\n        bytes32 slot = _PENDING_OWNER_SLOT;\n        assembly {\n            sstore(slot, newOwner)\n        }\n    }\n}"
    },
    "contracts/AddressProvider.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\n/// @title DeltaPrime Address Provider\ncontract AddressProvider is OwnableUpgradeable {\n    mapping(bytes32 => address) private addresses;\n\n    bytes32 public constant RECOVERY_CONTRACT = \"RECOVERY_CONTRACT\";\n\n    event RecoveryContractUpdated(address indexed rc);\n\n    function initialize() external initializer {\n        __Ownable_init();\n    }\n\n    /// @notice Set recovery contract address\n    /// @param rc New recovery contract address\n    function setRecoveryContract(address rc) external onlyOwner {\n        _setAddress(RECOVERY_CONTRACT, rc);\n\n        emit RecoveryContractUpdated(rc);\n    }\n\n    /// @notice Get recovery contract address\n    function getRecoveryContract() external view returns (address) {\n        return _getAddress(RECOVERY_CONTRACT);\n    }\n\n    /// @dev Set address\n    /// @param key Key used to store address\n    /// @param addr Address to set\n    function _setAddress(bytes32 key, address addr) internal {\n        addresses[key] = addr;\n    }\n\n    /// @dev Get address\n    /// @param key Key used to get address\n    function _getAddress(bytes32 key) internal view returns (address) {\n        return addresses[key];\n    }\n}\n"
    },
    "contracts/BtcEligibleUsersList.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract BtcEligibleUsersList is Ownable{\n    address[] public eligibleUsersList;\n\n    constructor(address[] memory _eligibleUsersList){\n        eligibleUsersList = _eligibleUsersList;\n        _transferOwnership(0xBd2413135f3aab57195945A046cCA4e4bacD5a5b);\n    }\n\n    // only owner function to add users to eligible list\n    function addEligibleUsers(address[] calldata _eligibleUsers) external onlyOwner {\n        for (uint256 i = 0; i < _eligibleUsers.length; i++) {\n            eligibleUsersList.push(_eligibleUsers[i]);\n        }\n    }\n\n    /// only owner function to remove users from eligible list\n    function removeEligibleUsers(address[] calldata _eligibleUsers) external onlyOwner {\n        for (uint256 i = 0; i < _eligibleUsers.length; i++) {\n            for (uint256 j = 0; j < eligibleUsersList.length; j++) {\n                if (eligibleUsersList[j] == _eligibleUsers[i]) {\n                    eligibleUsersList[j] = eligibleUsersList[eligibleUsersList.length - 1];\n                    eligibleUsersList.pop();\n                }\n            }\n        }\n    }\n\n    // only owner function for replacing eligible users list\n    function replaceEligibleUsersList(address[] calldata _eligibleUsersList) external onlyOwner {\n        eligibleUsersList = _eligibleUsersList;\n    }\n\n    // function for getting the number of eligible users\n    function getEligibleUsersCount() external view returns (uint256) {\n        return eligibleUsersList.length;\n    }\n\n    // function for getting range of eligible users\n    function getEligibleUsers(uint256 _start, uint256 _end) external view returns (address[] memory) {\n        require(_start < _end, \"Invalid range\");\n        require(_end <= eligibleUsersList.length, \"Invalid range\");\n        address[] memory users = new address[](_end - _start);\n        for (uint256 i = _start; i < _end; i++) {\n            users[i - _start] = eligibleUsersList[i];\n        }\n        return users;\n    }\n}"
    },
    "contracts/deployment/arbitrum/ArbBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract ArbBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/ArbDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract ArbDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/ArbPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 84497b01716b53fb360c04d763183339d5599174;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title `ArbPool`\n * @dev Contract allowing user to deposit to and borrow ARB from a dedicated user account\n */\ncontract ArbPool is Pool {\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeArbibtrum\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPARB\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/arbitrum/ArbPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"./ArbPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract ArbPoolFactory {\n    function deployPool() public {\n        ArbPool pool = new ArbPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/ArbVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"./WethVariableUtilisationRatesCalculator.sol\";\n/**\n * @title ArbVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract ArbVariableUtilisationRatesCalculator is WethVariableUtilisationRatesCalculator{\n}"
    },
    "contracts/deployment/arbitrum/BtcBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: de0a4e9ee653d2aade275c436805bb3217a8979d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract BtcBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/BtcDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: de0a4e9ee653d2aade275c436805bb3217a8979d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract BtcDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/BtcPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 84497b01716b53fb360c04d763183339d5599174;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title BtcPool\n * @dev Contract allowing user to deposit to and borrow BTC.b from a dedicated user account\n */\ncontract BtcPool is Pool {\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeBitcoin\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPWBTC\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 8;\n    }\n}"
    },
    "contracts/deployment/arbitrum/BtcPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: de0a4e9ee653d2aade275c436805bb3217a8979d;\npragma solidity 0.8.27;\n\nimport \"./BtcPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract BtcPoolFactory {\n    function deployPool() public {\n        BtcPool pool = new BtcPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/BtcVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: de0a4e9ee653d2aade275c436805bb3217a8979d;\npragma solidity 0.8.27;\n\nimport \"./WethVariableUtilisationRatesCalculator.sol\";\n/**\n * @title BtcVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract BtcVariableUtilisationRatesCalculator is WethVariableUtilisationRatesCalculator{\n}"
    },
    "contracts/deployment/arbitrum/DaiBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract DaiBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/DaiDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract DaiDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/DaiPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 84497b01716b53fb360c04d763183339d5599174;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title DaiPool\n * @dev Contract allowing user to deposit to and borrow DAI from a dedicated user account\n */\ncontract DaiPool is Pool {\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeDAIToken\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPDAI\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/arbitrum/DaiPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"./DaiPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract DaiPoolFactory {\n    function deployPool() public {\n        DaiPool pool = new DaiPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/DaiVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 6094467959b5f026a0b2395f84a97536afb77aab;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title DaiVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract DaiVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.167e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.25e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.05e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 1e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.65e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4 = 6.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 5.6e18;\n\n    uint256 public constant MAX_RATE = 0.9e18;\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/EthBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract EthBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/EthDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract EthDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/FraxBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract FraxBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/FraxDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract FraxDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/FraxPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title FraxPool\n * @dev Contract allowing user to deposit to and borrow FRAX from a dedicated user account\n */\ncontract FraxPool is Pool {\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeFraxToken\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPFRAX\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/arbitrum/FraxPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"./FraxPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract FraxPoolFactory {\n    function deployPool() public {\n        FraxPool pool = new FraxPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/FraxVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title FraxVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract FraxVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.05e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.2e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.09e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 0.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.33e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4 = 7.800e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 6.9e18;\n\n    uint256 public constant MAX_RATE = 0.9e18;\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/LinkBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 58c223f4c83794b2ac9477fb697e0632d59efff8;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract LinkBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/LinkDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 58c223f4c83794b2ac9477fb697e0632d59efff8;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract LinkDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/LinkPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title LinkPool\n * @dev Contract allowing user to deposit to and borrow LINK from a dedicated user account\n */\ncontract LinkPool is Pool {\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeChainlink\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPLINK\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/arbitrum/LinkPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"./LinkPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract LinkPoolFactory {\n    function deployPool() public {\n        LinkPool pool = new LinkPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/LinkVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 58c223f4c83794b2ac9477fb697e0632d59efff8;\npragma solidity 0.8.27;\n\nimport \"./WethVariableUtilisationRatesCalculator.sol\";\n/**\n * @title EthVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract LinkVariableUtilisationRatesCalculator is WethVariableUtilisationRatesCalculator {\n}"
    },
    "contracts/deployment/arbitrum/UniBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 58c223f4c83794b2ac9477fb697e0632d59efff8;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UniBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/UniDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 58c223f4c83794b2ac9477fb697e0632d59efff8;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UniDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/UniPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title EthPool\n * @dev Contract allowing user to deposit to and borrow WETH.e from a dedicated user account\n */\ncontract UniPool is Pool {\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeUniswap\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPUNI\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/arbitrum/UniPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"./UniPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract UniPoolFactory {\n    function deployPool() public {\n        UniPool pool = new UniPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/UniVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 58c223f4c83794b2ac9477fb697e0632d59efff8;\npragma solidity 0.8.27;\n\nimport \"./WethVariableUtilisationRatesCalculator.sol\";\n/**\n * @title EthVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract UniVariableUtilisationRatesCalculator is WethVariableUtilisationRatesCalculator {\n}"
    },
    "contracts/deployment/arbitrum/UsdcBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdcBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/UsdcDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdcDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/UsdcPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 84497b01716b53fb360c04d763183339d5599174;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title UsdcPool\n * @dev Contract allowing user to deposit to and borrow USDC from a dedicated user account\n */\ncontract UsdcPool is Pool {\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeUSDCoin\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPUSDC\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 6;\n    }\n}"
    },
    "contracts/deployment/arbitrum/UsdcPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./UsdcPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract UsdcPoolFactory {\n    function deployPool() public {\n        UsdcPool pool = new UsdcPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/UsdcVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 6dc3ab0c31ac66137f41175063423dd3c8e796f0;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title UsdcVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract UsdcVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.167e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.25e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.05e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 1e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.65e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4 = 6.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 5.6e18;\n\n    uint256 public constant MAX_RATE = 0.9e18;\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/UsdtBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdtBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/UsdtDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdtDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/UsdtPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title UsdtPool\n * @dev Contract allowing user to deposit to and borrow USDT from a dedicated user account\n */\ncontract UsdtPool is Pool {\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeTetherToken\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPUSDt\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 6;\n    }\n}"
    },
    "contracts/deployment/arbitrum/UsdtPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"./UsdtPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract UsdtPoolFactory {\n    function deployPool() public {\n        UsdtPool pool = new UsdtPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/UsdtVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title UsdtVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract UsdtVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.05e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.2e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.09e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 0.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.33e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4 = 7.800e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 6.9e18;\n\n    uint256 public constant MAX_RATE = 0.9e18;\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/WethBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract WethBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/WethDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract WethDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/arbitrum/WethPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 84497b01716b53fb360c04d763183339d5599174;\npragma solidity 0.8.27;\n\nimport \"../../WrappedNativeTokenPool.sol\";\n\n\n/**\n * @title WethPool\n * @dev Contract allowing user to deposit to and borrow WETH from a dedicated user account\n */\ncontract WethPool is WrappedNativeTokenPool {\n    // Returns max. acceptable pool utilisation after borrow action\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeWrappedETH\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPWETH\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/arbitrum/WethPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./WethPool.sol\";\n\n\n/**\n * @title WethPoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract WethPoolFactory {\n    function deployPool() public {\n        WethPool pool = new WethPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/arbitrum/WethVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title WethVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract WethVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.05e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.2e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.09e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 0.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.33e18;\n\n    // BREAKPOINT must be lower than 1e18\n\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4= 29.8e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 26.7e18;\n\n    uint256 public constant MAX_RATE = 3.1e18;\n\n\n\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/BtcBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract BtcBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/BtcDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract BtcDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/BtcPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c2bfee98a59745a565435d8d8abe7a9391c35493;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title BtcPool\n * @dev Contract allowing user to deposit to and borrow BTC.b from a dedicated user account\n */\ncontract BtcPool is Pool {\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeBitcoin\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPBTCb\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 8;\n    }\n}"
    },
    "contracts/deployment/avalanche/BtcPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"./BtcPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract BtcPoolFactory {\n    function deployPool() public {\n        BtcPool pool = new BtcPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/BtcVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 83717555c511b82ae0d517b5f6fd5e09b7728852;\npragma solidity 0.8.27;\n\nimport \"./WavaxVariableUtilisationRatesCalculator.sol\";\n/**\n * @title BtcVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract BtcVariableUtilisationRatesCalculator is WavaxVariableUtilisationRatesCalculator{\n}"
    },
    "contracts/deployment/avalanche/EthBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract EthBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/EthDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract EthDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/EthPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8899a0d66afa13f275f68569b55f278edb7abb65;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title EthPool\n * @dev Contract allowing user to deposit to and borrow WETH.e from a dedicated user account\n */\ncontract EthPool is Pool {\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeWrappedEther\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPWETHe\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/avalanche/EthPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"./EthPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract EthPoolFactory {\n    function deployPool() public {\n        EthPool pool = new EthPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/EthVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 83717555c511b82ae0d517b5f6fd5e09b7728852;\npragma solidity 0.8.27;\n\nimport \"./WavaxVariableUtilisationRatesCalculator.sol\";\n/**\n * @title EthVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract EthVariableUtilisationRatesCalculator is WavaxVariableUtilisationRatesCalculator {\n}"
    },
    "contracts/deployment/avalanche/UsdcBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdcBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/UsdcDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdcDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/UsdcPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c2bfee98a59745a565435d8d8abe7a9391c35493;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title UsdcPool\n * @dev Contract allowing user to deposit to and borrow USDC from a dedicated user account\n */\ncontract UsdcPool is Pool {\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeUSDCoin\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPUSDC\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 6;\n    }\n}"
    },
    "contracts/deployment/avalanche/UsdcPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"./UsdcPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract UsdcPoolFactory {\n    function deployPool() public {\n        UsdcPool pool = new UsdcPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/UsdcVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: f106f303852385ff33e1a83f9b0684556dd56134;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title UsdcVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract UsdcVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.167e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.25e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.05e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 1e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.65e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4 = 6.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 5.6e18;\n\n    uint256 public constant MAX_RATE = 0.9e18;\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/UsdtBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f1e1bba11316303810f35a4440e20bc5ad0ef86;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdtBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/UsdtDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f1e1bba11316303810f35a4440e20bc5ad0ef86;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract UsdtDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/UsdtPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c2bfee98a59745a565435d8d8abe7a9391c35493;\npragma solidity 0.8.27;\n\nimport \"../../Pool.sol\";\n\n\n/**\n * @title UsdtPool\n * @dev Contract allowing user to deposit to and borrow USDT from a dedicated user account\n */\ncontract UsdtPool is Pool {\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeTetherToken\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPUSDt\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 6;\n    }\n}"
    },
    "contracts/deployment/avalanche/UsdtPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f1e1bba11316303810f35a4440e20bc5ad0ef86;\npragma solidity 0.8.27;\n\nimport \"./UsdtPool.sol\";\n\n\n/**\n * @title PoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract UsdtPoolFactory {\n    function deployPool() public {\n        UsdtPool pool = new UsdtPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/UsdtVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: f106f303852385ff33e1a83f9b0684556dd56134;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title UsdtVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract UsdtVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.167e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.25e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.05e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 1e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.65e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4 = 6.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 5.6e18;\n\n    uint256 public constant MAX_RATE = 0.9e18;\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/WavaxBorrowIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract WavaxBorrowIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/WavaxDepositIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../../LinearIndex.sol\";\n\ncontract WavaxDepositIndex is LinearIndex {}"
    },
    "contracts/deployment/avalanche/WavaxPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c2bfee98a59745a565435d8d8abe7a9391c35493;\npragma solidity 0.8.27;\n\nimport \"../../WrappedNativeTokenPool.sol\";\n\n\n/**\n * @title WavaxPool\n * @dev Contract allowing user to deposit to and borrow WAVAX from a dedicated user account\n */\ncontract WavaxPool is WrappedNativeTokenPool {\n    // Returns max. acceptable pool utilisation after borrow action\n    function getMaxPoolUtilisationForBorrowing() override public view returns (uint256) {\n        return 0.925e18;\n    }\n\n    function name() public virtual override pure returns(string memory _name){\n        _name = \"DeltaPrimeWrappedAVAX\";\n    }\n\n    function symbol() public virtual override pure returns(string memory _symbol){\n        _symbol = \"DPWAVAX\";\n    }\n\n    function decimals() public virtual override pure returns(uint8 decimals){\n        decimals = 18;\n    }\n}"
    },
    "contracts/deployment/avalanche/WavaxPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 5bae95ca244e96444fe80078195944f6637e72d8;\npragma solidity 0.8.27;\n\nimport \"./WavaxPool.sol\";\n\n\n/**\n * @title WavaxPoolFactory\n * @dev Contract factory allowing anyone to deploy a pool contract\n */\ncontract WavaxPoolFactory {\n    function deployPool() public {\n        WavaxPool pool = new WavaxPool();\n        emit PoolDeployed(msg.sender, address(pool), block.timestamp);\n    }\n\n    /**\n     * @dev emitted after pool is deployed by any user\n     * @param user the address initiating the deployment\n     * @param poolAddress of deployed pool\n     * @param timestamp of the deployment\n     **/\n    event PoolDeployed(address user, address poolAddress, uint256 timestamp);\n}"
    },
    "contracts/deployment/avalanche/WavaxVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 83717555c511b82ae0d517b5f6fd5e09b7728852;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title WavaxVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract WavaxVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0.05e18;\n    uint256 public constant OFFSET_1 = 0;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.2e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.09e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 0.5e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 0.33e18;\n\n    // BREAKPOINT must be lower than 1e18\n\n    uint256 public constant BREAKPOINT_3 = 0.9e18;\n\n    uint256 public constant SLOPE_4= 29.8e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_4 = 26.7e18;\n\n    uint256 public constant MAX_RATE = 3.1e18;\n\n\n\n\n    //residual spread to account for arithmetic inaccuracies in calculation of deposit rate. Does not result in any meaningful\n    //profit generation\n    uint256 public spread = 1e12;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else if (poolUtilisation <= BREAKPOINT_3) {\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2/3/4 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_4) / 1e18 - OFFSET_4;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/DepositRewarderAbstract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IDepositRewarder.sol\";\n\nabstract contract DepositRewarderAbstract is\n    IDepositRewarder,\n    Ownable,\n    ReentrancyGuard\n{\n    using SafeERC20 for IERC20;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                        STORAGE                                            //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Pool address\n    address public immutable pool;\n\n    /// @notice Duration of rewards to be paid out (in seconds)\n    uint256 public duration;\n\n    /// @notice Timestamp of when the rewards finish\n    uint256 public finishAt;\n\n    /// @notice Minimum of last updated time and reward finish time\n    uint256 public updatedAt;\n\n    /// @notice Reward to be paid out per second\n    uint256 public rewardRate;\n\n    /// @notice Sum of (reward rate * dt * 1e18 / total supply)\n    uint256 public rewardPerTokenStored;\n\n    /// @notice User address => rewardPerTokenStored\n    mapping(address => uint256) public userRewardPerTokenPaid;\n\n    /// @notice User address => rewards to be claimed\n    mapping(address => uint256) public rewards;\n\n    /// @notice Total deposited\n    uint256 public totalSupply;\n\n    /// @notice User address => deposited amount\n    mapping(address => uint256) public balanceOf;\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                        ERRORS                                             //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    /// @notice Error for when an address parameter passed is invalid\n    error InvalidAddress();\n\n    /// @notice Error for when msg.sender is unauthorized\n    error Unauthorized();\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                        EVENTS                                             //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    event Deposited(\n        address indexed account,\n        uint256 indexed amount,\n        uint256 timestamp\n    );\n\n    event Withdrawn(\n        address indexed account,\n        uint256 indexed amount,\n        uint256 timestamp\n    );\n\n    event BatchDeposited(address[] accounts, uint256 timestamp);\n\n    event RewardsDurationUpdated(uint256 duration);\n\n    event RewardAdded(uint256 reward);\n\n    event RewardPaid(address indexed account, uint256 reward);\n\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n    //                                       MODIFIERS                                           //\n    ///////////////////////////////////////////////////////////////////////////////////////////////\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        }\n\n        _;\n    }\n\n    modifier onlyPool() {\n        if (msg.sender != pool) {\n            revert Unauthorized();\n        }\n\n        _;\n    }\n\n    constructor(address pool_) {\n        if (pool_ == address(0)) {\n            revert InvalidAddress();\n        }\n\n        pool = pool_;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return\n            rewardPerTokenStored +\n            (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\n            totalSupply;\n    }\n\n    function addDeposits(address[] memory accounts) external onlyOwner {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        uint256 length = accounts.length;\n        for (uint256 i; i != length; ++i) {\n            address account = accounts[i];\n            rewards[account] = earned(account);\n            uint256 balance = IERC20(pool).balanceOf(account);\n            uint256 oldBalance = balanceOf[account];\n            balanceOf[account] = balance;\n            totalSupply = totalSupply + balance - oldBalance;\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n\n        emit BatchDeposited(accounts, block.timestamp);\n    }\n\n    function stakeFor(\n        uint256 amount,\n        address account\n    ) external nonReentrant onlyPool updateReward(account) {\n        balanceOf[account] += amount;\n        totalSupply += amount;\n\n        emit Deposited(account, amount, block.timestamp);\n    }\n\n    function withdrawFor(\n        uint256 amount,\n        address account\n    ) external nonReentrant onlyPool updateReward(account) returns (uint256) {\n        amount = _min(balanceOf[account], amount);\n\n        balanceOf[account] -= amount;\n        totalSupply -= amount;\n\n        emit Withdrawn(account, amount, block.timestamp);\n\n        return amount;\n    }\n\n    function earned(address _account) public view returns (uint256) {\n        return\n            ((balanceOf[_account] *\n                (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18) +\n            rewards[_account];\n    }\n\n    function getRewardsFor(address payable _user) external virtual;\n\n    function setRewardsDuration(uint256 _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n\n        emit RewardsDurationUpdated(_duration);\n    }\n\n    function _min(uint256 x, uint256 y) private pure returns (uint256) {\n        return x <= y ? x : y;\n    }\n}\n"
    },
    "contracts/DepositRewarderERC20.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2ede0bbde1c468465ae647d5f989635d6090bcba;\npragma solidity ^0.8.27;\n\nimport \"./DepositRewarderAbstract.sol\";\n\ncontract DepositRewarderERC20 is DepositRewarderAbstract {\n    using SafeERC20 for IERC20;\n\n    /// @notice Reward token\n    IERC20 public immutable rewardToken;\n\n    constructor(\n        IERC20 rewardToken_,\n        address pool_\n    ) DepositRewarderAbstract(pool_) {\n        if (address(rewardToken_) == address(0)) {\n            revert InvalidAddress();\n        }\n\n        rewardToken = rewardToken_;\n    }\n\n    function getRewardsFor(\n        address payable _user\n    ) external override nonReentrant updateReward(_user) {\n        uint256 reward = rewards[_user];\n        if (reward > 0) {\n            rewards[_user] = 0;\n            rewardToken.safeTransfer(_user, reward);\n            emit RewardPaid(_user, reward);\n        }\n    }\n\n    function notifyRewardAmount(\n        uint256 reward\n    ) external onlyOwner updateReward(address(0)) {\n        if (block.timestamp >= finishAt) {\n            rewardRate = reward / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRate;\n            rewardRate = (reward + remainingRewards) / duration;\n        }\n\n        require(rewardRate > 0, \"reward rate = 0\");\n        require(\n            rewardRate * duration <= rewardToken.balanceOf(address(this)),\n            \"reward amount > balance\"\n        );\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n\n        emit RewardAdded(reward);\n    }\n}\n"
    },
    "contracts/DepositRewarderNative.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\nimport \"./DepositRewarderAbstract.sol\";\n\ncontract DepositRewarderNative is DepositRewarderAbstract {\n    constructor(address pool_) DepositRewarderAbstract(pool_) {}\n\n    function getRewardsFor(\n        address payable _user\n    ) external override nonReentrant updateReward(_user) {\n        uint256 reward = rewards[_user];\n        if (reward > 0) {\n            rewards[_user] = 0;\n            (bool success, bytes memory result) = _user.call{value: reward, gas: 5000}(\"\");\n            require(success, \"Failed to send native token\");\n        }\n    }\n\n    function notifyRewardAmount()\n        external\n        payable\n        onlyOwner\n        updateReward(address(0))\n    {\n        if (block.timestamp >= finishAt) {\n            rewardRate = msg.value / duration;\n        } else {\n            uint256 remainingRewards = (finishAt - block.timestamp) * rewardRate;\n            rewardRate = (msg.value + remainingRewards) / duration;\n        }\n\n        require(rewardRate > 0, \"reward rate = 0\");\n        require(\n            rewardRate * duration <= address(this).balance,\n            \"reward amount > balance\"\n        );\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n\n        emit RewardAdded(msg.value);\n    }\n}\n"
    },
    "contracts/DepositSwap.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: e458289996cc5bb1378ce9654eedc316f5beefdf;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./interfaces/facets/IYieldYakRouter.sol\";\nimport \"./Pool.sol\";\n\nabstract contract DepositSwap {\n    using SafeERC20 for IERC20;\n\n    address private constant PARA_TRANSFER_PROXY =\n        0x216B4B4Ba9F3e719726886d34a177484278Bfcae;\n    address private constant PARA_ROUTER =\n        0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57;\n\n    function _isTokenSupported(address token) internal virtual pure returns (bool);\n\n    function _tokenToPoolTUPMapping(address token) internal virtual pure returns (Pool);\n\n    function _withdrawFromPool(Pool pool, IERC20 token, uint256 amount, address user) internal {\n        uint256 userInitialFromTokenDepositBalance = pool.balanceOf(user);\n        uint256 poolInitialBalance = pool.balanceOf(address(this));\n\n        require(userInitialFromTokenDepositBalance >= amount, \"Insufficient fromToken deposit balance\");\n\n        pool.transferFrom(user, address(this), amount);\n        require(pool.balanceOf(address(this)) - poolInitialBalance == amount, \"amountFromToken and post-transfer contract balance mismatch\");\n        require(pool.balanceOf(user) == userInitialFromTokenDepositBalance - amount, \"user post-transfer balance is incorrect\");\n\n        uint256 poolInitialTokenBalance = token.balanceOf(address(this));\n\n        pool.withdraw(amount);\n\n        require(pool.balanceOf(address(this)) == poolInitialBalance, \"Post-withdrawal contract deposit balance must be 0\");\n        require(token.balanceOf(address(this)) == poolInitialTokenBalance + amount, \"Post-withdrawal contract fromToken balance is incorrect\");\n    }\n\n    function _depositToPool(Pool pool, IERC20 token, uint256 amount, address user) internal {\n        uint256 contractInitialToTokenBalance = token.balanceOf(address(this));\n        uint256 userInitialToTokenDepositBalance = pool.balanceOf(user);\n        uint256 poolInitialBalance = pool.balanceOf(address(this));\n\n        require(contractInitialToTokenBalance >= amount, \"Insufficient contract toToken balance\");\n\n        token.safeApprove(address(pool), 0);\n        token.safeApprove(address(pool), amount);\n        pool.deposit(amount);\n\n        require(token.balanceOf(address(this)) == contractInitialToTokenBalance - amount, \"Post-deposit contract toToken balance must be 0\");\n        require(pool.balanceOf(address(this)) == poolInitialBalance + amount, \"Post-deposit contract deposit balance is incorrect\");\n\n        pool.transfer(user, amount);\n\n        require(token.balanceOf(address(this)) == contractInitialToTokenBalance - amount, \"Post-transfer contract deposit balance must be 0\");\n        require(pool.balanceOf(user) == userInitialToTokenDepositBalance + amount, \"Post-transfer user deposit balance is incorrect\");\n    }\n\n    function _yakSwap(address[] calldata path, address[] calldata adapters, uint256 amountIn, uint256 amountOut) internal {\n        IERC20(path[0]).safeApprove(YY_ROUTER(), 0);\n        IERC20(path[0]).safeApprove(YY_ROUTER(), amountIn);\n\n        IYieldYakRouter router = IYieldYakRouter(YY_ROUTER());\n\n\n        IYieldYakRouter.Trade memory trade = IYieldYakRouter.Trade({\n            amountIn: amountIn,\n            amountOut: amountOut,\n            path: path,\n            adapters: adapters\n        });\n\n        router.swapNoSplit(trade, address(this), 0);\n    }\n\n\n    // Needs approval on the fromToken Pool\n    function depositSwap(uint256 amountFromToken, uint256 minAmountToToken, address[] calldata path, address[] calldata adapters) public {\n        address fromToken = path[0];\n        address toToken = path[path.length - 1];\n\n        require(_isTokenSupported(fromToken), \"fromToken not supported\");\n        require(_isTokenSupported(toToken), \"toToken not supported\");\n\n        Pool fromPool = _tokenToPoolTUPMapping(fromToken);\n        Pool toPool = _tokenToPoolTUPMapping(toToken);\n\n        address user = msg.sender;\n        amountFromToken = Math.min(fromPool.balanceOf(user), amountFromToken);\n\n        _withdrawFromPool(fromPool, IERC20(fromToken), amountFromToken, user);\n\n        _yakSwap(path, adapters, amountFromToken, minAmountToToken);\n\n        _depositToPool(toPool, IERC20(toToken), IERC20(toToken).balanceOf(address(this)), user);\n    }\n\n    // Needs approval on the fromToken Pool\n    function depositSwapParaSwap(\n        bytes4 selector,\n        bytes memory data,\n        address fromToken,\n        uint256 fromAmount,\n        address toToken,\n        uint256 minOut\n    ) public {\n        require(_isTokenSupported(fromToken), \"fromToken not supported\");\n        require(_isTokenSupported(toToken), \"toToken not supported\");\n\n        require(minOut > 0, \"minOut needs to be > 0\");\n        require(fromAmount > 0, \"Amount of tokens to sell needs to be > 0\");\n\n        Pool fromPool = _tokenToPoolTUPMapping(fromToken);\n        Pool toPool = _tokenToPoolTUPMapping(toToken);\n\n        address user = msg.sender;\n        fromAmount = Math.min(fromPool.balanceOf(user), fromAmount);\n\n        _withdrawFromPool(fromPool, IERC20(fromToken), fromAmount, user);\n\n        IERC20(fromToken).safeApprove(PARA_TRANSFER_PROXY, 0);\n        IERC20(fromToken).safeApprove(\n            PARA_TRANSFER_PROXY,\n            fromAmount\n        );\n\n        (bool success, ) = PARA_ROUTER.call((abi.encodePacked(selector, data)));\n        require(success, \"Swap failed\");\n\n        uint256 amountOut = IERC20(toToken).balanceOf(address(this));\n        require(amountOut >= minOut, \"Too little received\");\n\n        _depositToPool(toPool, IERC20(toToken), amountOut, user);\n    }\n\n    function YY_ROUTER() internal virtual pure returns (address);\n}\n"
    },
    "contracts/DepositSwapArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 3742ed131202971f0b79e04769200986a3c7f8d0;\npragma solidity 0.8.27;\n\nimport \"./DepositSwap.sol\";\n\ncontract DepositSwapArbitrum is DepositSwap {\n    using SafeERC20 for IERC20;\n\n    address private constant PARA_TRANSFER_PROXY =\n    0x216B4B4Ba9F3e719726886d34a177484278Bfcae;\n    address private constant PARA_ROUTER =\n    0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57;\n\n    address public constant WETH_POOL_TUP = 0x0BeBEB5679115f143772CfD97359BBcc393d46b3;\n    address public constant USDC_POOL_TUP = 0x8FE3842e0B7472a57f2A2D56cF6bCe08517A1De0;\n    address public constant ARB_POOL_TUP = 0x2B8C610F3fC6F883817637d15514293565C3d08A;\n    address public constant BTC_POOL_TUP = 0x5CdE36c23f0909960BA4D6E8713257C6191f8C35;\n    address public constant DAI_POOL_TUP = 0xd5E8f691756c3d7b86FD8A89A06497D38D362540;\n\n    address public constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n    address public constant USDC = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831;\n    address public constant ARB = 0x912CE59144191C1204E64559FE8253a0e49E6548;\n    address public constant BTC = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f;\n    address public constant DAI = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n\n    function _isTokenSupported(address token) internal override pure returns (bool) {\n        if(\n            token == WETH ||\n            token == USDC ||\n            token == BTC ||\n            token == DAI ||\n            token == ARB\n        ){\n            return true;\n        }\n        return false;\n    }\n\n    function _tokenToPoolTUPMapping(address token) internal override pure returns (Pool) {\n        if(token == WETH){\n            return Pool(WETH_POOL_TUP);\n        } else if (token == USDC){\n            return Pool(USDC_POOL_TUP);\n        } else if (token == ARB){\n            return Pool(ARB_POOL_TUP);\n        } else if (token == BTC){\n            return Pool(BTC_POOL_TUP);\n        } else if (token == DAI){\n            return Pool(DAI_POOL_TUP);\n        }\n        revert(\"Pool not supported\");\n    }\n\n    function YY_ROUTER() internal override pure returns (address) {\n        return 0xb32C79a25291265eF240Eb32E9faBbc6DcEE3cE3;\n    }\n}\n"
    },
    "contracts/DepositSwapAvalanche.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./DepositSwap.sol\";\n\ncontract DepositSwapAvalanche is DepositSwap {\n    using SafeERC20 for IERC20;\n\n    address private constant PARA_TRANSFER_PROXY =\n        0x216B4B4Ba9F3e719726886d34a177484278Bfcae;\n    address private constant PARA_ROUTER =\n        0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57;\n\n    address public constant WAVAX_POOL_TUP = 0xD26E504fc642B96751fD55D3E68AF295806542f5;\n    address public constant USDC_POOL_TUP = 0x2323dAC85C6Ab9bd6a8B5Fb75B0581E31232d12b;\n    address public constant USDT_POOL_TUP = 0xd222e10D7Fe6B7f9608F14A8B5Cf703c74eFBcA1;\n    address public constant ETH_POOL_TUP = 0xD7fEB276ba254cD9b34804A986CE9a8C3E359148;\n    address public constant BTC_POOL_TUP = 0x475589b0Ed87591A893Df42EC6076d2499bB63d0;\n\n    address public constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    address public constant WETH = 0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB;\n    address public constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n    address public constant USDT = 0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7;\n    address public constant BTC = 0x152b9d0FdC40C096757F570A51E494bd4b943E50;\n\n    function _isTokenSupported(address token) internal override pure returns (bool) {\n        if(\n            token == WAVAX ||\n            token == WETH ||\n            token == USDC ||\n            token == USDT ||\n            token == BTC\n        ){\n            return true;\n        }\n        return false;\n    }\n\n    function _tokenToPoolTUPMapping(address token) internal override pure returns (Pool) {\n        if(token == WAVAX){\n            return Pool(WAVAX_POOL_TUP);\n        } else if (token == WETH){\n            return Pool(ETH_POOL_TUP);\n        } else if (token == USDC){\n            return Pool(USDC_POOL_TUP);\n        } else if (token == USDT){\n            return Pool(USDT_POOL_TUP);\n        } else if (token == BTC){\n            return Pool(BTC_POOL_TUP);\n        }\n        revert(\"Pool not supported\");\n    }\n\n    function YY_ROUTER() internal override pure returns (address) {\n        return 0xC4729E56b831d74bBc18797e0e17A295fA77488c;\n    }\n}\n"
    },
    "contracts/DiamondHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 97d6cc3cb60bfd6feda4ea784b13bf0e7daac710;\npragma solidity 0.8.27;\n\nimport \"./interfaces/IDiamondBeacon.sol\";\n\n//This path is updated during deployment\nimport \"./lib/arbitrum/DeploymentConstants.sol\";\n\n/**\n * DiamondHelper\n * Helper methods\n **/\ncontract DiamondHelper {\n    function _getFacetAddress(bytes4 methodSelector) internal view returns (address solvencyFacetAddress) {\n        solvencyFacetAddress = IDiamondBeacon(payable(DeploymentConstants.getDiamondAddress())).implementation(methodSelector);\n    }\n}"
    },
    "contracts/facets/arbitrum/AssetsOperationsArbitrumFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 824dcb816242972f9370e35039cf65c6d12cd6f0;\npragma solidity 0.8.27;\n\nimport \"../AssetsOperationsFacet.sol\";\n\ncontract AssetsOperationsArbitrumFacet is AssetsOperationsFacet {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    function YY_ROUTER() internal override pure returns (address) {\n        return 0xb32C79a25291265eF240Eb32E9faBbc6DcEE3cE3;\n    }\n\n    /**\n    * Funds the loan with a specified amount of a GLP\n    * @dev Requires approval for stakedGLP token on frontend side\n    * @param _amount to be funded\n    **/\n    function fundGLP(uint256 _amount) public override nonReentrant{\n        IERC20Metadata stakedGlpToken = IERC20Metadata(0x5402B5F40310bDED796c7D0F3FF6683f5C0cFfdf);\n        _amount = Math.min(_amount, stakedGlpToken.balanceOf(msg.sender));\n        address(stakedGlpToken).safeTransferFrom(msg.sender, address(this), _amount);\n        if (stakedGlpToken.balanceOf(address(this)) > 0) {\n            DiamondStorageLib.addOwnedAsset(\"GLP\", address(stakedGlpToken));\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        tokenManager.increaseProtocolExposure(\"GLP\", _amount);\n\n        emit Funded(msg.sender, \"GLP\", _amount, block.timestamp);\n    }\n\n    /**\n        * Withdraws specified amount of a GLP\n        * @param _amount to be withdrawn\n    **/\n    function withdrawGLP(uint256 _amount) public override onlyOwner nonReentrant canRepayDebtFully remainsSolvent{\n        IERC20Metadata token = getERC20TokenInstance(\"GLP\", true);\n        IERC20Metadata stakedGlpToken = IERC20Metadata(0x5402B5F40310bDED796c7D0F3FF6683f5C0cFfdf);\n        _amount = Math.min(token.balanceOf(address(this)), _amount);\n\n        address(stakedGlpToken).safeTransfer(msg.sender, _amount);\n        if (token.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(\"GLP\");\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        tokenManager.decreaseProtocolExposure(\"GLP\", _amount);\n\n        emit Withdrawn(msg.sender, \"GLP\", _amount, block.timestamp);\n    }\n}\n"
    },
    "contracts/facets/arbitrum/BeefyFinanceArbitrumFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 19d9982858f4feeff1ca98cbf31b07304a79ac7f;\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/facets/IBeefyFinance.sol\";\n\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract BeefyFinanceArbitrumFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    // Vaults\n    address private constant MOO_SUSHI_DPX_ETH_LP = 0x4D323f77c32EDdC62BF8eAbA11E5C573FD0a2ccd;\n    address private constant MOO_GMX = 0x5B904f19fb9ccf493b623e5c8cE91603665788b0;\n\n    // LPs\n    address private constant SUSHI_DPX_ETH_LP = 0x0C1Cf6883efA1B496B01f654E247B9b419873054;\n    address private constant GMX = 0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a;\n\n    // ----- STAKE -----\n\n    /**\n      * Stakes SUSHI_DPX_ETH_LP in the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of SUSHI_DPX_ETH_LP to be staked\n    **/\n    function stakeSushiDpxEthLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant remainsSolvent {\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n            lpTokenAddress: SUSHI_DPX_ETH_LP,\n            vaultAddress: MOO_SUSHI_DPX_ETH_LP,\n            lpTokenSymbol: \"SUSHI_DPX_ETH_LP\",\n            vaultTokenSymbol: \"MOO_SUSHI_DPX_ETH_LP\",\n            amount: amount\n        }));\n    }\n\n    /**\n      * Stakes GMX in the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of GMX to be staked\n    **/\n    function stakeGmxBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant remainsSolvent {\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n            lpTokenAddress: GMX,\n            vaultAddress: MOO_GMX,\n            lpTokenSymbol: \"GMX\",\n            vaultTokenSymbol: \"MOO_GMX\",\n            amount: amount\n        }));\n    }\n\n    // ----- UNSTAKE -----\n\n    /**\n      * Unstakes SUSHI_DPX_ETH_LP from the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of SUSHI_DPX_ETH_LP to be unstaked\n    **/\n    function unstakeSushiDpxEthLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n            _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n            lpTokenAddress: SUSHI_DPX_ETH_LP,\n            vaultAddress: MOO_SUSHI_DPX_ETH_LP,\n            lpTokenSymbol: \"SUSHI_DPX_ETH_LP\",\n            vaultTokenSymbol: \"MOO_SUSHI_DPX_ETH_LP\",\n            amount: amount\n        }));\n    }\n\n    /**\n      * Untakes GMX from the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of GMX to be unstaked\n    **/\n    function unstakeGmxBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n            lpTokenAddress: GMX,\n            vaultAddress: MOO_GMX,\n            lpTokenSymbol: \"GMX\",\n            vaultTokenSymbol: \"MOO_GMX\",\n            amount: amount\n        }));\n    }\n\n    // ----- PRIVATE METHODS -----\n\n    /**\n      * Stakes {stakingDetails.lpTokenAddress} LP token in the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param stakingDetails IBeefyFinance.BeefyStakingDetails staking details\n    **/\n    function _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails memory stakingDetails) private {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(stakingDetails.amount > 0, \"Cannot stake 0 tokens\");\n        // _ACTIVE = 2\n        require(tokenManager.tokenToStatus(stakingDetails.lpTokenAddress) == 2, \"LP token not supported\");\n        require(tokenManager.tokenToStatus(stakingDetails.vaultAddress) == 2, \"Vault token not supported\");\n        require(IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this)) >= stakingDetails.amount, \"Not enough LP token available\");\n\n        stakingDetails.lpTokenAddress.safeApprove(stakingDetails.vaultAddress, 0);\n        stakingDetails.lpTokenAddress.safeApprove(stakingDetails.vaultAddress, stakingDetails.amount);\n        \n        IBeefyFinance vaultContract = IBeefyFinance(stakingDetails.vaultAddress);\n        uint256 initialVaultToken = vaultContract.balanceOf(address(this));\n\n        vaultContract.deposit(stakingDetails.amount);\n\n        _increaseExposure(tokenManager, stakingDetails.vaultAddress, vaultContract.balanceOf(address(this)) - initialVaultToken);\n        _decreaseExposure(tokenManager, stakingDetails.lpTokenAddress, stakingDetails.amount);\n\n        emit Staked(msg.sender, stakingDetails.lpTokenSymbol, stakingDetails.vaultAddress, stakingDetails.amount, block.timestamp);\n    }\n\n    /**\n     * Unstakes {stakingDetails.lpTokenAddress} LP token in the Beefy protocol\n     * @dev This function uses the redstone-evm-connector\n     * @param stakingDetails IBeefyFinance.BeefyStakingDetails staking details\n    **/\n    function _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails memory stakingDetails) private {\n        IBeefyFinance vaultContract = IBeefyFinance(stakingDetails.vaultAddress);\n        uint256 initialStakedBalance = vaultContract.balanceOf(address(this));\n        uint256 initialLpBalance = IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this));\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(initialStakedBalance >= stakingDetails.amount, \"Cannot unstake more than was initially staked\");\n\n        vaultContract.withdraw(stakingDetails.amount);\n\n        _decreaseExposure(tokenManager, stakingDetails.vaultAddress, stakingDetails.amount);\n        _increaseExposure(tokenManager, stakingDetails.lpTokenAddress, IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this)) - initialLpBalance);\n\n        emit Unstaked(msg.sender, stakingDetails.lpTokenSymbol, stakingDetails.vaultAddress, stakingDetails.amount, block.timestamp);\n    }\n\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of the vault token\n        * @param amount of the asset that was staked\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param asset the asset that was unstaked\n        * @param vault address of the vault token\n        * @param amount of the asset that was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\n}"
    },
    "contracts/facets/arbitrum/ConvexFacetArbi.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../lib/SolvencyMethods.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../../interfaces/arbitrum/IConvexPool.sol\";\nimport \"../../interfaces/arbitrum/IConvexRewarder.sol\";\n\ncontract ConvexFacetArbi is ReentrancyGuardKeccak, SolvencyMethods {\n    using TransferHelper for address;\n\n    // Curve\n    // TODO: Add to TokenManager\n    address public constant CRV_USD_BTC_ETH_LP_TOKEN_ADDRESS = 0x8e0B8c8BB9db49a46697F3a5Bb8A308e744821D2;\n    // TODO: Add to TokenManager\n    address public constant CRV_TOKEN_ADDRESS = 0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978;\n\n    // Convex\n    // TODO: Add to TokenManager\n    address public constant CVX_TOKEN_ADDRESS = 0xb952A807345991BD529FDded05009F5e80Fe8F45;\n    // TODO: Add to TokenManager\n    address public constant CVX_USD_BTC_ETH_LP_TOKEN_ADDRESS = 0xA9249f8667cb120F065D9dA1dCb37AD28E1E8FF0;\n\n    address public constant DEPOSIT_CONTRACT_USD_BTC_ETH_ADDRESS = 0xF403C135812408BFbE8713b5A23a04b3D48AAE31;\n    uint256 public constant USD_BTC_ETH_POOL_ID = 8;\n\n    function depositAndStakeUsdBtcEth(uint256 lpTokensAmount) external returns (uint256){\n        return _depositAndStake(IConvexPool.DepositDetails({\n            crvLpTokenAmount: lpTokensAmount,\n            depositPoolId: USD_BTC_ETH_POOL_ID,\n            depositPoolAddress: DEPOSIT_CONTRACT_USD_BTC_ETH_ADDRESS,\n            crvLpTokenAddress: CRV_USD_BTC_ETH_LP_TOKEN_ADDRESS,\n            crvLpTokenIdentifier: \"CRV_USD_BTC_ETH\",\n            cvxPoolLPTokenAddress: CVX_USD_BTC_ETH_LP_TOKEN_ADDRESS,\n            cvxPoolIdentifier: \"CVX_USD_BTC_ETH\"\n        }));\n\n    }\n\n    function withdrawAndClaimUsdBtcEth(uint256 receiptTokenAmount) external returns(uint256){\n        return _withdrawAndClaim(IConvexPool.WithdrawalDetails({\n            receiptTokenAmount: receiptTokenAmount,\n            crvLpTokenAddress: CRV_USD_BTC_ETH_LP_TOKEN_ADDRESS,\n            crvLpTokenIdentifier: \"CRV_USD_BTC_ETH\",\n            cvxPoolLPTokenAddress: CVX_USD_BTC_ETH_LP_TOKEN_ADDRESS,\n            cvxPoolIdentifier: \"CVX_USD_BTC_ETH\"\n        }));\n    }\n\n    function _depositAndStake(IConvexPool.DepositDetails memory depositDetails) internal onlyOwner nonReentrant recalculateAssetsExposure remainsSolvent returns (uint256){\n        IERC20Metadata crvLpToken = IERC20Metadata(depositDetails.crvLpTokenAddress);\n        IERC20Metadata cvxLpToken = IERC20Metadata(depositDetails.cvxPoolLPTokenAddress);\n        IConvexPool cvxPool = IConvexPool(depositDetails.depositPoolAddress);\n\n        uint256 initialReceiptTokenBalance = cvxLpToken.balanceOf(address(this));\n\n        depositDetails.crvLpTokenAmount = Math.min(crvLpToken.balanceOf(address(this)), depositDetails.crvLpTokenAmount);\n        require(depositDetails.crvLpTokenAmount > 0, \"Cannot stake 0 tokens\");\n\n        address(crvLpToken).safeApprove(address(cvxPool), 0);\n        address(crvLpToken).safeApprove(address(cvxPool), depositDetails.crvLpTokenAmount);\n\n        cvxPool.deposit(depositDetails.depositPoolId, depositDetails.crvLpTokenAmount);\n\n        // Add/remove owned tokens\n        DiamondStorageLib.addOwnedAsset(depositDetails.cvxPoolIdentifier, depositDetails.cvxPoolLPTokenAddress);\n        if(crvLpToken.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(depositDetails.crvLpTokenIdentifier);\n        }\n\n        uint256 receiptTokenReceivedAmount = cvxLpToken.balanceOf(address(this)) - initialReceiptTokenBalance;\n        emit Staked(\n            msg.sender,\n            depositDetails.crvLpTokenIdentifier,\n            depositDetails.depositPoolAddress,\n            depositDetails.crvLpTokenAmount,\n            receiptTokenReceivedAmount,\n            block.timestamp);\n\n        return receiptTokenReceivedAmount;\n    }\n\n    function _withdrawAndClaim(IConvexPool.WithdrawalDetails memory withdrawalDetails) internal onlyOwner nonReentrant recalculateAssetsExposure remainsSolvent returns (uint256){\n        IERC20Metadata crvLpToken = IERC20Metadata(withdrawalDetails.crvLpTokenAddress);\n        IConvexRewarder cvxRewarder = IConvexRewarder(withdrawalDetails.cvxPoolLPTokenAddress);\n        IERC20Metadata crvToken = IERC20Metadata(CRV_TOKEN_ADDRESS);\n        IERC20Metadata cvxToken = IERC20Metadata(CVX_TOKEN_ADDRESS);\n\n        uint256 initialDepositTokenBalance = crvLpToken.balanceOf(address(this));\n        withdrawalDetails.receiptTokenAmount = Math.min(cvxRewarder.balanceOf(address(this)), withdrawalDetails.receiptTokenAmount);\n\n        // Always claim (true) rewards upon withdrawal\n        cvxRewarder.withdraw(withdrawalDetails.receiptTokenAmount, true);\n\n        // Curve LP token\n        DiamondStorageLib.addOwnedAsset(withdrawalDetails.crvLpTokenIdentifier, withdrawalDetails.crvLpTokenAddress);\n\n        // Add reward tokens if any were claimed\n        if(crvToken.balanceOf(address(this)) > 0) {\n            DiamondStorageLib.addOwnedAsset(\"CRV\", CRV_TOKEN_ADDRESS);\n        }\n        if(cvxToken.balanceOf(address(this)) > 0) {\n            DiamondStorageLib.addOwnedAsset(\"CVX\", CVX_TOKEN_ADDRESS);\n        }\n\n        // Convex LP token and rewarder are the same contract\n        if(cvxRewarder.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(withdrawalDetails.cvxPoolIdentifier);\n        }\n\n        uint256 depositTokenReceivedAmount = crvLpToken.balanceOf(address(this)) - initialDepositTokenBalance;\n\n        emit Unstaked(\n            msg.sender,\n            withdrawalDetails.crvLpTokenIdentifier,\n            withdrawalDetails.cvxPoolLPTokenAddress,\n            depositTokenReceivedAmount,\n            withdrawalDetails.receiptTokenAmount,\n            block.timestamp);\n\n\n        return depositTokenReceivedAmount;\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of the vault token\n        * @param depositTokenAmount how much of deposit token was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param asset the asset that was unstaked\n        * @param vault address of the vault token\n        * @param depositTokenAmount how much deposit token was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n}\n"
    },
    "contracts/facets/arbitrum/GLPFacetArbi.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 19d9982858f4feeff1ca98cbf31b07304a79ac7f;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../interfaces/facets/arbitrum/IGLPRewarder.sol\";\nimport \"../../interfaces/facets/arbitrum/IRewardRouterV2.sol\";\nimport \"../../interfaces/facets/arbitrum/IRewardTracker.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract GLPFacetArbi is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    // Used to claim GLP fees\n    address private constant REWARD_ROUTER_ADDRESS = 0x159854e14A862Df9E39E1D128b8e5F70B4A3cE9B;\n    // Used to mint/redeem GLP\n    address private constant GLP_REWARD_ROUTER_ADDRESS = 0xB95DB5B167D75e6d04227CfFFA61069348d271F5;\n    // Used to approve tokens to mint GLP with\n    address private constant GLP_MANAGER_ADDRESS = 0x3963FfC9dff443c2A94f21b129D429891E32ec18;\n    // sGLP\n    address private constant GLP_TOKEN_ADDRESS = 0x5402B5F40310bDED796c7D0F3FF6683f5C0cFfdf;\n\n    function claimGLpFees() external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent {\n        IRewardRouterV2 rewardRouter = IRewardRouterV2(REWARD_ROUTER_ADDRESS);\n        IRewardTracker rewardTracker = IRewardTracker(rewardRouter.feeGlpTracker());\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(rewardTracker.claimable(address(this)) > 0, \"There are no claimable fees\");\n\n        IERC20Metadata wethToken = getERC20TokenInstance(\"ETH\", false);\n        uint256 initialWethBalance = wethToken.balanceOf(address(this));\n\n        rewardRouter.claimFees();\n\n        uint256 postClaimingWethBalance = wethToken.balanceOf(address(this));\n        uint256 wethClaimed = postClaimingWethBalance - initialWethBalance;\n\n        _increaseExposure(tokenManager, address(wethToken), wethClaimed);\n\n        emit GLPFeesClaim(msg.sender, wethClaimed, block.timestamp);\n    }\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent{\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        require(tokenManager.isTokenAssetActive(GLP_TOKEN_ADDRESS), \"GLP not supported.\");\n        require(tokenManager.isTokenAssetActive(_token), \"Asset not supported.\");\n\n        IERC20Metadata tokenToMintWith = IERC20Metadata(_token);\n        bytes32 tokenToMintWithSymbol = tokenManager.tokenAddressToSymbol(_token);\n        IGLPRewarder glpRewarder = IGLPRewarder(GLP_REWARD_ROUTER_ADDRESS);\n        IERC20Metadata glpToken = IERC20Metadata(GLP_TOKEN_ADDRESS);\n\n        uint256 glpInitialBalance = glpToken.balanceOf(address(this));\n\n        _amount = Math.min(tokenToMintWith.balanceOf(address(this)), _amount);\n\n        require(_amount > 0, \"Amount of GLP to mint  has to be greater than 0\");\n\n        _token.safeApprove(GLP_MANAGER_ADDRESS, 0);\n        _token.safeApprove(GLP_MANAGER_ADDRESS, _amount);\n\n        uint256 glpOutputAmount = glpRewarder.mintAndStakeGlp(_token, _amount, _minUsdg, _minGlp);\n\n        require((glpToken.balanceOf(address(this)) - glpInitialBalance) == glpOutputAmount, \"GLP minted and balance difference mismatch\");\n        require(glpOutputAmount >=_minGlp, \"Insufficient output amount\");\n\n        _increaseExposure(tokenManager, GLP_TOKEN_ADDRESS, glpOutputAmount);\n        _decreaseExposure(tokenManager, _token, _amount);\n\n        emit GLPMint(\n            msg.sender,\n            tokenToMintWithSymbol,\n            _amount,\n            glpOutputAmount,\n            block.timestamp\n        );\n\n    }\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut) external nonReentrant onlyOwnerOrInsolvent noBorrowInTheSameBlock   {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        require(tokenManager.isTokenAssetActive(_tokenOut), \"Asset not supported.\");\n\n        IERC20Metadata redeemedToken = IERC20Metadata(_tokenOut);\n        bytes32 redeemedTokenSymbol = tokenManager.tokenAddressToSymbol(_tokenOut);\n        IGLPRewarder glpRewarder = IGLPRewarder(GLP_REWARD_ROUTER_ADDRESS);\n        IERC20Metadata glpToken = IERC20Metadata(GLP_TOKEN_ADDRESS);\n\n        uint256 redeemedTokenInitialBalance = redeemedToken.balanceOf(address(this));\n        _glpAmount = Math.min(glpToken.balanceOf(address(this)), _glpAmount);\n\n        require(_glpAmount > 0, \"Amount of GLP to redeem has to be greater than 0\");\n\n        uint256 redeemedAmount = glpRewarder.unstakeAndRedeemGlp(_tokenOut, _glpAmount, _minOut, address(this));\n\n        require((redeemedToken.balanceOf(address(this)) - redeemedTokenInitialBalance) == redeemedAmount, \"Redeemed token amount and balance difference mismatch\");\n        require(redeemedAmount >= _minOut, \"Insufficient output amount\");\n\n        _decreaseExposure(tokenManager, GLP_TOKEN_ADDRESS, _glpAmount);\n        _increaseExposure(tokenManager, _tokenOut, redeemedAmount);\n\n        emit GLPRedemption(\n            msg.sender,\n            redeemedTokenSymbol,\n            _glpAmount,\n            redeemedAmount,\n            block.timestamp\n        );\n\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /**\n     * @dev emitted after a GLP token mint\n     * @param user the address of user minting GLP\n     * @param tokenToMintWith token which GLP was minted with\n     * @param tokenToMintWithAmount amount of token used to mint GLP\n     * @param glpOutputAmount amount of GLP minted\n     * @param timestamp time of the mint\n     **/\n    event GLPMint(address indexed user, bytes32 indexed tokenToMintWith, uint256 tokenToMintWithAmount, uint256 glpOutputAmount, uint256 timestamp);\n\n    /**\n  * @dev emitted after a GLP token redemption\n  * @param user the address of user redeeming GLP\n  * @param redeemedToken token which GLP was redeemed into\n  * @param glpRedeemedAmount amount of GLP redeemed\n  * @param redeemedTokenAmount amount of redeemedToken redeemed\n  * @param timestamp time of the redemption\n  **/\n    event GLPRedemption(address indexed user, bytes32 indexed redeemedToken, uint256 glpRedeemedAmount, uint256 redeemedTokenAmount, uint256 timestamp);\n\n    /**\n    * @dev emitted after claiming GLP fees\n    * @param user the address of user claiming fees\n    * @param wethAmountClaimed amount of weth fees that were claimed\n    * @param timestamp time of claiming the fees\n    **/\n    event GLPFeesClaim(address indexed user, uint256 wethAmountClaimed, uint256 timestamp);\n}\n"
    },
    "contracts/facets/arbitrum/GmxV2CallbacksFacetArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 65136a418b6f93ab386bcb536b847bd1de0caf3a;\npragma solidity 0.8.27;\n\n//This path is updated during deployment\nimport \"../GmxV2CallbacksFacet.sol\";\n\ncontract GmxV2CallbacksFacetArbitrum is GmxV2CallbacksFacet {\n    using TransferHelper for address;\n\n    // https://github.com/gmx-io/gmx-synthetics/blob/main/deployments/arbitrum/\n    // GMX contracts\n\n    function getGmxV2RoleStore() internal pure override returns (address) {\n        return 0x3c3d99FD298f679DBC2CEcd132b4eC4d0F5e6e72;\n    }\n\n    // Markets\n    address constant GM_ETH_WETH_USDC = 0x70d95587d40A2caf56bd97485aB3Eec10Bee6336;\n    address constant GM_ARB_ARB_USDC = 0xC25cEf6061Cf5dE5eb761b50E4743c1F5D7E5407;\n    address constant GM_LINK_LINK_USDC = 0x7f1fa204bb700853D36994DA19F830b6Ad18455C;\n    address constant GM_UNI_UNI_USDC = 0xc7Abb2C5f3BF3CEB389dF0Eecd6120D451170B50;\n    address constant GM_BTC_WBTC_USDC = 0x47c031236e19d024b42f8AE6780E44A573170703;\n\n    address constant GM_SOL_SOL_USDC = 0x09400D9DB990D5ed3f35D7be61DfAEB900Af03C9;\n    address constant GM_NEAR_WETH_USDC = 0x63Dc80EE90F26363B3FCD609007CC9e14c8991BE;\n    address constant GM_ATOM_WETH_USDC = 0x248C35760068cE009a13076D573ed3497A47bCD4;\n    address constant GM_GMX_GMX_USDC = 0x55391D178Ce46e7AC8eaAEa50A72D1A5a8A622Da;\n\n    address constant GM_ETH_WETH = 0x450bb6774Dd8a756274E0ab4107953259d2ac541;\n    address constant GM_BTC_WBTC = 0x7C11F78Ce78768518D743E81Fdfa2F860C6b9A77;\n\n    // Tokens\n    address constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n    address constant USDC = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831;\n    address constant ARB = 0x912CE59144191C1204E64559FE8253a0e49E6548;\n    address constant LINK = 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4;\n    address constant UNI = 0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0;\n    address constant WBTC = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f;\n\n    address constant SOL = 0x2bcC6D6CdBbDC0a4071e48bb3B969b06B3330c07;\n    address constant GMX = 0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a;\n\n    // Mappings\n    function marketToLongToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_ETH_WETH_USDC || market == GM_ETH_WETH) {\n            return WETH;\n        } else if (market == GM_ARB_ARB_USDC) {\n            return ARB;\n        } else if (market == GM_LINK_LINK_USDC) {\n            return LINK;\n        } else if (market == GM_UNI_UNI_USDC) {\n            return UNI;\n        } else if (market == GM_BTC_WBTC_USDC || market == GM_BTC_WBTC) {\n            return WBTC;\n        } else if (market == GM_SOL_SOL_USDC) {\n            return SOL;\n        } else if (market == GM_NEAR_WETH_USDC) {\n            return WETH;\n        } else if (market == GM_ATOM_WETH_USDC) {\n            return WETH;\n        } else if (market == GM_GMX_GMX_USDC) {\n            return GMX;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    function marketToShortToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_ETH_WETH_USDC) {\n            return USDC;\n        } else if (market == GM_ARB_ARB_USDC) {\n            return USDC;\n        } else if (market == GM_LINK_LINK_USDC) {\n            return USDC;\n        } else if (market == GM_UNI_UNI_USDC) {\n            return USDC;\n        } else if (market == GM_BTC_WBTC_USDC) {\n            return USDC;\n        } else if (market == GM_ETH_WETH) {\n            return WETH;\n        } else if (market == GM_BTC_WBTC) {\n            return WBTC;\n        } else if (market == GM_SOL_SOL_USDC) {\n            return USDC;\n        } else if (market == GM_NEAR_WETH_USDC) {\n            return USDC;\n        } else if (market == GM_ATOM_WETH_USDC) {\n            return USDC;\n        } else if (market == GM_GMX_GMX_USDC) {\n            return USDC;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n}\n"
    },
    "contracts/facets/arbitrum/GmxV2FacetArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 65136a418b6f93ab386bcb536b847bd1de0caf3a;\npragma solidity 0.8.27;\n\n//This path is updated during deployment\nimport \"../GmxV2Facet.sol\";\n\ncontract GmxV2FacetArbitrum is GmxV2Facet {\n    using TransferHelper for address;\n\n    // https://github.com/gmx-io/gmx-synthetics/blob/main/deployments/arbitrum/\n    // GMX contracts\n    function getGmxV2Router() internal pure override returns (address) {\n        return 0x7452c558d45f8afC8c83dAe62C3f8A5BE19c71f6;\n    }\n\n    function getGmxV2ExchangeRouter() internal pure override returns (address) {\n        return 0x69C527fC77291722b52649E45c838e41be8Bf5d5;\n    }\n\n    function getGmxV2DepositVault() internal pure override returns (address) {\n        return 0xF89e77e8Dc11691C9e8757e84aaFbCD8A67d7A55;\n    }\n\n    function getGmxV2WithdrawalVault() internal pure override returns (address) {\n        return 0x0628D46b5D145f183AdB6Ef1f2c97eD1C4701C55;\n    }\n\n    // Markets\n    address constant GM_ETH_WETH_USDC = 0x70d95587d40A2caf56bd97485aB3Eec10Bee6336;\n    address constant GM_ARB_ARB_USDC = 0xC25cEf6061Cf5dE5eb761b50E4743c1F5D7E5407;\n    address constant GM_LINK_LINK_USDC = 0x7f1fa204bb700853D36994DA19F830b6Ad18455C;\n    address constant GM_UNI_UNI_USDC = 0xc7Abb2C5f3BF3CEB389dF0Eecd6120D451170B50;\n    address constant GM_BTC_WBTC_USDC = 0x47c031236e19d024b42f8AE6780E44A573170703;\n    address constant GM_SOL_SOL_USDC = 0x09400D9DB990D5ed3f35D7be61DfAEB900Af03C9;\n    address constant GM_NEAR_WETH_USDC = 0x63Dc80EE90F26363B3FCD609007CC9e14c8991BE;\n    address constant GM_ATOM_WETH_USDC = 0x248C35760068cE009a13076D573ed3497A47bCD4;\n    address constant GM_GMX_GMX_USDC = 0x55391D178Ce46e7AC8eaAEa50A72D1A5a8A622Da;\n\n    // Tokens\n    address constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n    address constant USDC = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831;\n    address constant ARB = 0x912CE59144191C1204E64559FE8253a0e49E6548;\n    address constant LINK = 0xf97f4df75117a78c1A5a0DBb814Af92458539FB4;\n    address constant UNI = 0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0;\n    address constant WBTC = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f;\n    address constant SOL = 0x2bcC6D6CdBbDC0a4071e48bb3B969b06B3330c07;\n    address constant GMX = 0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a;\n\n    // Mappings\n    function marketToLongToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_ETH_WETH_USDC) {\n            return WETH;\n        } else if (market == GM_ARB_ARB_USDC) {\n            return ARB;\n        } else if (market == GM_LINK_LINK_USDC) {\n            return LINK;\n        } else if (market == GM_UNI_UNI_USDC) {\n            return UNI;\n        } else if (market == GM_BTC_WBTC_USDC) {\n            return WBTC;\n        } else if (market == GM_SOL_SOL_USDC) {\n            return SOL;\n        } else if (market == GM_NEAR_WETH_USDC) {\n            return WETH;\n        } else if (market == GM_ATOM_WETH_USDC) {\n            return WETH;\n        } else if (market == GM_GMX_GMX_USDC) {\n            return GMX;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    function marketToShortToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_ETH_WETH_USDC) {\n            return USDC;\n        } else if (market == GM_ARB_ARB_USDC) {\n            return USDC;\n        } else if (market == GM_LINK_LINK_USDC) {\n            return USDC;\n        } else if (market == GM_UNI_UNI_USDC) {\n            return USDC;\n        } else if (market == GM_BTC_WBTC_USDC) {\n            return USDC;\n        } else if (market == GM_SOL_SOL_USDC) {\n            return USDC;\n        } else if (market == GM_NEAR_WETH_USDC) {\n            return USDC;\n        } else if (market == GM_ATOM_WETH_USDC) {\n            return USDC;\n        } else if (market == GM_GMX_GMX_USDC) {\n            return USDC;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    // DEPOSIT\n    function depositEthUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? WETH : USDC;\n\n        _deposit(\n            GM_ETH_WETH_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositArbUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? ARB : USDC;\n\n        _deposit(\n            GM_ARB_ARB_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositLinkUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? LINK : USDC;\n\n        _deposit(\n            GM_LINK_LINK_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositUniUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? UNI : USDC;\n\n        _deposit(\n            GM_UNI_UNI_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositBtcUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? WBTC : USDC;\n\n        _deposit(\n            GM_BTC_WBTC_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositSolUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? SOL : USDC;\n\n        _deposit(\n            GM_SOL_SOL_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositNearUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? WETH : USDC;\n\n        _deposit(\n            GM_NEAR_WETH_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositAtomUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? WETH : USDC;\n\n        _deposit(\n            GM_ATOM_WETH_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositGmxUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? GMX : USDC;\n\n        _deposit(\n            GM_GMX_GMX_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    // WITHDRAW\n    function withdrawEthUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_ETH_WETH_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawArbUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_ARB_ARB_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawLinkUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_LINK_LINK_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawUniUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_UNI_UNI_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawBtcUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_BTC_WBTC_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawSolUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_SOL_SOL_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawNearUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_NEAR_WETH_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawAtomUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_ATOM_WETH_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawGmxUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_GMX_GMX_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n}\n"
    },
    "contracts/facets/arbitrum/GmxV2PlusFacetArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 65136a418b6f93ab386bcb536b847bd1de0caf3a;\npragma solidity 0.8.27;\n\n//This path is updated during deployment\nimport \"../GmxV2PlusFacet.sol\";\n\ncontract GmxV2PlusFacetArbitrum is GmxV2PlusFacet {\n    using TransferHelper for address;\n\n    // https://github.com/gmx-io/gmx-synthetics/blob/main/deployments/arbitrum/\n    // GMX contracts\n    function getGmxV2Router() internal pure override returns (address) {\n        return 0x7452c558d45f8afC8c83dAe62C3f8A5BE19c71f6;\n    }\n\n    function getGmxV2ExchangeRouter() internal pure override returns (address) {\n        return 0x69C527fC77291722b52649E45c838e41be8Bf5d5;\n    }\n\n    function getGmxV2DepositVault() internal pure override returns (address) {\n        return 0xF89e77e8Dc11691C9e8757e84aaFbCD8A67d7A55;\n    }\n\n    function getGmxV2WithdrawalVault() internal pure override returns (address) {\n        return 0x0628D46b5D145f183AdB6Ef1f2c97eD1C4701C55;\n    }\n\n    // Markets\n    address constant GM_ETH_WETH = 0x450bb6774Dd8a756274E0ab4107953259d2ac541;\n    address constant GM_BTC_WBTC = 0x7C11F78Ce78768518D743E81Fdfa2F860C6b9A77;\n\n    // Tokens\n    address constant WETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n    address constant WBTC = 0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f;\n\n    // Mappings\n    function marketToToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_ETH_WETH) {\n            return WETH;\n        } else if (market == GM_BTC_WBTC) {\n            return WBTC;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    // DEPOSIT\n    function depositEthGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        _deposit(GM_ETH_WETH, tokenAmount, minGmAmount, executionFee);\n    }\n\n    function depositBtcGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        _deposit(GM_BTC_WBTC, tokenAmount, minGmAmount, executionFee);\n    }\n\n    // WITHDRAW\n    function withdrawEthGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_ETH_WETH,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawBtcGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_BTC_WBTC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n}\n"
    },
    "contracts/facets/arbitrum/LevelFinanceFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 64a9eb8d8ae32bd1462f11fe1513b45de6dcdadb;\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/facets/arbitrum/ILevelFinance.sol\";\nimport \"../../interfaces/facets/arbitrum/ILevelOrderManager.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract LevelFinanceFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    address private constant ETH_TOKEN =\n        0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n\n    address private constant LEVEL_FARMING =\n        0xC18c952F800516E1eef6aB482F3d331c84d43d38;\n\n    address private constant LEVEL_ORDER_MANAGER = 0x2215298606C9D0274527b13519Ec50c3A7f1c1eF;\n\n    // LPs\n    address private constant LEVEL_SENIOR_LLP =\n        0x5573405636F4b895E511C9C54aAfbefa0E7Ee458;\n    address private constant LEVEL_MEZZANINE_LLP =\n        0xb076f79f8D1477165E2ff8fa99930381FB7d94c1;\n    address private constant LEVEL_JUNIOR_LLP =\n        0x502697AF336F7413Bb4706262e7C506Edab4f3B9;\n\n    // ----- STAKE -----\n\n    /**\n     * Stakes ETH in the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of ETH to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeEthSnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeEthSnr.selector\n            });\n        _stakeTokenLevel(address(0), \"ETH\", amount, minLpAmount, 0, position);\n    }\n\n    /**\n     * Stakes ETH in the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of ETH to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeEthMze(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeEthMze.selector\n            });\n        _stakeTokenLevel(address(0), \"ETH\", amount, minLpAmount, 1, position);\n    }\n\n    /**\n     * Stakes ETH in the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of ETH to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeEthJnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeEthJnr.selector\n            });\n        _stakeTokenLevel(address(0), \"ETH\", amount, minLpAmount, 2, position);\n    }\n\n    /**\n     * Stakes BTC in the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of BTC to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeBtcSnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeBtcSnr.selector\n            });\n        _stakeTokenLevel(\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f,\n            \"BTC\",\n            amount,\n            minLpAmount,\n            0,\n            position\n        );\n    }\n\n    /**\n     * Stakes BTC in the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of BTC to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeBtcMze(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeBtcMze.selector\n            });\n        _stakeTokenLevel(\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f,\n            \"BTC\",\n            amount,\n            minLpAmount,\n            1,\n            position\n        );\n    }\n\n    /**\n     * Stakes BTC in the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of BTC to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeBtcJnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeBtcJnr.selector\n            });\n        _stakeTokenLevel(\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f,\n            \"BTC\",\n            amount,\n            minLpAmount,\n            2,\n            position\n        );\n    }\n\n    /**\n     * Stakes USDT in the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDT to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeUsdtSnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdtSnr.selector\n            });\n        _stakeTokenLevel(\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9,\n            \"USDT\",\n            amount,\n            minLpAmount,\n            0,\n            position\n        );\n    }\n\n    /**\n     * Stakes USDT in the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDT to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeUsdtMze(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdtMze.selector\n            });\n        _stakeTokenLevel(\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9,\n            \"USDT\",\n            amount,\n            minLpAmount,\n            1,\n            position\n        );\n    }\n\n    /**\n     * Stakes USDT in the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDT to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeUsdtJnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdtJnr.selector\n            });\n        _stakeTokenLevel(\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9,\n            \"USDT\",\n            amount,\n            minLpAmount,\n            2,\n            position\n        );\n    }\n\n    /**\n     * Stakes USDC in the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDC to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeUsdcSnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcSnr.selector\n            });\n        _stakeTokenLevel(\n            0xaf88d065e77c8cC2239327C5EDb3A432268e5831,\n            \"USDC\",\n            amount,\n            minLpAmount,\n            0,\n            position\n        );\n    }\n\n    /**\n     * Stakes USDC in the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDC to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeUsdcMze(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcMze.selector\n            });\n        _stakeTokenLevel(\n            0xaf88d065e77c8cC2239327C5EDb3A432268e5831,\n            \"USDC\",\n            amount,\n            minLpAmount,\n            1,\n            position\n        );\n    }\n\n    /**\n     * Stakes USDC in the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDC to be staked\n     * @param minLpAmount minimum amount of LLP\n     **/\n    function levelStakeUsdcJnr(\n        uint256 amount,\n        uint256 minLpAmount\n    )\n        public\n        onlyOwner\n        nonReentrant\n        recalculateAssetsExposure\n        remainsSolvent\n    {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcJnr.selector\n            });\n        _stakeTokenLevel(\n            0xaf88d065e77c8cC2239327C5EDb3A432268e5831,\n            \"USDC\",\n            amount,\n            minLpAmount,\n            2,\n            position\n        );\n    }\n\n    // ----- UNSTAKE -----\n\n    /**\n     * Unstakes ETH from the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of ETH to be unstaked\n     **/\n    function levelUnstakeEthSnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeEthSnr.selector\n            });\n        _unstakeTokenLevel(address(0), \"ETH\", lpAmount, minAmount, 0, position);\n    }\n\n    /**\n     * Unstakes ETH from the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of ETH to be unstaked\n     **/\n    function levelUnstakeEthMze(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeEthMze.selector\n            });\n        _unstakeTokenLevel(address(0), \"ETH\", lpAmount, minAmount, 1, position);\n    }\n\n    /**\n     * Unstakes ETH from the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of ETH to be unstaked\n     **/\n    function levelUnstakeEthJnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeEthJnr.selector\n            });\n        _unstakeTokenLevel(address(0), \"ETH\", lpAmount, minAmount, 2, position);\n    }\n\n    /**\n     * Unstakes BTC from the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of BTC to be unstaked\n     **/\n    function levelUnstakeBtcSnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeBtcSnr.selector\n            });\n        _unstakeTokenLevel(\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f,\n            \"BTC\",\n            lpAmount,\n            minAmount,\n            0,\n            position\n        );\n    }\n\n    /**\n     * Unstakes BTC from the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of BTC to be unstaked\n     **/\n    function levelUnstakeBtcMze(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeBtcMze.selector\n            });\n        _unstakeTokenLevel(\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f,\n            \"BTC\",\n            lpAmount,\n            minAmount,\n            1,\n            position\n        );\n    }\n\n    /**\n     * Unstakes BTC from the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of BTC to be unstaked\n     **/\n    function levelUnstakeBtcJnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeBtcJnr.selector\n            });\n        _unstakeTokenLevel(\n            0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f,\n            \"BTC\",\n            lpAmount,\n            minAmount,\n            2,\n            position\n        );\n    }\n\n    /**\n     * Unstakes USDT from the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of USDT to be unstaked\n     **/\n    function levelUnstakeUsdtSnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdtSnr.selector\n            });\n        _unstakeTokenLevel(\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9,\n            \"USDT\",\n            lpAmount,\n            minAmount,\n            0,\n            position\n        );\n    }\n\n    /**\n     * Unstakes USDT from the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of USDT to be unstaked\n     **/\n    function levelUnstakeUsdtMze(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdtMze.selector\n            });\n        _unstakeTokenLevel(\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9,\n            \"USDT\",\n            lpAmount,\n            minAmount,\n            1,\n            position\n        );\n    }\n\n    /**\n     * Unstakes USDT from the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of USDT to be unstaked\n     **/\n    function levelUnstakeUsdtJnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdtJnr.selector\n            });\n        _unstakeTokenLevel(\n            0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9,\n            \"USDT\",\n            lpAmount,\n            minAmount,\n            2,\n            position\n        );\n    }\n\n    /**\n     * Unstakes USDC from the senior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of USDC to be unstaked\n     **/\n    function levelUnstakeUsdcSnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyWhitelistedLiquidators nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcSnr.selector\n            });\n        _unstakeTokenLevel(\n            0xaf88d065e77c8cC2239327C5EDb3A432268e5831,\n            \"USDC\",\n            lpAmount,\n            minAmount,\n            0,\n            position\n        );\n    }\n\n    /**\n     * Unstakes USDC from the mezzanine tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of USDC to be unstaked\n     **/\n    function levelUnstakeUsdcMze(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyWhitelistedLiquidators nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcMze.selector\n            });\n        _unstakeTokenLevel(\n            0xaf88d065e77c8cC2239327C5EDb3A432268e5831,\n            \"USDC\",\n            lpAmount,\n            minAmount,\n            1,\n            position\n        );\n    }\n\n    modifier onlyWhitelistedLiquidators() {\n        // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\n        require(SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\n        _;\n    }\n\n    /**\n     * Unstakes USDC from the junior tranche of Level finance\n     * @dev This function uses the redstone-evm-connector\n     * @param lpAmount amount of LLP to be unstaked\n     * @param minAmount minimum amount of USDC to be unstaked\n     **/\n    function levelUnstakeUsdcJnr(\n        uint256 lpAmount,\n        uint256 minAmount\n    ) public onlyWhitelistedLiquidators nonReentrant recalculateAssetsExposure {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcJnr.selector\n            });\n        _unstakeTokenLevel(\n            0xaf88d065e77c8cC2239327C5EDb3A432268e5831,\n            \"USDC\",\n            lpAmount,\n            minAmount,\n            2,\n            position\n        );\n    }\n\n    // ----- BALANCE -----\n\n    function levelSnrBalance() public view returns (uint256 _stakedBalance) {\n        return _levelBalance(0);\n    }\n\n    function levelMzeBalance() public view returns (uint256 _stakedBalance) {\n        return _levelBalance(1);\n    }\n\n    function levelJnrBalance() public view returns (uint256 _stakedBalance) {\n        return _levelBalance(2);\n    }\n\n    function _levelBalance(uint256 pid) internal view returns (uint256) {\n        ILevelFinance.UserInfo memory userInfo = ILevelFinance(LEVEL_FARMING)\n            .userInfo(pid, address(this));\n        return userInfo.amount;\n    }\n\n    // ----- PRIVATE METHODS -----\n\n    /**\n     * Stakes {stakingDetails.lpTokenAddress} LP token in the Level finance\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function _stakeTokenLevel(\n        address asset,\n        bytes32 symbol,\n        uint256 amount,\n        uint256 minLpAmount,\n        uint256 pid,\n        IStakingPositions.StakedPosition memory position\n    ) private {\n        revert(\"No longer supported.\");\n    }\n\n    function exitLevelFinanceAndHarvestRewardsForOwner() external payable onlyWhitelistedLiquidators{\n        ILevelFinance farmingContract = ILevelFinance(LEVEL_FARMING);\n        ILevelOrderManager orderManager = ILevelOrderManager(LEVEL_ORDER_MANAGER);\n\n        uint256 snrTrancheBalance = levelSnrBalance();\n\n\n        if(snrTrancheBalance > 0){\n            farmingContract.withdraw(0, snrTrancheBalance, address(this));\n            uint256 llpSeniorBalance = IERC20Metadata(LEVEL_SENIOR_LLP).balanceOf(address(this));\n            IERC20Metadata(LEVEL_SENIOR_LLP).approve(LEVEL_ORDER_MANAGER, llpSeniorBalance);\n\n            orderManager.placeRemoveLiquidityOrder{value: msg.value}(\n                LEVEL_SENIOR_LLP,\n                0xaf88d065e77c8cC2239327C5EDb3A432268e5831,\n                llpSeniorBalance,\n                0,\n                uint64(block.timestamp + 180),\n                address(this)\n            );\n            farmingContract.harvest(0, DiamondStorageLib.contractOwner());\n            DiamondStorageLib.removeStakedPosition(\"stkdSnrLLP\");\n            DiamondStorageLib.addOwnedAsset(\"USDC\",0xaf88d065e77c8cC2239327C5EDb3A432268e5831);\n        }\n    }\n\n    /**\n     * Unstakes {stakingDetails.lpTokenAddress} LP token from the Level finance\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function _unstakeTokenLevel(\n        address asset,\n        bytes32 symbol,\n        uint256 amount,\n        uint256 minAmount,\n        uint256 pid,\n        IStakingPositions.StakedPosition memory position\n    ) private {\n        ILevelFinance farmingContract = ILevelFinance(LEVEL_FARMING);\n        IERC20Metadata unstakedToken = getERC20TokenInstance(symbol, false);\n        uint256 initialReceiptTokenBalance = farmingContract\n        .userInfo(pid, address(this))\n        .amount;\n\n        amount = Math.min(initialReceiptTokenBalance, amount);\n\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        uint256 balance = unstakedToken.balanceOf(address(this));\n\n        if (asset == address(0)) {\n            farmingContract.removeLiquidityETH(\n                pid,\n                amount,\n                minAmount,\n                address(this)\n            );\n            IWrappedNativeToken(ETH_TOKEN).deposit{value: address(this).balance}();\n        } else {\n            farmingContract.removeLiquidity(\n                pid,\n                amount,\n                asset,\n                minAmount,\n                address(this)\n            );\n        }\n\n        uint256 newBalance = unstakedToken.balanceOf(address(this));\n\n        uint256 newReceiptTokenBalance = farmingContract\n        .userInfo(pid, address(this))\n        .amount;\n\n        // Add/remove owned tokens\n        if (newReceiptTokenBalance == 0) {\n            DiamondStorageLib.removeStakedPosition(position.identifier);\n        }\n        DiamondStorageLib.addOwnedAsset(symbol, address(unstakedToken));\n\n        emit Unstaked(\n            msg.sender,\n            symbol,\n            LEVEL_FARMING,\n            newBalance - balance,\n            initialReceiptTokenBalance - newReceiptTokenBalance,\n            block.timestamp\n        );\n\n        farmingContract.harvest(pid, DiamondStorageLib.contractOwner());\n        emit RewardsHarvested(msg.sender, pid, block.timestamp);\n    }\n\n    function harvestRewards(uint256 pid) external nonReentrant onlyOwner {\n        ILevelFinance farmingContract = ILevelFinance(LEVEL_FARMING);\n        farmingContract.harvest(pid, msg.sender);\n        emit RewardsHarvested(msg.sender, pid, block.timestamp);\n    }\n\n    function unstakeAndWithdrawLLP(uint256 pid, uint256 amount) external nonReentrant onlyOwner recalculateAssetsExposure remainsSolvent{\n        revert(\"No longer supported.\");\n    }\n\n    // @dev Requires an approval on LLP token for the PrimeAccount address prior to calling this function\n    function depositLLPAndStake(uint256 pid, uint256 amount) external nonReentrant onlyOwner recalculateAssetsExposure{\n        revert(\"No longer supported.\");\n    }\n\n    function pidToLLPToken(uint256 pid) private pure returns (address){\n        if(pid == 0){\n            return LEVEL_SENIOR_LLP;\n        } else if(pid == 1){\n            return LEVEL_MEZZANINE_LLP;\n        } else if(pid == 2){\n            return LEVEL_JUNIOR_LLP;\n        } else {\n            revert(\"Invalid pid\");\n        }\n    }\n\n    function pidToStakedPosition(uint256 pid) private pure returns (IStakingPositions.StakedPosition memory){\n        if(pid == 0){\n            return IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_SENIOR_LLP,\n                symbol: \"arbSnrLLP\",\n                identifier: \"stkdSnrLLP\",\n                balanceSelector: this.levelSnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcSnr.selector\n            });\n        } else if(pid == 1){\n            return IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_MEZZANINE_LLP,\n                symbol: \"arbMzeLLP\",\n                identifier: \"stkdMzeLLP\",\n                balanceSelector: this.levelMzeBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcMze.selector\n            });\n        } else if(pid == 2){\n            return IStakingPositions\n            .StakedPosition({\n                asset: LEVEL_JUNIOR_LLP,\n                symbol: \"arbJnrLLP\",\n                identifier: \"stkdJnrLLP\",\n                balanceSelector: this.levelJnrBalance.selector,\n                unstakeSelector: this.levelUnstakeUsdcJnr.selector\n            });\n        } else {\n            revert(\"Invalid pid\");\n        }\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    /**\n     * @dev emitted when user stakes an asset\n     * @param user the address executing staking\n     * @param asset the asset that was staked\n     * @param vault address of the vault token\n     * @param depositTokenAmount how much of deposit token was staked\n     * @param receiptTokenAmount how much of receipt token was received\n     * @param timestamp of staking\n     **/\n    event Staked(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositTokenAmount,\n        uint256 receiptTokenAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user deposits LLP tokens into PA\n     * @param user the address depositing\n     * @param asset the asset that was staked\n     * @param vault address of the vault token\n     * @param depositAmount how much of LLP was deposited\n     * @param timestamp of deposit\n     **/\n    event DepositedLLP(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user withdraws LLP tokens from PA\n     * @param user the address withdrawing\n     * @param asset the asset that was staked\n     * @param vault address of the vault token\n     * @param depositAmount how much of LLP was withdrawn\n     * @param timestamp of withdrawal\n     **/\n    event WithdrewLLP(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user unstakes an asset\n     * @param user the address executing unstaking\n     * @param vault address of the vault token\n     * @param asset the asset that was unstaked\n     * @param depositTokenAmount how much deposit token was received\n     * @param receiptTokenAmount how much receipt token was unstaked\n     * @param timestamp of unstaking\n     **/\n    event Unstaked(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositTokenAmount,\n        uint256 receiptTokenAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user harvests rewards\n     * @param user the address collecting rewards\n     * @param pid tranche id that rewards were harvested from\n     * @param timestamp of collecting rewards\n     **/\n    event RewardsHarvested(\n        address indexed user,\n        uint256 indexed pid,\n        uint256 timestamp\n    );\n}\n"
    },
    "contracts/facets/arbitrum/LTIPFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8e5d3085ec4332d1a170bb7087f08c89141d9afe;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol\";\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../SolvencyFacetProd.sol\";\nimport {ILTIPFacet} from \"../../interfaces/facets/arbitrum/ILTIPFacet.sol\";\n\ncontract LTIPFacet is ILTIPFacet, RedstoneConsumerNumericBase {\n    function getDataServiceId() public view virtual override returns (string memory) {\n        return \"redstone-arbitrum-prod\";\n    }\n\n    function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n        return 3;\n    }\n\n    function getAuthorisedSignerIndex(\n        address signerAddress\n    ) public view virtual override returns (uint8) {\n        if (signerAddress == 0x345Efd26098e173F811e3B9Af1B0e0a11872B38b) {\n            return 0;\n        } else if (signerAddress == 0xbD0c5ccd85D5831B10E3e49527B8Cd67e2EFAf39) {\n            return 1;\n        } else if (signerAddress == 0x2F3E8EC88C01593d10ca9461c807660fF2D8DB28) {\n            return 2;\n        } else if (signerAddress == 0xb7f154bB5491565D215F4EB1c3fe3e84960627aF) {\n            return 3;\n        } else if (signerAddress == 0xE6b0De8F4B31F137d3c59b5a0A71e66e7D504Ef9) {\n            return 4;\n        } else {\n            revert SignerNotAuthorised(signerAddress);\n        }\n    }\n\n    function getTotalAssetsValueBase(SolvencyFacetProd.AssetPrice[] memory ownedAssetsPrices) internal view returns (uint256) {\n        if (ownedAssetsPrices.length > 0) {\n            ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n            uint256 total = address(this).balance * ownedAssetsPrices[0].price / 10 ** 8;\n\n            for (uint256 i = 0; i < ownedAssetsPrices.length; i++) {\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssetsPrices[i].asset, true));\n                uint256 assetBalance = token.balanceOf(address(this));\n\n                total = total + (ownedAssetsPrices[i].price * 10 ** 10 * assetBalance / (10 ** token.decimals()));\n            }\n            return total;\n        } else {\n            return 0;\n        }\n    }\n\n    function getDebtAssets() internal view returns(bytes32[] memory result) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        result = tokenManager.getAllPoolAssets();\n    }\n\n    function getDebtAssetsPrices() internal view returns(SolvencyFacetProd.AssetPrice[] memory result) {\n        bytes32[] memory debtAssets = getDebtAssets();\n\n        uint256[] memory debtAssetsPrices = getOracleNumericValuesFromTxMsg(debtAssets);\n        result = new SolvencyFacetProd.AssetPrice[](debtAssetsPrices.length);\n\n        for(uint i; i<debtAssetsPrices.length; i++){\n            result[i] = SolvencyFacetProd.AssetPrice({\n                asset: debtAssets[i],\n                price: debtAssetsPrices[i]\n            });\n        }\n    }\n\n    function getDebt() internal view virtual returns (uint256) {\n        SolvencyFacetProd.AssetPrice[] memory debtAssetsPrices = getDebtAssetsPrices();\n        return getDebtBase(debtAssetsPrices);\n    }\n\n    function getDebtBase(SolvencyFacetProd.AssetPrice[] memory debtAssetsPrices) internal view returns (uint256){\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        uint256 debt;\n\n        for (uint256 i; i < debtAssetsPrices.length; i++) {\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(debtAssetsPrices[i].asset, true));\n\n            Pool pool = Pool(tokenManager.getPoolAddress(debtAssetsPrices[i].asset));\n            //10**18 (wei in eth) / 10**8 (precision of oracle feed) = 10**10\n            debt = debt + pool.getBorrowed(address(this)) * debtAssetsPrices[i].price * 10 ** 10\n                / 10 ** token.decimals();\n        }\n\n        return debt;\n    }\n\n    function getLTIPEligibleTVL() public view returns (uint256) {\n        bytes32[] memory notEligibleTokens = new bytes32[](19);\n        notEligibleTokens[0] = bytes32(\"ETH\");\n        notEligibleTokens[1] = bytes32(\"USDC\");\n        notEligibleTokens[2] = bytes32(\"ARB\");\n        notEligibleTokens[3] = bytes32(\"BTC\");\n        notEligibleTokens[4] = bytes32(\"DAI\");\n        notEligibleTokens[5] = bytes32(\"USDT\");\n        notEligibleTokens[6] = bytes32(\"FRAX\");\n        notEligibleTokens[7] = bytes32(\"USDC.e\");\n        notEligibleTokens[8] = bytes32(\"UNI\");\n        notEligibleTokens[9] = bytes32(\"LINK\");\n        notEligibleTokens[10] = bytes32(\"GMX\");\n        notEligibleTokens[11] = bytes32(\"MAGIC\");\n        notEligibleTokens[12] = bytes32(\"WOO\");\n        notEligibleTokens[13] = bytes32(\"wstETH\");\n        notEligibleTokens[14] = bytes32(\"JOE\");\n        notEligibleTokens[15] = bytes32(\"GRAIL\");\n        notEligibleTokens[16] = bytes32(\"ezETH\");\n        notEligibleTokens[17] = bytes32(\"weETH\");\n        notEligibleTokens[18] = bytes32(\"rsETH\");\n\n        uint256[] memory prices = getOracleNumericValuesFromTxMsg(notEligibleTokens);\n\n        SolvencyFacetProd.AssetPrice[] memory assetsPrices = new SolvencyFacetProd.AssetPrice[](notEligibleTokens.length);\n\n        for(uint i; i<notEligibleTokens.length; i++){\n            assetsPrices[i] = SolvencyFacetProd.AssetPrice({\n                asset: notEligibleTokens[i],\n                price: prices[i]\n            });\n        }\n\n        uint256 notEligibleAssetsValue = getTotalAssetsValueBase(assetsPrices);\n        uint256 debt = getDebt();\n\n        return debt > notEligibleAssetsValue ? debt - notEligibleAssetsValue : 0;\n    }\n}\n"
    },
    "contracts/facets/arbitrum/PenpieFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 45f62a9cb0dbaab64877c33c5a5f9324e08e6a40;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/arbitrum/IPendleRouter.sol\";\nimport \"../../interfaces/arbitrum/IPendleDepositHelper.sol\";\nimport \"../../interfaces/arbitrum/IMasterPenpie.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract PenpieFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    // CONSTANTS\n\n    address private constant PENDLE_ROUTER =\n        0x888888888889758F76e7103c6CbF23ABbF58F946;\n    address public constant DEPOSIT_HELPER =\n        0xc06a5d3014b9124Bf215287980305Af2f793eB30;\n    address public constant PENDLE_STAKING =\n        0x6DB96BBEB081d2a85E0954C252f2c1dC108b3f81;\n    address public constant MASTER_PENPIE =\n        0x0776C06907CE6Ff3d9Dbf84bA9B3422d7225942D;\n    address public constant PNP = 0x2Ac2B254Bc18cD4999f64773a966E4f4869c34Ee;\n    address public constant PENDLE = 0x0c880f6761F1af8d9Aa9C466984b80DAb9a8c9e8;\n    address public constant SILO = 0x0341C0C0ec423328621788d4854119B97f44E391;\n\n    address public constant PENDLE_EZ_ETH_MARKET =\n        0x5E03C94Fc5Fb2E21882000A96Df0b63d2c4312e2;\n    address public constant PENDLE_EZ_ETH_26_09_24 =\n    0x35f3dB08a6e9cB4391348b0B404F493E7ae264c0;\n\n    address public constant PENDLE_WST_ETH_MARKET =\n        0xFd8AeE8FCC10aac1897F8D5271d112810C79e022;\n    address public constant PENDLE_WSTETH_26_06_25 =\n    0x08a152834de126d2ef83D612ff36e4523FD0017F;\n\n    address public constant PENDLE_E_ETH_MARKET =\n        0x952083cde7aaa11AB8449057F7de23A970AA8472;\n    address public constant PENDLE_E_ETH_26_09_24 =\n    0xf9F9779d8fF604732EBA9AD345E6A27EF5c2a9d6;\n\n    address public constant PENDLE_RS_ETH_MARKET =\n        0x6Ae79089b2CF4be441480801bb741A531d94312b;\n    address public constant PENDLE_RS_ETH_26_09_24 =\n    0xED99fC8bdB8E9e7B8240f62f69609a125A0Fbf14;\n\n    address public constant PENDLE_WST_ETH_SILO_MARKET =\n        0xACcd9A7cb5518326BeD715f90bD32CDf2fEc2D14;\n\n    // PUBLIC FUNCTIONS\n\n    /**\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function depositToPendleAndStakeInPenpie(\n        bytes32 asset,\n        uint256 amount,\n        address market,\n        uint256 minLpOut,\n        IPendleRouter.ApproxParams memory guessPtReceivedFromSy,\n        IPendleRouter.TokenInput memory input,\n        IPendleRouter.LimitOrderData memory limit\n    ) external onlyOwner nonReentrant remainsSolvent {\n        require(minLpOut > 0, \"Invalid minLpOut\");\n\n        address lpToken = _getPenpieLpToken(market);\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        IERC20 token = IERC20(tokenManager.getAssetAddress(asset, false));\n\n        amount = Math.min(token.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot stake 0 tokens\");\n\n        address(token).safeApprove(PENDLE_ROUTER, 0);\n        address(token).safeApprove(PENDLE_ROUTER, amount);\n\n        (uint256 netLpOut, , ) = IPendleRouter(PENDLE_ROUTER)\n            .addLiquiditySingleToken(\n                address(this),\n                market,\n                minLpOut,\n                guessPtReceivedFromSy,\n                input,\n                limit\n            );\n        require(netLpOut >= minLpOut, \"Too little received\");\n\n        market.safeApprove(PENDLE_STAKING, 0);\n        market.safeApprove(PENDLE_STAKING, netLpOut);\n\n        IPendleDepositHelper(DEPOSIT_HELPER).depositMarket(market, netLpOut);\n\n        _increaseExposure(tokenManager, lpToken, netLpOut);\n        _decreaseExposure(tokenManager, address(token), amount);\n\n        emit Staked(msg.sender, asset, lpToken, amount, netLpOut, block.timestamp);\n    }\n\n    /**\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function unstakeFromPenpieAndWithdrawFromPendle(\n        bytes32 asset,\n        uint256 amount,\n        address market,\n        uint256 minOut,\n        IPendleRouter.TokenOutput memory output,\n        IPendleRouter.LimitOrderData memory limit\n    ) external onlyOwnerOrInsolvent nonReentrant returns (uint256) {\n        address lpToken = _getPenpieLpToken(market);\n        uint256 netTokenOut;\n\n        {\n            amount = Math.min(IERC20(lpToken).balanceOf(address(this)), amount);\n            require(amount > 0, \"Cannot unstake 0 tokens\");\n\n            {\n                (\n                    uint256 pendingPenpie,\n                    address[] memory bonusTokenAddresses,\n                    uint256[] memory pendingBonusRewards\n                ) = pendingRewards(market);\n\n                IPendleDepositHelper(DEPOSIT_HELPER).withdrawMarketWithClaim(\n                    market,\n                    amount,\n                    true\n                );\n\n                _handleRewards(pendingPenpie, bonusTokenAddresses, pendingBonusRewards);\n            }\n\n            market.safeApprove(PENDLE_ROUTER, 0);\n            market.safeApprove(PENDLE_ROUTER, amount);\n\n            (netTokenOut, , ) = IPendleRouter(PENDLE_ROUTER)\n                .removeLiquiditySingleToken(\n                    address(this),\n                    market,\n                    amount,\n                    output,\n                    limit\n                );\n            require(netTokenOut >= minOut, \"Too little received\");\n\n            ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n            address token = tokenManager.getAssetAddress(asset, false);\n\n            require(token == output.tokenOut, \"Invalid input token\");\n\n            _increaseExposure(tokenManager, token, netTokenOut);\n            _decreaseExposure(tokenManager, lpToken, amount);\n        }\n\n        emit Unstaked(\n            msg.sender,\n            asset,\n            lpToken,\n            netTokenOut,\n            amount,\n            block.timestamp\n        );\n\n        return netTokenOut;\n    }\n\n    /**\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function depositPendleLPAndStakeInPenpie(\n        address market,\n        uint256 amount\n    ) external onlyOwner nonReentrant remainsSolvent {\n        address lpToken = _getPenpieLpToken(market);\n\n        market.safeTransferFrom(msg.sender, address(this), amount);\n\n        market.safeApprove(PENDLE_STAKING, 0);\n        market.safeApprove(PENDLE_STAKING, amount);\n\n        IPendleDepositHelper(DEPOSIT_HELPER).depositMarket(market, amount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, lpToken, amount);\n\n        emit PendleLpStaked(msg.sender, lpToken, amount, block.timestamp);\n    }\n\n    /**\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function unstakeFromPenpieAndWithdrawPendleLP(\n        address market,\n        uint256 amount\n    )\n        external\n        onlyOwner\n        canRepayDebtFully\n        nonReentrant\n        remainsSolvent\n        returns (uint256)\n    {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address lpToken = _getPenpieLpToken(market);\n\n        amount = Math.min(IERC20(lpToken).balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        (\n            uint256 pendingPenpie,\n            address[] memory bonusTokenAddresses,\n            uint256[] memory pendingBonusRewards\n        ) = pendingRewards(market);\n\n        IPendleDepositHelper(DEPOSIT_HELPER).withdrawMarketWithClaim(\n            market,\n            amount,\n            true\n        );\n        _handleRewards(pendingPenpie, bonusTokenAddresses, pendingBonusRewards);\n\n        market.safeTransfer(msg.sender, amount);\n\n        _decreaseExposure(tokenManager, lpToken, amount);\n\n        emit PendleLpUnstaked(msg.sender, lpToken, amount, block.timestamp);\n\n        return amount;\n    }\n\n    function pendingRewards(\n        address market\n    ) public view returns (uint256, address[] memory, uint256[] memory) {\n        (\n            uint256 pendingPenpie,\n            address[] memory bonusTokenAddresses,\n            ,\n            uint256[] memory pendingBonusRewards\n        ) = IMasterPenpie(MASTER_PENPIE).allPendingTokens(market, address(this));\n        return (pendingPenpie, bonusTokenAddresses, pendingBonusRewards);\n    }\n\n    function claimRewards(address market) external onlyOwner {\n        (\n            uint256 pendingPenpie,\n            address[] memory bonusTokenAddresses,\n            uint256[] memory pendingBonusRewards\n        ) = pendingRewards(market);\n        address[] memory stakingTokens = new address[](1);\n        stakingTokens[0] = market;\n        IMasterPenpie(MASTER_PENPIE).multiclaim(stakingTokens);\n\n        _handleRewards(pendingPenpie, bonusTokenAddresses, pendingBonusRewards);\n    }\n\n    // INTERNAL FUNCTIONS\n    function _getPenpieLpToken(address market) internal pure returns (address) {\n        // ezETH\n        if (market == PENDLE_EZ_ETH_MARKET) {\n            return 0xecCDC2C2191d5148905229c5226375124934b63b;\n        }\n        if (market == PENDLE_EZ_ETH_26_09_24) {\n            return 0xB3f215aFD47Dd29f4B82D9b480BB86FeAF543e67;\n        }\n\n        // wstETH\n        if (market == PENDLE_WST_ETH_MARKET) {\n            return 0xdb0e1D1872202A81Eb0cb655137f4a937873E02f;\n        }\n        if (market == PENDLE_WSTETH_26_06_25) {\n            return 0x4d2Faa48Ef93Cc3c8A7Ec27F3Cb91cEB1a36F89B;\n        }\n\n        // eETH\n        if (market == PENDLE_E_ETH_MARKET) {\n            return 0x264f4138161aaE16b76dEc7D4eEb756f25Fa67Cd;\n        }\n        if (market == PENDLE_E_ETH_26_09_24) {\n            return 0xa7D760926F3098E9fb5A93018155578fCDad75C0;\n        }\n\n        // rsETH\n        if (market == PENDLE_RS_ETH_MARKET) {\n            return 0xe3B327c43b5002eb7280Eef52823698b6cDA06cF;\n        }\n        if (market == PENDLE_RS_ETH_26_09_24) {\n            return 0x9e411b97437Af296D6c4b482893c63Ffd8DfBE6D;\n        }\n\n        // wstETHSilo\n        if (market == PENDLE_WST_ETH_SILO_MARKET) {\n            return 0xCcCC7c80c9Be9fDf22e322A5fdbfD2ef6ac5D574;\n        }\n\n        revert(\"Invalid market address\");\n    }\n\n    function _handleRewards(\n        uint256 pendingPenpie,\n        address[] memory bonusTokenAddresses,\n        uint256[] memory pendingBonusRewards\n    ) internal {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address owner = DiamondStorageLib.contractOwner();\n\n        if (pendingPenpie > 0 && tokenManager.isTokenAssetActive(PNP)) {\n            _increaseExposure(tokenManager, PNP, pendingPenpie);\n        } else if (pendingPenpie > 0) {\n            PNP.safeTransfer(owner, pendingPenpie);\n        }\n\n        uint256 len = bonusTokenAddresses.length;\n        for (uint256 i; i != len; ++i) {\n            address bonusToken = bonusTokenAddresses[i];\n            uint256 pendingReward = pendingBonusRewards[i];\n            if (pendingReward == 0) {\n                continue;\n            }\n\n            if (tokenManager.isTokenAssetActive(bonusToken)) {\n                _increaseExposure(tokenManager, bonusToken, pendingReward);\n            } else {\n                bonusToken.safeTransfer(owner, pendingReward);\n            }\n        }\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n     * @dev emitted when user stakes an asset\n     * @param user the address executing staking\n     * @param asset the asset that was staked\n     * @param vault address of receipt token\n     * @param depositTokenAmount how much of deposit token was staked\n     * @param receiptTokenAmount how much of receipt token was received\n     * @param timestamp of staking\n     **/\n    event Staked(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositTokenAmount,\n        uint256 receiptTokenAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user unstakes an asset\n     * @param user the address executing unstaking\n     * @param asset the asset that was unstaked\n     * @param vault address of receipt token\n     * @param depositTokenAmount how much deposit token was received\n     * @param receiptTokenAmount how much receipt token was unstaked\n     * @param timestamp of unstaking\n     **/\n    event Unstaked(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositTokenAmount,\n        uint256 receiptTokenAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user stakes an asset\n     * @param user the address executing staking\n     * @param vault address of receipt token\n     * @param amount how much of deposit token was staked\n     * @param timestamp of staking\n     **/\n    event PendleLpStaked(\n        address indexed user,\n        address indexed vault,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user unstakes an asset\n     * @param user the address executing unstaking\n     * @param vault address of receipt token\n     * @param amount how much deposit token was received\n     * @param timestamp of unstaking\n     **/\n    event PendleLpUnstaked(\n        address indexed user,\n        address indexed vault,\n        uint256 amount,\n        uint256 timestamp\n    );\n}\n"
    },
    "contracts/facets/arbitrum/RemoveWstEthAssetFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2ff7031532d38b344def3a4b8a953f80f29d0b00;\npragma solidity 0.8.27;\n\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\ncontract RemoveWstEthAssetFacet  {\n    function RemoveWstEthAsset() external {\n        require(msg.sender == 0x5D80a1c0a5084163F1D2620c1B1F43209cd4dB12, \"Wrong msg.sender\");\n        DiamondStorageLib.removeOwnedAsset(\"wstETH\");\n    }\n}\n"
    },
    "contracts/facets/arbitrum/SolvencyFacetProdArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c2ccdf2b9a14009c964300273129b0bfaf0457b4;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\nimport \"../../Pool.sol\";\nimport \"../SolvencyFacetProd.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../interfaces/facets/avalanche/ITraderJoeV2Facet.sol\";\nimport \"../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\nimport {PriceHelper} from \"../../lib/joe-v2/PriceHelper.sol\";\nimport {Uint256x256Math} from \"../../lib/joe-v2/math/Uint256x256Math.sol\";\nimport {TickMath} from \"../../lib/uniswap-v3/TickMath.sol\";\nimport {FullMath} from \"../../lib/uniswap-v3/FullMath.sol\";\nimport \"../../interfaces/facets/avalanche/IYieldYak.sol\";\n\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../../interfaces/facets/avalanche/IUniswapV3Facet.sol\";\n\ncontract SolvencyFacetProdArbitrum is SolvencyFacetProd {\n    function getDataServiceId() public view virtual override returns (string memory) {\n        return \"redstone-arbitrum-prod\";\n    }\n\n    function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n        return 3;\n    }\n\n    function getAuthorisedSignerIndex(\n        address signerAddress\n    ) public view virtual override returns (uint8) {\n        if (signerAddress == 0x345Efd26098e173F811e3B9Af1B0e0a11872B38b) {\n            return 0;\n        } else if (signerAddress == 0xbD0c5ccd85D5831B10E3e49527B8Cd67e2EFAf39) {\n            return 1;\n        } else if (signerAddress == 0x2F3E8EC88C01593d10ca9461c807660fF2D8DB28) {\n            return 2;\n        } else if (signerAddress == 0xb7f154bB5491565D215F4EB1c3fe3e84960627aF) {\n            return 3;\n        } else if (signerAddress == 0xE6b0De8F4B31F137d3c59b5a0A71e66e7D504Ef9) {\n            return 4;\n        } else {\n            revert SignerNotAuthorised(signerAddress);\n        }\n    }\n\n    function fixVaultDecimals(address vault) internal view returns (uint256 multiplier){\n        if(vault == 0x8Bc6968b7A9Eed1DD0A259eFa85dc2325B923dd2 || vault == 0x4649c7c3316B27C4A3DB5f3B47f87C687776Eb8C){\n            IYieldYak vault = IYieldYak(vault);\n            IERC20Metadata vaultDepositToken = IERC20Metadata(vault.depositToken());\n            multiplier = 10 ** (vault.decimals() - vaultDepositToken.decimals());\n        } else {\n            multiplier = 1;\n        }\n\n    }\n\n    function _getTWVOwnedAssets(AssetPrice[] memory ownedAssetsPrices) internal virtual override view returns (uint256) {\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        uint256 weightedValueOfTokens = ownedAssetsPrices[0].price * (address(this).balance - msg.value) * tokenManager.debtCoverage(tokenManager.getAssetAddress(nativeTokenSymbol, true)) / (10 ** 26);\n\n        if (ownedAssetsPrices.length > 0) {\n\n            for (uint256 i = 0; i < ownedAssetsPrices.length; i++) {\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssetsPrices[i].asset, true));\n                weightedValueOfTokens = weightedValueOfTokens + (ownedAssetsPrices[i].price * token.balanceOf(address(this)) * tokenManager.debtCoverage(address(token)) * fixVaultDecimals(address(token)) / (10 ** token.decimals() * 1e8));\n            }\n        }\n        return weightedValueOfTokens;\n    }\n\n    function _getTotalAssetsValueBase(AssetPrice[] memory ownedAssetsPrices) public virtual override view returns (uint256) {\n        if (ownedAssetsPrices.length > 0) {\n            ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n            uint256 total = address(this).balance * ownedAssetsPrices[0].price / 10 ** 8;\n\n            for (uint256 i = 0; i < ownedAssetsPrices.length; i++) {\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssetsPrices[i].asset, true));\n                uint256 assetBalance = token.balanceOf(address(this)) * fixVaultDecimals(address(token));\n\n                total = total + (ownedAssetsPrices[i].price * 10 ** 10 * assetBalance / (10 ** token.decimals()));\n            }\n            return total;\n        } else {\n            return 0;\n        }\n    }\n}\n"
    },
    "contracts/facets/arbitrum/SushiSwapDEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 19d9982858f4feeff1ca98cbf31b07304a79ac7f;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2DEXFacet.sol\";\n\ncontract SushiSwapDEXFacet is UniswapV2DEXFacet {\n    function getProtocolID() pure internal override returns (bytes32) {\n        return \"SUSHI\";\n    }\n\n    /**\n      * Swaps one asset to another\n      * @dev This function uses the redstone-evm-connector\n      * @param _soldAsset asset to be sold\n      * @param _boughtAsset asset to be bought\n      * @param _exactSold exact amount of asset to be sold\n      * @param _minimumBought minimum amount of asset to be bought\n    **/\n    function swapSushiSwap(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) public noBorrowInTheSameBlock onlyOwner returns (uint256[] memory) {\n        return swapAssets(_soldAsset, _boughtAsset, _exactSold, _minimumBought);\n    }\n\n    function addLiquiditySushiSwap(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) public onlyOwner {\n        addLiquidity(_firstAsset, _secondAsset, amountADesired, amountBDesired, amountAMin, amountBMin);\n    }\n\n    //onlOwnerOrInsolvent inside UniswapDexFacet\n    function removeLiquiditySushiSwap(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) public {\n        removeLiquidity(_firstAsset, _secondAsset, liquidity, amountAMin, amountBMin);\n    }\n\n    /**\n     * Returns address of UniswapV2-like exchange\n     **/\n    function getExchangeIntermediaryContract() public override returns (address) {\n        return 0xfd5665022359586Af38836b88E52E4690a3a7B79;\n    }\n}\n"
    },
    "contracts/facets/arbitrum/SushiSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: b5c62dcabdd9dc6577cb12be92681b37cadb26c9;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../lib/SolvencyMethods.sol\";\nimport \"../../interfaces/facets/arbitrum/IMiniChef.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\n\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract SushiSwapFacet is\n    ReentrancyGuardKeccak,\n    SolvencyMethods,\n    OnlyOwnerOrInsolvent\n{\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    // MiniChefV2\n    address private constant MINICHEF =\n        0xF4d73326C13a4Fc5FD7A064217e12780e9Bd62c3;\n\n    // Sushi Token\n    address private constant SUSHI_TOKEN =\n        0xd4d42F0b6DEF4CE0383636770eF773390d85c61A;\n\n    // PUBLIC FUNCTIONS\n\n    /**\n     * Stakes USDT in Yield Yak protocol\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDT to be staked\n     **/\n    function sushiStakeDpxEthLp(\n        uint256 amount\n    ) public onlyOwner nonReentrant remainsSolvent {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: 0x0C1Cf6883efA1B496B01f654E247B9b419873054,\n                symbol: \"SUSHI_DPX_ETH_LP\",\n                identifier: \"SUSHI_DPX_ETH_LP_AUTO\",\n                balanceSelector: this.sushiDpxEthLpBalance.selector,\n                unstakeSelector: this.sushiUnstakeDpxEthLp.selector\n            });\n        _stakeToken(amount, position, 17);\n    }\n\n    /**\n     * Unstakes USDT from Yield Yak protocol\n     * @dev This function uses the redstone-evm-connector\n     * @param amount amount of USDT to be unstaked\n     **/\n    function sushiUnstakeDpxEthLp(\n        uint256 amount,\n        uint256 minAmount\n    ) public onlyOwnerOrInsolvent nonReentrant {\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: 0x0C1Cf6883efA1B496B01f654E247B9b419873054,\n                symbol: \"SUSHI_DPX_ETH_LP\",\n                identifier: \"SUSHI_DPX_ETH_LP_AUTO\",\n                balanceSelector: this.sushiDpxEthLpBalance.selector,\n                unstakeSelector: this.sushiUnstakeDpxEthLp.selector\n            });\n        _unstakeToken(amount, minAmount, position, 17);\n    }\n\n    function sushiDpxEthLpBalance() public view returns (uint256 _stakedBalance) {\n        return IMiniChef(MINICHEF).userInfo(17, address(this)).amount;\n    }\n\n    // ----- PRIVATE METHODS -----\n\n    /**\n     * Stakes {position.asset} token in the SushiSwap MiniChefV2\n     * @dev This function uses the redstone-evm-connector\n     * @param amount The amount of tokens to stake\n     * @param position IStakingPositions.StakedPosition staking details\n     * @param pid Pool ID\n     **/\n    function _stakeToken(\n        uint256 amount,\n        IStakingPositions.StakedPosition memory position,\n        uint256 pid\n    ) private recalculateAssetsExposure {\n        IMiniChef miniChef = IMiniChef(MINICHEF);\n        IERC20Metadata stakedToken = getERC20TokenInstance(position.symbol, false);\n        uint256 initialReceiptTokenBalance = miniChef\n            .userInfo(pid, address(this))\n            .amount;\n\n        amount = Math.min(stakedToken.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot stake 0 tokens\");\n\n        address(stakedToken).safeApprove(MINICHEF, 0);\n        address(stakedToken).safeApprove(MINICHEF, amount);\n\n        miniChef.deposit(pid, amount, address(this));\n\n        DiamondStorageLib.addStakedPosition(position);\n\n        if (stakedToken.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(position.symbol);\n        }\n\n        emit Staked(\n            msg.sender,\n            position.symbol,\n            MINICHEF,\n            amount,\n            miniChef.userInfo(pid, address(this)).amount - initialReceiptTokenBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Unstakes {position.asset} token from the SushiSwap MiniChefV2\n     * @dev This function uses the redstone-evm-connector\n     * @param amount The amount of tokens to unstake\n     * @param minAmount The minimum amount of tokens to unstake\n     * @param position IStakingPositions.StakedPosition staking details\n     * @param pid Pool ID\n     **/\n    function _unstakeToken(\n        uint256 amount,\n        uint256 minAmount,\n        IStakingPositions.StakedPosition memory position,\n        uint256 pid\n    ) private recalculateAssetsExposure returns (uint256 unstaked) {\n        IMiniChef miniChef = IMiniChef(MINICHEF);\n        IERC20Metadata unstakedToken = getERC20TokenInstance(\n            position.symbol,\n            false\n        );\n        uint256 initialReceiptTokenBalance = miniChef\n            .userInfo(pid, address(this))\n            .amount;\n\n        amount = Math.min(initialReceiptTokenBalance, amount);\n\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        uint256 balance = unstakedToken.balanceOf(address(this));\n\n        miniChef.withdraw(pid, amount, address(this));\n\n        uint256 newBalance = unstakedToken.balanceOf(address(this));\n\n        require(newBalance >= balance + minAmount, \"too little received\");\n\n        uint256 newReceiptTokenBalance = miniChef\n            .userInfo(pid, address(this))\n            .amount;\n\n        // Add/remove owned tokens\n        if (newReceiptTokenBalance == 0) {\n            DiamondStorageLib.removeStakedPosition(position.identifier);\n        }\n        DiamondStorageLib.addOwnedAsset(position.symbol, address(unstakedToken));\n\n        emit Unstaked(\n            msg.sender,\n            position.symbol,\n            MINICHEF,\n            newBalance - balance,\n            initialReceiptTokenBalance - newReceiptTokenBalance,\n            block.timestamp\n        );\n\n        _handleRewards(pid);\n\n        return newBalance - balance;\n    }\n\n    function _handleRewards(uint256 pid) internal {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        IMiniChef miniChef = IMiniChef(MINICHEF);\n        uint256 pendingSushi = miniChef.pendingSushi(pid, address(this));\n        IRewarder rewarder = miniChef.rewarder(pid);\n        address[] memory rewardTokens;\n        if (address(rewarder) != address(0)) {\n            (rewardTokens, ) = rewarder.pendingTokens(\n                pid,\n                address(this),\n                pendingSushi\n            );\n        }\n\n        miniChef.harvest(pid, address(this));\n\n        bytes32 rewardTokenSymbol = tokenManager.tokenAddressToSymbol(SUSHI_TOKEN);\n        if (\n            rewardTokenSymbol != \"\" &&\n            IERC20(SUSHI_TOKEN).balanceOf(address(this)) > 0\n        ) {\n            DiamondStorageLib.addOwnedAsset(rewardTokenSymbol, SUSHI_TOKEN);\n        }\n\n        uint256 rewardLength = rewardTokens.length;\n        for (uint256 i; i != rewardLength; ++i) {\n            address rewardToken = rewardTokens[i];\n            rewardTokenSymbol = tokenManager.tokenAddressToSymbol(rewardToken);\n            if (rewardTokenSymbol == \"\") {\n                emit UnsupportedRewardToken(msg.sender, rewardToken, block.timestamp);\n                continue;\n            }\n            if (IERC20(rewardToken).balanceOf(address(this)) > 0) {\n                DiamondStorageLib.addOwnedAsset(rewardTokenSymbol, rewardToken);\n            }\n        }\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    /**\n     * @dev emitted when user stakes an asset\n     * @param user the address executing staking\n     * @param asset the asset that was staked\n     * @param vault address of the vault token\n     * @param depositTokenAmount how much of deposit token was staked\n     * @param receiptTokenAmount how much of receipt token was received\n     * @param timestamp of staking\n     **/\n    event Staked(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositTokenAmount,\n        uint256 receiptTokenAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user unstakes an asset\n     * @param user the address executing unstaking\n     * @param vault address of the vault token\n     * @param asset the asset that was unstaked\n     * @param depositTokenAmount how much deposit token was received\n     * @param receiptTokenAmount how much receipt token was unstaked\n     * @param timestamp of unstaking\n     **/\n    event Unstaked(\n        address indexed user,\n        bytes32 indexed asset,\n        address indexed vault,\n        uint256 depositTokenAmount,\n        uint256 receiptTokenAmount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted when user collects rewards in tokens that are not supported\n     * @param user the address collecting rewards\n     * @param asset reward token that was collected\n     * @param timestamp of collecting rewards\n     **/\n    event UnsupportedRewardToken(\n        address indexed user,\n        address indexed asset,\n        uint256 timestamp\n    );\n}\n"
    },
    "contracts/facets/arbitrum/TraderJoeV2ArbitrumFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../TraderJoeV2Facet.sol\";\n\ncontract TraderJoeV2ArbitrumFacet is TraderJoeV2Facet {\n    function maxBinsPerPrimeAccount() public pure override returns (uint256) {\n        return 300;\n    }\n\n    function getWhitelistedTraderJoeV2Pairs() internal pure override returns (ILBPair[] memory pools) {\n        pools = new ILBPair[](19);\n        // TJLB_DAI_USDCe\n        pools[0] = ILBPair(0x500173F418137090dad96421811147b63b448A0f);\n        // TJLB_ETH_USDT\n        pools[1] = ILBPair(0xd387c40a72703B38A5181573724bcaF2Ce6038a5);\n        // TJLB_ETH_USDCe\n        pools[2] = ILBPair(0x94d53BE52706a155d27440C4a2434BEa772a6f7C);\n        // TJLB_ARB_ETH\n        pools[3] = ILBPair(0x0Be4aC7dA6cd4bAD60d96FbC6d091e1098aFA358);\n        // TJLB_BTC_ETH\n        pools[4] = ILBPair(0xcfA09B20c85933B197e8901226ad0D6dACa7f114);\n        // TJLB_GMX_ETH\n        pools[5] = ILBPair(0x60563686ca7b668e4a2d7D31448e5F10456ecaF8);\n        // TJLB_WOO_ETH\n        pools[6] = ILBPair(0xB87495219C432fc85161e4283DfF131692A528BD);\n        // TJLB_JOE_ETH\n        pools[7] = ILBPair(0x4b9bfeD1dD4E6780454b2B02213788f31FfBA74a);\n        // TJLB_USDT_USDCe\n        pools[8] = ILBPair(0x0242DD3b2e792CdBD399cc6195951bC202Aee97B);\n        // TJLB_ETH_USDC\n        pools[9] = ILBPair(0x69f1216cB2905bf0852f74624D5Fa7b5FC4dA710);\n        // TJLB_GRAIL_ETH\n        pools[10] = ILBPair(0x461761f2848EC6B9Fb3D3fb031e112c7d5b89563);\n        // TJLB_MAGIC_ETH\n        pools[11] = ILBPair(0xE847C55a3148580E864EC31E7273bc4eC25089c1);\n        // TJLB_ARB_ETH_v2.2\n        pools[12] = ILBPair(0xC09F4ad33a164e29DF3c94719ffD5F7B5B057781);\n        // TJLB_ETH_USDC_v2.2\n        pools[13] = ILBPair(0xb7236B927e03542AC3bE0A054F2bEa8868AF9508);\n        // TJLB_ETH_USDT_v2.2\n        pools[14] = ILBPair(0x055f2cF6da90F14598D35C1184ED535C908dE737);\n\n        // TJLB_wstETH_ETH_v2.2\n        pools[15] = ILBPair(0x71bc33F539f83b99674D71AcFeb2ce0373376512);\n        // TJLB_ezETH_ETH_v2.2\n        pools[16] = ILBPair(0x8C0635aD0AfD7aa9444AF07Da6C104DD79b58D82);\n        // TJLB_weETH_ETH_v2.2\n        pools[17] = ILBPair(0x2088eB5E23F24458e241430eF155d4EC05BBc9e8);\n\n        // TJLB_JOE_WETH_v2.2\n        pools[18] = ILBPair(0x2088eB5E23F24458e241430eF155d4EC05BBc9e8);\n    }\n}\n"
    },
    "contracts/facets/arbitrum/YieldYakFacetArbi.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 19d9982858f4feeff1ca98cbf31b07304a79ac7f;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../lib/SolvencyMethods.sol\";\nimport \"../../interfaces/facets/avalanche/IYieldYak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\n\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\n// TODO: Check STATUS (tokenManager) of Vault tokens before allowing to stake\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract YieldYakFacetArbi is ReentrancyGuardKeccak, SolvencyMethods, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    // Staking Vaults tokens\n    address private constant YY_WOMBEX_USDT = 0x8Bc6968b7A9Eed1DD0A259eFa85dc2325B923dd2;\n    address private constant YY_WOMBEX_USDCe = 0x4649c7c3316B27C4A3DB5f3B47f87C687776Eb8C;\n    address private constant YY_WOMBEX_GLP = 0x28f37fa106AA2159c91C769f7AE415952D28b6ac;\n    address private constant YY_WOMBEX_DAI = 0x1817fE376740b53CAe73224B7F0a57F23DD4C9b5;\n\n    // Tokens\n    address private constant USDT_TOKEN = 0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9;\n    address private constant USDCe_TOKEN = 0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8;\n    address private constant GLP_TOKEN = 0x5402B5F40310bDED796c7D0F3FF6683f5C0cFfdf;\n    address private constant DAI_TOKEN = 0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1;\n\n    // ----- STAKE -----\n\n    /**\n       * Stakes USDT in Yield Yak protocol\n       * @dev This function uses the redstone-evm-connector\n       * @param amount amount of USDT to be staked\n    **/\n    function stakeUSDTYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n            tokenAddress: USDT_TOKEN,\n            vaultAddress: YY_WOMBEX_USDT,\n            tokenSymbol: \"USDT\",\n            vaultTokenSymbol: \"YY_WOMBEX_USDT\",\n            amount: amount\n        }));\n    }\n\n    /**\n       * Stakes USDC.e in Yield Yak protocol\n       * @dev This function uses the redstone-evm-connector\n       * @param amount amount of USDC.e to be staked\n    **/\n    function stakeUSDCeYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n            tokenAddress: USDCe_TOKEN,\n            vaultAddress: YY_WOMBEX_USDCe,\n            tokenSymbol: \"USDC.e\",\n            vaultTokenSymbol: \"YY_WOMBEX_USDC.e\",\n            amount: amount\n        }));\n    }\n\n    /**\n       * Stakes GLP in Yield Yak protocol\n       * @dev This function uses the redstone-evm-connector\n       * @param amount amount of GLP to be staked\n    **/\n    function stakeGLPYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: GLP_TOKEN,\n        vaultAddress: YY_WOMBEX_GLP,\n        tokenSymbol: \"GLP\",\n        vaultTokenSymbol: \"YY_WOMBEX_GLP\",\n        amount: amount\n        }));\n    }\n\n    /**\n       * Stakes DAI in Yield Yak protocol\n       * @dev This function uses the redstone-evm-connector\n       * @param amount amount of DAI to be staked\n    **/\n    function stakeDAIYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n            tokenAddress: DAI_TOKEN,\n            vaultAddress: YY_WOMBEX_DAI,\n            tokenSymbol: \"DAI\",\n            vaultTokenSymbol: \"YY_WOMBEX_DAI\",\n            amount: amount\n        }));\n    }\n\n    // ----- UNSTAKE -----\n\n\n    /**\n    * Unstakes USDT from Yield Yak protocol\n    * @dev This function uses the redstone-evm-connector\n        * @param amount amount of USDT to be unstaked\n    **/\n    function unstakeUSDTYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: USDT_TOKEN,\n        vaultAddress: YY_WOMBEX_USDT,\n        tokenSymbol: \"USDT\",\n        vaultTokenSymbol: \"YY_WOMBEX_USDT\",\n        amount: amount\n        }));\n    }\n\n    /**\n    * Unstakes USDC.e from Yield Yak protocol\n    * @dev This function uses the redstone-evm-connector\n        * @param amount amount of USDC.e to be unstaked\n    **/\n    function unstakeUSDCeYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n            tokenAddress: USDCe_TOKEN,\n            vaultAddress: YY_WOMBEX_USDCe,\n            tokenSymbol: \"USDC.e\",\n            vaultTokenSymbol: \"YY_WOMBEX_USDC.e\",\n            amount: amount\n        }));\n    }\n\n    /**\n    * Unstakes GLP from Yield Yak protocol\n    * @dev This function uses the redstone-evm-connector\n        * @param amount amount of GLP to be unstaked\n    **/\n    function unstakeGLPYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: GLP_TOKEN,\n        vaultAddress: YY_WOMBEX_GLP,\n        tokenSymbol: \"GLP\",\n        vaultTokenSymbol: \"YY_WOMBEX_GLP\",\n        amount: amount\n        }));\n    }\n\n    /**\n    * Unstakes DAI from Yield Yak protocol\n    * @dev This function uses the redstone-evm-connector\n        * @param amount amount of DAI to be unstaked\n    **/\n    function unstakeDAIYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n            tokenAddress: DAI_TOKEN,\n            vaultAddress: YY_WOMBEX_DAI,\n            tokenSymbol: \"DAI\",\n            vaultTokenSymbol: \"YY_WOMBEX_DAI\",\n            amount: amount\n        }));\n    }\n\n    // ----- PRIVATE METHODS -----\n\n    /**\n      * Stakes {stakingDetails.tokenAddress} token in the YieldYak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param stakingDetails IYieldYak.YYStakingDetails staking details\n    **/\n    function _stakeTokenYY(IYieldYak.YYStakingDetails memory stakingDetails) private {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        IERC20Metadata yrtToken = IERC20Metadata(stakingDetails.vaultAddress);\n        uint256 initialYRTBalance = yrtToken.balanceOf(address(this));\n\n        stakingDetails.amount = Math.min(IERC20Metadata(stakingDetails.tokenAddress).balanceOf(address(this)), stakingDetails.amount);\n        require(stakingDetails.amount > 0, \"Cannot stake 0 tokens\");\n        // _ACTIVE = 2\n        require(tokenManager.tokenToStatus(stakingDetails.tokenAddress) == 2, \"Token not supported\");\n        require(tokenManager.tokenToStatus(stakingDetails.vaultAddress) == 2, \"Vault token not supported\");\n\n        stakingDetails.tokenAddress.safeApprove(stakingDetails.vaultAddress, 0);\n        stakingDetails.tokenAddress.safeApprove(stakingDetails.vaultAddress, stakingDetails.amount);\n        IYieldYak(stakingDetails.vaultAddress).deposit(stakingDetails.amount);\n\n        uint256 yrtTokenReceived = yrtToken.balanceOf(address(this)) - initialYRTBalance;\n\n        _decreaseExposure(tokenManager, stakingDetails.tokenAddress, stakingDetails.amount);\n        _increaseExposure(tokenManager, stakingDetails.vaultAddress, yrtTokenReceived);\n\n        emit Staked(\n            msg.sender,\n            stakingDetails.tokenSymbol,\n            stakingDetails.vaultAddress,\n            stakingDetails.amount,\n            yrtTokenReceived,\n            block.timestamp);\n    }\n\n    /**\n      * Unstakes {stakingDetails.tokenAddress} token in the YieldYak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param stakingDetails IYieldYak.YYStakingDetails staking details\n    **/\n    function _unstakeTokenYY(IYieldYak.YYStakingDetails memory stakingDetails) private {\n        IYieldYak vaultContract = IYieldYak(stakingDetails.vaultAddress);\n        IERC20Metadata depositToken = IERC20Metadata(stakingDetails.tokenAddress);\n        uint256 initialDepositTokenBalance = depositToken.balanceOf(address(this));\n        stakingDetails.amount = Math.min(vaultContract.balanceOf(address(this)), stakingDetails.amount);\n\n        vaultContract.withdraw(stakingDetails.amount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        uint256 depositTokenReceived = depositToken.balanceOf(address(this)) - initialDepositTokenBalance;\n\n        _increaseExposure(tokenManager, stakingDetails.tokenAddress, depositTokenReceived);\n        _decreaseExposure(tokenManager, stakingDetails.vaultAddress, stakingDetails.amount);\n\n        emit Unstaked(\n            msg.sender,\n            stakingDetails.tokenSymbol,\n            stakingDetails.vaultAddress,\n            depositTokenReceived,\n            stakingDetails.amount,\n            block.timestamp);\n    }\n\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of the vault token\n        * @param depositTokenAmount how much of deposit token was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param vault address of the vault token\n        * @param asset the asset that was unstaked\n        * @param depositTokenAmount how much deposit token was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n}"
    },
    "contracts/facets/arbitrum/YieldYakSwapArbitrumFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 19d9982858f4feeff1ca98cbf31b07304a79ac7f;\npragma solidity 0.8.27;\n\nimport \"../avalanche/YieldYakSwapFacet.sol\";\n\ncontract YieldYakSwapArbitrumFacet is YieldYakSwapFacet {\n    function YY_ROUTER() internal override pure returns (address) {\n        return 0xb32C79a25291265eF240Eb32E9faBbc6DcEE3cE3;\n    }\n}\n"
    },
    "contracts/facets/AssetsExposureController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 80b132047eed3a89d09cda7bcb108a4826c6ed69;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/ITokenManager.sol\";\nimport \"../interfaces/IStakingPositions.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract AssetsExposureController {\n    function resetPrimeAccountAssetsExposure() external {\n        bytes32[] memory ownedAssets = DeploymentConstants.getAllOwnedAssets();\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        for(uint i=0; i<ownedAssets.length; i++){\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssets[i], true));\n            tokenManager.decreaseProtocolExposure(ownedAssets[i], token.balanceOf(address(this)) * 1e18 / 10**token.decimals());\n        }\n        for(uint i=0; i<positions.length; i++){\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\n            if (success) {\n                uint256 balance = abi.decode(result, (uint256));\n                uint256 decimals = IERC20Metadata(tokenManager.getAssetAddress(positions[i].symbol, true)).decimals();\n                tokenManager.decreaseProtocolExposure(positions[i].identifier, balance * 1e18 / 10**decimals);\n            }\n        }\n    }\n\n    function setPrimeAccountAssetsExposure() external {\n        bytes32[] memory ownedAssets = DeploymentConstants.getAllOwnedAssets();\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        for(uint i=0; i<ownedAssets.length; i++){\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssets[i], true));\n            tokenManager.increaseProtocolExposure(ownedAssets[i], token.balanceOf(address(this)) * 1e18 / 10**token.decimals());\n        }\n        for(uint i=0; i<positions.length; i++){\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\n            if (success) {\n                uint256 balance = abi.decode(result, (uint256));\n                uint256 decimals = IERC20Metadata(tokenManager.getAssetAddress(positions[i].symbol, true)).decimals();\n                tokenManager.increaseProtocolExposure(positions[i].identifier, balance * 1e18 / 10**decimals);\n            }\n        }\n    }\n}\n"
    },
    "contracts/facets/AssetsOperationsFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9be978eee452f5d0645f568d47e3ca96b1d7c8ef;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport \"../OnlyOwnerOrInsolvent.sol\";\nimport \"../interfaces/ITokenManager.sol\";\nimport \"../interfaces/IVPrimeController.sol\";\nimport \"./SmartLoanLiquidationFacet.sol\";\nimport \"../interfaces/facets/IYieldYakRouter.sol\";\n\n//this path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract AssetsOperationsFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    address private constant PARA_TRANSFER_PROXY =\n        0x216B4B4Ba9F3e719726886d34a177484278Bfcae;\n    address private constant PARA_ROUTER =\n        0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57;\n\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\n\n    /**\n    * Removes an asset from the ownedAssets array\n    * @param _asset asset to be removed\n    * @param _address address of the asset\n    **/\n    function removeUnsupportedOwnedAsset(bytes32 _asset, address _address) external onlyWhitelistedLiquidators nonReentrant {\n    ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n    // Check if the asset exists in the TokenManager\n    require(tokenManager.tokenToStatus(_address) == 0, \"Asset is still supported\");\n    require(tokenManager.tokenAddressToSymbol(_address) == bytes32(0), \"Asset address to symbol not empty\");\n    require(tokenManager.debtCoverage(_address) == 0, \"Asset still has debt coverage\");\n    require(tokenManager.identifierToExposureGroup(_asset) == bytes32(0), \"Asset still has exposure group\");\n\n    bytes32[] memory allAssets = tokenManager.getAllTokenAssets();\n    // Loop through all assets and check if the asset exists\n    for (uint i = 0; i < allAssets.length; i++) {\n        require(allAssets[i] != _asset, \"Asset exists in TokenManager\");\n    }\n\n\n    // Remove the asset from the ownedAssets array\n    DiamondStorageLib.removeOwnedAsset(_asset);\n}\n\n    /**\n    * Funds the loan with a specified amount of a defined token\n    * @dev Requires approval for ERC20 token on frontend side\n    * @param _fundedAsset asset to be funded\n    * @param _amount to be funded\n    **/\n    function fund(bytes32 _fundedAsset, uint256 _amount) public virtual nonReentrant {\n        IERC20Metadata token = getERC20TokenInstance(_fundedAsset, false);\n        _amount = Math.min(_amount, token.balanceOf(msg.sender));\n\n        address(token).safeTransferFrom(msg.sender, address(this), _amount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(token), _amount);\n\n        emit Funded(msg.sender, _fundedAsset, _amount, block.timestamp);\n    }\n\n    function addOwnedAsset(bytes32 _asset, address _address) external onlyWhitelistedLiquidators nonReentrant{\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        require(tokenManager.isTokenAssetActive(_address), \"Asset not supported\");\n\n        DiamondStorageLib.addOwnedAsset(_asset, _address);\n    }\n\n    function _processRepay(ITokenManager tokenManager, Pool fromAssetPool, address fromToken, uint256 repayAmount, uint256 receivedRepayTokenAmount) internal {\n        fromToken.safeApprove(address(fromAssetPool), 0);\n        fromToken.safeApprove(address(fromAssetPool), repayAmount);\n        fromAssetPool.repay(repayAmount);\n\n        if(receivedRepayTokenAmount > repayAmount) {\n            _increaseExposure(tokenManager, fromToken, receivedRepayTokenAmount - repayAmount);\n        }  else {\n            _decreaseExposure(tokenManager, fromToken, repayAmount - receivedRepayTokenAmount);\n        }\n    }\n\n    /**\n    * Funds the loan with a specified amount of a GLP\n    * @dev Requires approval for stakedGLP token on frontend side\n    * @param _amount to be funded\n    **/\n    function fundGLP(uint256 _amount) public virtual nonReentrant {\n        IERC20Metadata stakedGlpToken = IERC20Metadata(0xaE64d55a6f09E4263421737397D1fdFA71896a69);\n        _amount = Math.min(_amount, stakedGlpToken.balanceOf(msg.sender));\n        address(stakedGlpToken).safeTransferFrom(msg.sender, address(this), _amount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(stakedGlpToken), _amount);\n\n        emit Funded(msg.sender, \"GLP\", _amount, block.timestamp);\n    }\n\n    /**\n    * Withdraws an amount of a defined asset from the loan\n    * This method could be used to cash out profits from investments\n    * The loan needs to remain solvent after the withdrawal\n    * @dev This function uses the redstone-evm-connector\n    * @param _withdrawnAsset asset to be withdrawn\n    * @param _amount to be withdrawn\n    **/\n    function withdraw(bytes32 _withdrawnAsset, uint256 _amount) public virtual onlyOwner nonReentrant canRepayDebtFully remainsSolvent {\n        IERC20Metadata token = getERC20TokenInstance(_withdrawnAsset, true);\n        _amount = Math.min(_amount, token.balanceOf(address(this)));\n\n        address(token).safeTransfer(msg.sender, _amount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        _decreaseExposure(tokenManager, address(token), _amount);\n        emit Withdrawn(msg.sender, _withdrawnAsset, _amount, block.timestamp);\n    }\n\n    /**\n        * Withdraws specified amount of a GLP\n        * @param _amount to be withdrawn\n    **/\n    function withdrawGLP(uint256 _amount) public virtual onlyOwner nonReentrant canRepayDebtFully remainsSolvent{\n        IERC20Metadata token = getERC20TokenInstance(\"GLP\", true);\n        IERC20Metadata stakedGlpToken = IERC20Metadata(0xaE64d55a6f09E4263421737397D1fdFA71896a69);\n        _amount = Math.min(token.balanceOf(address(this)), _amount);\n        \n        address(stakedGlpToken).safeTransfer(msg.sender, _amount);\n        \n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        _decreaseExposure(tokenManager, address(stakedGlpToken), _amount);\n        emit Withdrawn(msg.sender, \"GLP\", _amount, block.timestamp);\n    }\n\n    /**\n    * Borrows funds from the pool\n    * @dev This function uses the redstone-evm-connector\n    * @param _asset to be borrowed\n    * @param _amount of funds to borrow\n    **/\n    function borrow(bytes32 _asset, uint256 _amount) external onlyOwner remainsSolvent nonReentrant {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        ds._lastBorrowTimestamp = block.timestamp;\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        Pool pool = Pool(tokenManager.getPoolAddress(_asset));\n        pool.borrow(_amount);\n\n        IERC20Metadata token = getERC20TokenInstance(_asset, false);\n        _increaseExposure(tokenManager, address(token), _amount);\n\n        notifyVPrimeController(DiamondStorageLib.contractOwner(), tokenManager);\n        emit Borrowed(msg.sender, _asset, _amount, block.timestamp);\n    }\n\n    /**\n     * Repays funds to the pool\n     * @dev This function uses the redstone-evm-connector\n     * @param _asset to be repaid\n     * @param _amount of funds to repay\n     **/\n    function repay(bytes32 _asset, uint256 _amount) public payable nonReentrant {\n        IERC20Metadata token = getERC20TokenInstance(_asset, true);\n\n        if (_isSolvent()) {\n            DiamondStorageLib.enforceIsContractOwner();\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        Pool pool = Pool(tokenManager.getPoolAddress(_asset));\n\n        _amount = Math.min(_amount, token.balanceOf(address(this)));\n        _amount = Math.min(_amount, pool.getBorrowed(address(this)));\n\n        address(token).safeApprove(address(pool), 0);\n        address(token).safeApprove(address(pool), _amount);\n\n        pool.repay(_amount);\n\n        _decreaseExposure(tokenManager, address(token), _amount);\n\n        emit Repaid(msg.sender, _asset, _amount, block.timestamp);\n\n        notifyVPrimeController(DiamondStorageLib.contractOwner(), tokenManager);\n    }\n\n    function withdrawUnsupportedToken(address token) external nonReentrant onlyOwner remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        // _NOT_SUPPORTED = 0\n        require(tokenManager.tokenToStatus(token) == 0, \"token supported\");\n        require(tokenManager.debtCoverage(token) == 0, \"token debt coverage != 0\");\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        require(balance > 0, \"nothing to withdraw\");\n        token.safeTransfer(msg.sender, balance);\n\n        emit WithdrawUnsupportedToken(msg.sender, token, balance, block.timestamp);\n    }\n\n    // TODO: Separate manager for unfreezing - not liquidators\n    function unfreezeAccount() external onlyWhitelistedLiquidators {\n        DiamondStorageLib.unfreezeAccount(msg.sender);\n    }\n\n    modifier onlyWhitelistedLiquidators() {\n        // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\n        require(SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\n        _;\n    }\n\n    /**\n     * Swap existing debt to another debt\n    * @dev This function uses the redstone-evm-connector\n    * @dev _repayAmount and __borrowAmount can be used to control the slippage.\n     * @param _fromAsset existing debt asset\n     * @param _toAsset new debt asset\n     * @param _repayAmount debt repay amount\n     * @param _borrowAmount debt borrow amount\n     * @param _path yield yak swap path\n     * @param _adapters yield yak swap adapters\n     */\n    function swapDebt(bytes32 _fromAsset, bytes32 _toAsset, uint256 _repayAmount, uint256 _borrowAmount, address[] calldata _path, address[] calldata _adapters) external onlyOwner remainsSolvent nonReentrant {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        Pool fromAssetPool = Pool(tokenManager.getPoolAddress(_fromAsset));\n        _repayAmount = Math.min(_repayAmount, fromAssetPool.getBorrowed(address(this)));\n\n        IERC20Metadata toToken = getERC20TokenInstance(_toAsset, false);\n        IERC20Metadata fromToken = getERC20TokenInstance(_fromAsset, false);\n\n        require(address(toToken) == _path[0], \"Invalid token input\");\n        require(address(fromToken) == _path[_path.length - 1], \"Invalid token input\");\n\n        Pool(tokenManager.getPoolAddress(_toAsset)).borrow(_borrowAmount);\n        uint256 initialRepayTokenAmount = fromToken.balanceOf(address(this));\n\n        {\n            // swap toAsset to fromAsset\n            address(toToken).safeApprove(YY_ROUTER(), 0);\n            address(toToken).safeApprove(YY_ROUTER(), _borrowAmount);\n\n            IYieldYakRouter router = IYieldYakRouter(YY_ROUTER());\n\n            IYieldYakRouter.Trade memory trade = IYieldYakRouter.Trade({\n                amountIn: _borrowAmount,\n                amountOut: _repayAmount,\n                path: _path,\n                adapters: _adapters\n            });\n        \n            router.swapNoSplit(trade, address(this), 0);\n        }\n\n        _repayAmount = Math.min(_repayAmount, fromToken.balanceOf(address(this)));\n        \n        _processRepay(tokenManager, fromAssetPool, address(fromToken), _repayAmount, fromToken.balanceOf(address(this)) - initialRepayTokenAmount);\n\n        emit DebtSwap(msg.sender, address(fromToken), address(toToken), _repayAmount, _borrowAmount, block.timestamp);\n    }\n\n    function swapDebtParaSwap(bytes32 _fromAsset, bytes32 _toAsset, uint256 _repayAmount, uint256 _borrowAmount, bytes4 selector, bytes memory data) external onlyOwnerOrInsolvent remainsSolvent nonReentrant {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        Pool fromAssetPool = Pool(tokenManager.getPoolAddress(_fromAsset));\n        _repayAmount = Math.min(_repayAmount, fromAssetPool.getBorrowed(address(this)));\n\n        IERC20Metadata toToken = getERC20TokenInstance(_toAsset, false);\n        IERC20Metadata fromToken = getERC20TokenInstance(_fromAsset, false);\n\n        Pool toAssetPool = Pool(tokenManager.getPoolAddress(_toAsset));\n        toAssetPool.borrow(_borrowAmount);\n\n        uint256 initialRepayTokenAmount = fromToken.balanceOf(address(this));\n\n        {\n            \n            // swap toAsset to fromAsset\n            address(toToken).safeApprove(PARA_TRANSFER_PROXY, 0);\n            address(toToken).safeApprove(PARA_TRANSFER_PROXY, _borrowAmount);\n\n            (bool success, ) = PARA_ROUTER.call((abi.encodePacked(selector, data)));\n            require(success, \"Swap failed\");\n\n        }\n        _repayAmount = Math.min(fromToken.balanceOf(address(this)), _repayAmount);\n\n        _processRepay(tokenManager, fromAssetPool, address(fromToken), _repayAmount, fromToken.balanceOf(address(this)) - initialRepayTokenAmount);\n\n        emit DebtSwap(msg.sender, address(fromToken), address(toToken), _repayAmount, _borrowAmount, block.timestamp);\n    }\n\n    function containsOracleCalldata() public view returns (bool) {\n        // Checking if the calldata ends with the RedStone marker\n        bool hasValidRedstoneMarker;\n        assembly {\n            let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n            hasValidRedstoneMarker := eq(\n                REDSTONE_MARKER_MASK,\n                and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n            )\n        }\n        return hasValidRedstoneMarker;\n    }\n\n    function getVPrimeControllerAddress(ITokenManager tokenManager) internal view returns (address) {\n        if(address(tokenManager) != address(0)) {\n            return tokenManager.getVPrimeControllerAddress();\n        }\n        return address(0);\n    }\n\n    function notifyVPrimeController(address account, ITokenManager tokenManager) internal {\n        address vPrimeControllerAddress = getVPrimeControllerAddress(tokenManager);\n        if(vPrimeControllerAddress != address(0)){\n            if(containsOracleCalldata()) {\n                proxyCalldata(\n                    vPrimeControllerAddress,\n                    abi.encodeWithSignature\n                    (\"updateVPrimeSnapshot(address)\", account),\n                    false\n                );\n            } else {\n                IVPrimeController(vPrimeControllerAddress).setUserNeedsUpdate(account);\n            }\n        }\n    }\n\n    /* ======= VIEW FUNCTIONS ======*/\n\n    /**\n    * Returns a current balance of the asset held by the smart loan\n    * @param _asset the code of an asset\n    **/\n    function getBalance(bytes32 _asset) internal view returns (uint256) {\n        IERC20 token = IERC20(DeploymentConstants.getTokenManager().getAssetAddress(_asset, true));\n        return token.balanceOf(address(this));\n    }\n\n    function YY_ROUTER() internal virtual pure returns (address) {\n        return 0xC4729E56b831d74bBc18797e0e17A295fA77488c;\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after a debt swap\n     * @param user the address which performed the debt swap\n     * @param fromToken token that was repaid\n     * @param toToken token that was borrowed\n     * @param repayAmount the amount of fromToken that was repaid\n     * @param borrowAmount the amount of toToken that was borrowed\n     * @param timestamp time of debt swap\n     **/\n    event DebtSwap(address indexed user, address indexed fromToken, address indexed toToken, uint256 repayAmount, uint256 borrowAmount, uint256 timestamp);\n\n    /**\n     * @dev emitted after a loan is funded\n     * @param user the address which funded the loan\n     * @param asset funded by a user\n     * @param amount the amount of funds\n     * @param timestamp time of funding\n     **/\n    event Funded(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted after the funds are withdrawn from the loan\n     * @param user the address which withdraws funds from the loan\n     * @param asset withdrawn by a user\n     * @param amount of funds withdrawn\n     * @param timestamp of the withdrawal\n     **/\n    event Withdrawn(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are borrowed from the pool\n     * @param user the address of borrower\n     * @param asset borrowed by an= user\n     * @param amount of the borrowed funds\n     * @param timestamp time of the borrowing\n     **/\n    event Borrowed(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are repaid to the pool\n     * @param user the address initiating repayment\n     * @param asset asset repaid by a user\n     * @param amount of repaid funds\n     * @param timestamp of the repayment\n     **/\n    event Repaid(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when unsupported token is withdrawn\n     * @param user the address withdrawing unsupported token\n     * @param token the unsupported token address\n     * @param amount of unsupported token withdrawn\n     * @param timestamp of the withdraw\n     **/\n    event WithdrawUnsupportedToken(address indexed user, address indexed token, uint256 amount, uint256 timestamp);\n}"
    },
    "contracts/facets/avalanche/AssetsOperationsAvalancheFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 824dcb816242972f9370e35039cf65c6d12cd6f0;\npragma solidity 0.8.27;\n\nimport \"../AssetsOperationsFacet.sol\";\nimport \"../SmartLoanLiquidationFacet.sol\";\n\ncontract AssetsOperationsAvalancheFacet is AssetsOperationsFacet {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    function YY_ROUTER() internal override pure returns (address) {\n        return 0xC4729E56b831d74bBc18797e0e17A295fA77488c;\n    }\n\n    /**\n    * Funds the loan with a specified amount of a GLP\n    * @dev Requires approval for stakedGLP token on frontend side\n    * @param _amount to be funded\n    **/\n    function fundGLP(uint256 _amount) public override nonReentrant {\n        IERC20Metadata stakedGlpToken = IERC20Metadata(0xaE64d55a6f09E4263421737397D1fdFA71896a69);\n        _amount = Math.min(_amount, stakedGlpToken.balanceOf(msg.sender));\n        address(stakedGlpToken).safeTransferFrom(msg.sender, address(this), _amount);\n        if (stakedGlpToken.balanceOf(address(this)) > 0) {\n            DiamondStorageLib.addOwnedAsset(\"GLP\", address(stakedGlpToken));\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        tokenManager.increaseProtocolExposure(\"GLP\", _amount);\n\n        emit Funded(msg.sender, \"GLP\", _amount, block.timestamp);\n    }\n\n    /**\n        * Withdraws specified amount of a GLP\n        * @param _amount to be withdrawn\n    **/\n    function withdrawGLP(uint256 _amount) public override onlyOwner nonReentrant canRepayDebtFully remainsSolvent{\n        IERC20Metadata token = getERC20TokenInstance(\"GLP\", true);\n        IERC20Metadata stakedGlpToken = IERC20Metadata(0xaE64d55a6f09E4263421737397D1fdFA71896a69);\n        _amount = Math.min(token.balanceOf(address(this)), _amount);\n\n        address(stakedGlpToken).safeTransfer(msg.sender, _amount);\n        if (token.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(\"GLP\");\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        tokenManager.decreaseProtocolExposure(\"GLP\", _amount);\n\n        emit Withdrawn(msg.sender, \"GLP\", _amount, block.timestamp);\n    }\n}\n"
    },
    "contracts/facets/avalanche/BalancerV2Facet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 6f7f4cd9481c319d118ca12f8d2a3f8688dcf371;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../interfaces/balancer-v2/IBalancerV2Vault.sol\";\nimport \"../../interfaces/balancer-v2/IBalancerV2Gauge.sol\";\nimport \"../../interfaces/balancer-v2/IBalancerPseudoMinter.sol\";\nimport \"../../interfaces/facets/avalanche/IBalancerV2Facet.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract BalancerV2Facet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent, IBalancerV2Facet {\n    using TransferHelper for address;\n\n    // Used to deposit/withdraw tokens\n    // https://docs.balancer.fi/concepts/vault/\n    address private constant MASTER_VAULT_ADDRESS = 0xBA12222222228d8Ba445958a75a0704d566BF2C8;\n\n    /**\n     * Joins a pool and stakes in a gauge\n     * @param request stake request\n     **/\n    function joinPoolAndStakeBalancerV2(IBalancerV2Facet.StakeRequest memory request) external nonReentrant onlyOwner remainsSolvent {\n        uint256 stakedTokensLength = request.stakedTokens.length;\n\n        if (stakedTokensLength != request.stakedAmounts.length) revert ArgArrayLengthsDiffer();\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        IVault vault = IVault(MASTER_VAULT_ADDRESS);\n\n        (address pool,) = vault.getPool(request.poolId);\n        if (pool == address(0)) revert ZeroAddressPool();\n\n        //poolToGauge checks as well if the pool is whitelisted\n        IBalancerV2Gauge gauge = IBalancerV2Gauge(poolToGauge(pool));\n\n        for (uint256 i; i < stakedTokensLength; i++) {\n            if (request.stakedAmounts[i] > 0 && !tokenManager.isTokenAssetActive(request.stakedTokens[i])) revert DepositingInactiveToken();\n            if (request.stakedTokens[i] == address(gauge)) revert DepositingWrongToken();\n        }\n\n        uint256[] memory initialDepositTokenBalances = new uint256[](stakedTokensLength);\n\n        {\n            bool allZero = true;\n\n            for (uint256 i; i < stakedTokensLength; ++i) {\n                if (request.stakedAmounts[i] > 0) {\n                    IERC20 depositToken = IERC20Metadata(request.stakedTokens[i]);\n                    initialDepositTokenBalances[i] = depositToken.balanceOf(address(this));\n                    request.stakedAmounts[i] = Math.min(request.stakedAmounts[i], initialDepositTokenBalances[i]);\n                }\n            }\n\n            for (uint256 i; i < stakedTokensLength; ++i ) {\n                if (request.stakedAmounts[i] > 0) {\n                    allZero = false;\n                    request.stakedTokens[i].safeApprove(MASTER_VAULT_ADDRESS, 0);\n                    request.stakedTokens[i].safeApprove(MASTER_VAULT_ADDRESS, request.stakedAmounts[i]);\n                }\n            }\n            require(!allZero, \"Cannot joinPoolAndStakeBalancerV2 0 tokens\");\n        }\n\n        uint256 beforePoolBalance = IERC20(pool).balanceOf(address(this));\n        {\n            IAsset[] memory tokens;\n            uint256[] memory amounts;\n            bytes memory userData;\n\n            {\n                uint256 length;\n                {\n                    bool hasPoolToken;\n                    for (uint256 i; i < stakedTokensLength; i++) {\n                        if (request.stakedTokens[i] == pool) {\n                            hasPoolToken = true;\n                            break;\n                        }\n                    }\n\n                    length = hasPoolToken ? stakedTokensLength : stakedTokensLength + 1;\n                }\n                tokens = new IAsset[](length);\n                amounts = new uint256[](length);\n\n                for (uint256 i; i < stakedTokensLength; i++) {\n                    tokens[i] = IAsset(request.stakedTokens[i]);\n                    amounts[i] = request.stakedAmounts[i];\n                }\n\n                if (stakedTokensLength != length) {\n                    tokens[stakedTokensLength] = IAsset(pool);\n                    amounts[stakedTokensLength] = 0;\n                }\n\n                userData = _calcUserData(request, stakedTokensLength, length);\n            }\n\n            IVault.JoinPoolRequest memory joinRequest = IVault.JoinPoolRequest(\n                tokens,\n                amounts,\n                //https://docs.balancer.fi/reference/joins-and-exits/pool-joins.html\n                userData,\n                false\n            );\n\n            //joins the pool\n            IVault(MASTER_VAULT_ADDRESS).joinPool(request.poolId, address(this), address(this), joinRequest);\n        }\n\n        uint256 initialGaugeBalance = IERC20(gauge).balanceOf(address(this));\n        {\n            uint256 poolBalance = IERC20(pool).balanceOf(address(this)) - beforePoolBalance;\n\n            IERC20(pool).approve(address(gauge), poolBalance);\n            //stakes everything in a gauge\n            gauge.deposit(poolBalance);\n\n            bytes32 poolSymbol = tokenManager.tokenAddressToSymbol(pool);\n            IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n                asset : pool,\n                symbol : poolSymbol,\n                identifier : poolToIdentifier(pool),\n                balanceSelector : poolToBalanceSelector(pool),\n                unstakeSelector : bytes4(0)\n            });\n\n            // Add staked position\n            DiamondStorageLib.addStakedPosition(position);\n\n            _increaseExposure(tokenManager, address(pool), IERC20(gauge).balanceOf(address(this)) - initialGaugeBalance);\n        }\n\n        bytes32[] memory stakedAssets = new bytes32[](stakedTokensLength);\n        uint256[] memory stakedAmounts = new uint256[](stakedTokensLength);\n\n        // Remove deposit tokens if empty and prepare arrays for the event\n        for (uint256 i; i < stakedTokensLength; ++i ) {\n            if (request.stakedAmounts[i] > 0) {\n                _decreaseExposure(tokenManager, request.stakedTokens[i], request.stakedAmounts[i]);\n\n                stakedAssets[i] = tokenManager.tokenAddressToSymbol(request.stakedTokens[i]);\n                stakedAmounts[i] = initialDepositTokenBalances[i] - IERC20Metadata(request.stakedTokens[i]).balanceOf(address(this));\n            }\n        }\n\n        emit StakeBalancerV2(\n            msg.sender,\n            stakedAssets,\n            pool,\n            stakedAmounts,\n            IERC20(gauge).balanceOf(address(this)) - initialGaugeBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Stakes in a gauge\n     * @param poolId balancer pool id\n     * @param amount stake amount\n     **/\n    function stakeBalancerV2(bytes32 poolId, uint256 amount) external nonReentrant onlyOwner remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        IVault vault = IVault(MASTER_VAULT_ADDRESS);\n\n        (address pool,) = vault.getPool(poolId);\n        if (pool == address(0)) revert ZeroAddressPool();\n\n        //poolToGauge checks as well if the pool is whitelisted\n        IBalancerV2Gauge gauge = IBalancerV2Gauge(poolToGauge(pool));\n\n        uint256 initialGaugeBalance = IERC20(gauge).balanceOf(address(this));\n        amount = Math.min(amount, IERC20(pool).balanceOf(address(this)));\n        require(amount > 0, \"Cannot stake 0 tokens\");\n\n        IERC20(pool).approve(address(gauge), amount);\n        //stakes everything in a gauge\n        gauge.deposit(amount);\n\n        bytes32 poolSymbol = tokenManager.tokenAddressToSymbol(pool);\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : pool,\n            symbol : poolSymbol,\n            identifier : poolToIdentifier(pool),\n            balanceSelector : poolToBalanceSelector(pool),\n            unstakeSelector : bytes4(0)\n        });\n\n        // Add staked position\n        DiamondStorageLib.addStakedPosition(position);\n        if (IERC20(pool).balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(poolSymbol);\n        }\n\n        emit BptStaked(\n            msg.sender,\n            poolSymbol,\n            pool,\n            amount,\n            IERC20(gauge).balanceOf(address(this)) - initialGaugeBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Unstakes tokens a gauge and exits a pool\n     * @param request unstake request\n    **/\n    function unstakeAndExitPoolBalancerV2(IBalancerV2Facet.UnstakeRequest memory request) external nonReentrant onlyOwnerOrInsolvent {\n        (address pool,) = IVault(MASTER_VAULT_ADDRESS).getPool(request.poolId);\n        if (pool == address(0)) revert ZeroAddressPool();\n\n        //poolToGauge checks as well if the pool is whitelisted\n        IBalancerV2Gauge gauge = IBalancerV2Gauge(poolToGauge(pool));\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        if (!tokenManager.isTokenAssetActive(request.unstakedToken)) revert UnstakingToInactiveToken();\n        if (request.unstakedToken == address(pool) || request.unstakedToken == address(gauge)) revert UnstakingWrongToken();\n\n        uint256 initialDepositTokenBalance = IERC20(request.unstakedToken).balanceOf(address(this));\n\n        //checks as well if the pool is whitelisted\n        uint256 initialGaugeBalance = IERC20(gauge).balanceOf(address(this));\n\n        //unstakes from the gauge\n        gauge.withdraw(request.bptAmount);\n\n        IVault.ExitPoolRequest memory exitRequest;\n\n        //exit pool to basic assets\n        {\n            IAsset[] memory assets;\n            uint256[] memory amounts;\n\n            uint256 unstakedIndex;\n            {\n                (IERC20[] memory tokens,,) = IVault(MASTER_VAULT_ADDRESS).getPoolTokens(request.poolId);\n\n                uint256 tokensLength = tokens.length;\n                assets = new IAsset[](tokensLength);\n                amounts = new uint256[](tokensLength);\n\n                bool foundPoolToken;\n                for (uint256 i; i < tokensLength; ++i) {\n                    assets[i] = IAsset(address(tokens[i]));\n                    if (address(tokens[i]) == pool) {\n                        foundPoolToken = true;\n                    }\n                    if (address(tokens[i]) == request.unstakedToken) {\n                        amounts[i] = request.unstakedAmount;\n                        unstakedIndex = foundPoolToken ? i - 1 : i;\n                    }\n                }\n            }\n\n            exitRequest = IVault.ExitPoolRequest(\n                assets,\n                amounts,\n                //https://docs.balancer.fi/reference/joins-and-exits/pool-joins.html\n                abi.encode(0, request.bptAmount, unstakedIndex),\n                false\n            );\n        }\n\n        //exit the pool\n        IVault(MASTER_VAULT_ADDRESS).exitPool(request.poolId, address(this), payable(address(this)), exitRequest);\n\n        bytes32[] memory unstakedAssets = new bytes32[](1);\n        uint256[] memory unstakedAmounts = new uint256[](1);\n\n        unstakedAssets[0] = tokenManager.tokenAddressToSymbol(request.unstakedToken);\n        unstakedAmounts[0] = IERC20(request.unstakedToken).balanceOf(address(this)) - initialDepositTokenBalance;\n        uint256 newGaugeBalance = IERC20(gauge).balanceOf(address(this));\n\n        _increaseExposure(tokenManager, request.unstakedToken, unstakedAmounts[0]);\n        _decreaseExposure(tokenManager, address(pool), initialGaugeBalance - newGaugeBalance);\n\n\n        if (newGaugeBalance == 0) {\n            DiamondStorageLib.removeStakedPosition(poolToIdentifier(pool));\n        }\n\n        emit UnstakeBalancerV2(\n            msg.sender,\n            unstakedAssets,\n            pool,\n            unstakedAmounts,\n            initialGaugeBalance - newGaugeBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Unstakes tokens a gauge\n     * @param poolId balancer pool id\n     * @param amount unstake amount\n    **/\n    function unstakeBalancerV2(bytes32 poolId, uint256 amount) external nonReentrant onlyOwnerOrInsolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        (address pool,) = IVault(MASTER_VAULT_ADDRESS).getPool(poolId);\n        if (pool == address(0)) revert ZeroAddressPool();\n\n        //poolToGauge checks as well if the pool is whitelisted\n        IBalancerV2Gauge gauge = IBalancerV2Gauge(poolToGauge(pool));\n\n        uint256 initialDepositTokenBalance = IERC20(pool).balanceOf(address(this));\n\n        //checks as well if the pool is whitelisted\n        uint256 initialGaugeBalance = IERC20(gauge).balanceOf(address(this));\n        amount = Math.min(amount, initialGaugeBalance);\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        //unstakes from the gauge\n        gauge.withdraw(amount);\n\n        uint256 newGaugeBalance = IERC20(gauge).balanceOf(address(this));\n        if (newGaugeBalance == 0) {\n            DiamondStorageLib.removeStakedPosition(poolToIdentifier(pool));\n        }\n\n        bytes32 poolSymbol = tokenManager.tokenAddressToSymbol(pool);\n        DiamondStorageLib.addOwnedAsset(poolSymbol, pool);\n\n        emit BptUnstaked(\n            msg.sender,\n            poolSymbol,\n            pool,\n            IERC20(pool).balanceOf(address(this)) - initialDepositTokenBalance,\n            initialGaugeBalance - newGaugeBalance,\n            block.timestamp\n        );\n    }\n\n    function claimRewardsBalancerV2(bytes32 poolId) external nonReentrant onlyOwner remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        (address pool,) = IVault(MASTER_VAULT_ADDRESS).getPool(poolId);\n        IBalancerV2Gauge gauge = IBalancerV2Gauge(poolToGauge(pool));\n\n        bytes32[] memory _rewardTokens = rewardTokens(pool);\n        uint256[] memory initialBalances = new uint256[](_rewardTokens.length);\n\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            address rewardToken;\n            rewardToken = unsupportedAssetToAddress(_rewardTokens[i]);\n\n            // Token is supported\n            if(rewardToken == address(0)){\n                rewardToken = tokenManager.getAssetAddress(_rewardTokens[i], false);\n                initialBalances[i] = IERC20(rewardToken).balanceOf(address(this));\n            }\n            // Token is not supported\n            else {\n                initialBalances[i] = IERC20(rewardToken).balanceOf(address(this));\n            }\n        }\n\n        gauge.claim_rewards();\n\n        IBalancerPseudoMinter pseudoMinter = IBalancerPseudoMinter(gauge.bal_pseudo_minter());\n        pseudoMinter.mint(address(gauge));\n\n        for (uint256 i; i < _rewardTokens.length; i++) {\n            address rewardToken;\n            rewardToken = unsupportedAssetToAddress(_rewardTokens[i]);\n\n            // Token is supported - add to owned assets\n            if(rewardToken == address(0)){\n                rewardToken = tokenManager.getAssetAddress(_rewardTokens[i], false);\n                uint256 claimedAmount = IERC20(rewardToken).balanceOf(address(this)) - initialBalances[i];\n                if(claimedAmount > 0) {\n                    _increaseExposure(tokenManager, rewardToken, claimedAmount);\n                    emit RewardClaimed(\n                        msg.sender,\n                        rewardToken,\n                        _rewardTokens[i],\n                        claimedAmount,\n                        block.timestamp\n                    );\n                }\n            }\n            // Token is not supported - transfer to msg.sender\n            else {\n                uint256 claimedAmount = IERC20(rewardToken).balanceOf(address(this)) - initialBalances[i];\n                if(claimedAmount > 0) {\n                    rewardToken.safeTransfer(msg.sender, claimedAmount);\n                    emit RewardClaimed(\n                        msg.sender,\n                        rewardToken,\n                        _rewardTokens[i],\n                        claimedAmount,\n                        block.timestamp\n                    );\n                }\n            }\n        }\n    }\n\n    function balancerGgAvaxBalance() public view returns (uint256) {\n        return gaugeBalance(0xC13546b97B9B1b15372368Dc06529d7191081F5B);\n    }\n\n    function balancerYyAvaxBalance() public view returns (uint256) {\n        return gaugeBalance(0x9fA6aB3d78984A69e712730A2227F20bCC8b5aD9);\n    }\n\n    function balancerSAvaxBalance() public view returns (uint256) {\n        return gaugeBalance(0xfD2620C9cfceC7D152467633B3B0Ca338D3d78cc);\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function poolToGauge(address pool) internal pure returns (address) {\n        if (pool == 0xC13546b97B9B1b15372368Dc06529d7191081F5B) {\n            return 0x231d84C37b2C4B5a2E2Fe325BB77DAa65bF71D92;\n        }\n        if (pool == 0x9fA6aB3d78984A69e712730A2227F20bCC8b5aD9) {\n            return 0x720158c329E6558287c4539b0Ed21742B0B73436;\n        }\n        if (pool == 0xfD2620C9cfceC7D152467633B3B0Ca338D3d78cc) {\n            return 0xf9aE6D2D56f02304f72dcC61694eAD0dC8DB51f7;\n        }\n\n        revert BalancerV2PoolNotWhitelisted();\n    }\n\n    function poolToIdentifier(address pool) internal pure returns (bytes32) {\n        if (pool == 0xC13546b97B9B1b15372368Dc06529d7191081F5B) {\n            return \"BAL_GG_AVAX_MAIN\";\n        }\n        if (pool == 0x9fA6aB3d78984A69e712730A2227F20bCC8b5aD9) {\n            return \"BAL_YY_AVAX_MAIN\";\n        }\n        if (pool == 0xfD2620C9cfceC7D152467633B3B0Ca338D3d78cc) {\n            return \"BAL_S_AVAX_MAIN\";\n        }\n\n        revert BalancerV2PoolNotWhitelisted();\n    }\n\n    function poolToBalanceSelector(address pool) internal pure returns (bytes4) {\n        if (pool == 0xC13546b97B9B1b15372368Dc06529d7191081F5B) {\n            return this.balancerGgAvaxBalance.selector;\n        }\n        if (pool == 0x9fA6aB3d78984A69e712730A2227F20bCC8b5aD9) {\n            return this.balancerYyAvaxBalance.selector;\n        }\n        if (pool == 0xfD2620C9cfceC7D152467633B3B0Ca338D3d78cc) {\n            return this.balancerSAvaxBalance.selector;\n        }\n\n        revert BalancerV2PoolNotWhitelisted();\n    }\n\n    function gaugeBalance(address pool) internal view returns (uint256) {\n        address gauge = poolToGauge(pool);\n        return IERC20(gauge).balanceOf(address(this));\n    }\n\n    function unsupportedAssetToAddress(bytes32 symbol) internal pure returns (address) {\n        if (symbol == \"GGP\") {\n            return 0x69260B9483F9871ca57f81A90D91E2F96c2Cd11d;\n        }\n        if (symbol == \"BAL\") {\n            return 0xE15bCB9E0EA69e6aB9FA080c4c4A5632896298C3;\n        }\n        if (symbol == \"QI\") {\n            return 0x8729438EB15e2C8B576fCc6AeCdA6A148776C0F5;\n        }\n\n        return address(0);\n    }\n\n    function rewardTokens(address pool) internal pure returns (bytes32[] memory) {\n        if (pool == 0xC13546b97B9B1b15372368Dc06529d7191081F5B) {\n            bytes32[] memory tokens = new bytes32[](4);\n            tokens[0] = \"AVAX\";\n            tokens[1] = \"USDC\";\n            tokens[2] = \"GGP\";\n            tokens[3] = \"BAL\";\n\n            return tokens;\n        }\n        if (pool == 0x9fA6aB3d78984A69e712730A2227F20bCC8b5aD9) {\n            bytes32[] memory tokens = new bytes32[](4);\n            tokens[0] = \"AVAX\";\n            tokens[1] = \"USDC\";\n            tokens[2] = \"yyAVAX\";\n            tokens[3] = \"BAL\";\n\n            return tokens;\n        }\n        if (pool == 0xfD2620C9cfceC7D152467633B3B0Ca338D3d78cc) {\n            bytes32[] memory tokens = new bytes32[](4);\n            tokens[0] = \"AVAX\";\n            tokens[1] = \"USDC\";\n            tokens[2] = \"QI\";\n            tokens[3] = \"BAL\";\n\n            return tokens;\n        }\n\n        revert BalancerV2RewardsNotDefined();\n    }\n\n    function _calcUserData(IBalancerV2Facet.StakeRequest memory request, uint256 stakedTokensLength, uint256 length) internal view returns (bytes memory userData) {\n        IVault vault = IVault(MASTER_VAULT_ADDRESS);\n        (address pool,) = vault.getPool(request.poolId);\n\n        if (stakedTokensLength != length) {\n            userData = abi.encode(1, request.stakedAmounts, request.minBptAmount);\n        } else {\n            uint256[] memory stakedAmounts = new uint256[](length - 1);\n            uint256 j;\n            for (uint256 i; i < stakedTokensLength; i++) {\n                if (request.stakedTokens[i] != pool) {\n                    stakedAmounts[j] = request.stakedAmounts[i];\n                    ++j;\n                }\n            }\n            userData = abi.encode(1, stakedAmounts, request.minBptAmount);\n        }\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    event RewardClaimed(\n        address indexed user,\n        address indexed token,\n        bytes32 asset,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n\n    // ERRORS\n    error BalancerV2PoolNotWhitelisted();\n\n    error BalancerV2RewardsNotDefined();\n\n    error ArgArrayLengthsDiffer();\n\n    error DepositingInactiveToken();\n\n    error DepositingWrongToken();\n\n    error UnstakingToInactiveToken();\n\n    error UnstakingWrongToken();\n\n    error ZeroAddressPool();\n}\n"
    },
    "contracts/facets/avalanche/BeefyFinanceAvalancheFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/facets/IBeefyFinance.sol\";\n\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract BeefyFinanceAvalancheFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    // Vaults\n    address private constant MOO_PNG_AVAX_USDC_LP = 0xf3340EdF16563D52C7E7C576F2fCC8f3D52464aB;\n    address private constant MOO_PNG_AVAX_USDCe_LP = 0x9B02209a331c072637C6eBd34cdCD6b6A16987a9;\n    address private constant MOO_TJ_AVAX_USDC_LP = 0x7E5bC7088aB3Da3e7fa1Aa7ceF1dC73F5B00681c;\n\n    // LPs\n    address private constant PNG_AVAX_USDC_LP = 0x0e0100Ab771E9288e0Aa97e11557E6654C3a9665;\n    address private constant PNG_AVAX_USDCe_LP = 0xbd918Ed441767fe7924e99F6a0E0B568ac1970D9;\n    address private constant TJ_AVAX_USDC_LP = 0xf4003F4efBE8691B60249E6afbD307aBE7758adb;\n\n    // ----- STAKE -----\n\n    /**\n      * Stakes PNG_AVAX_USDC_LP in the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_USDC_LP to be staked\n    **/\n    function stakePngUsdcAvaxLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant remainsSolvent {\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n            lpTokenAddress: PNG_AVAX_USDC_LP,\n            vaultAddress: MOO_PNG_AVAX_USDC_LP,\n            lpTokenSymbol: \"PNG_AVAX_USDC_LP\",\n            vaultTokenSymbol: \"MOO_PNG_AVAX_USDC_LP\",\n            amount: amount\n        }));\n    }\n\n    /**\n      * Stakes PNG_AVAX_USDCe_LP in the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_USDCe_LP to be staked\n    **/\n    function stakePngUsdceAvaxLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant remainsSolvent {\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n        lpTokenAddress: PNG_AVAX_USDCe_LP,\n        vaultAddress: MOO_PNG_AVAX_USDCe_LP,\n        lpTokenSymbol: \"PNG_AVAX_USDCe_LP\",\n        vaultTokenSymbol: \"MOO_PNG_AVAX_USDCe_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Stakes TJ_AVAX_USDC_LP in the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_USDC_LP to be staked\n    **/\n    function stakeTjUsdcAvaxLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant remainsSolvent {\n        _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n        lpTokenAddress: TJ_AVAX_USDC_LP,\n        vaultAddress: MOO_TJ_AVAX_USDC_LP,\n        lpTokenSymbol: \"TJ_AVAX_USDC_LP\",\n        vaultTokenSymbol: \"MOO_TJ_AVAX_USDC_LP\",\n        amount: amount\n        }));\n    }\n\n    // ----- UNSTAKE -----\n\n    /**\n      * Unstakes PNG_AVAX_USDC_LP from the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_USDC_LP to be unstaked\n    **/\n    function unstakePngUsdcAvaxLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n        lpTokenAddress: PNG_AVAX_USDC_LP,\n        vaultAddress: MOO_PNG_AVAX_USDC_LP,\n        lpTokenSymbol: \"PNG_AVAX_USDC_LP\",\n        vaultTokenSymbol: \"MOO_PNG_AVAX_USDC_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Unstakes PNG_AVAX_USDCe_LP from the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_USDCe_LP to be unstaked\n    **/\n    function unstakePngUsdceAvaxLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n        lpTokenAddress: PNG_AVAX_USDCe_LP,\n        vaultAddress: MOO_PNG_AVAX_USDCe_LP,\n        lpTokenSymbol: \"PNG_AVAX_USDCe_LP\",\n        vaultTokenSymbol: \"MOO_PNG_AVAX_USDCe_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Untakes TJ_AVAX_USDC_LP from the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_USDC_LP to be unstaked\n    **/\n    function unstakeTjUsdcAvaxLpBeefy(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails({\n        lpTokenAddress: TJ_AVAX_USDC_LP,\n        vaultAddress: MOO_TJ_AVAX_USDC_LP,\n        lpTokenSymbol: \"TJ_AVAX_USDC_LP\",\n        vaultTokenSymbol: \"MOO_TJ_AVAX_USDC_LP\",\n        amount: amount\n        }));\n    }\n\n    // ----- PRIVATE METHODS -----\n\n\n    /**\n      * Stakes {stakingDetails.lpTokenAddress} LP token in the Beefy protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param stakingDetails IBeefyFinance.BeefyStakingDetails staking details\n    **/\n    function _stakeLpBeefy(IBeefyFinance.BeefyStakingDetails memory stakingDetails) private {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(stakingDetails.amount > 0, \"Cannot stake 0 tokens\");\n        // _ACTIVE = 2\n        require(tokenManager.tokenToStatus(stakingDetails.lpTokenAddress) == 2, \"LP token not supported\");\n        require(tokenManager.tokenToStatus(stakingDetails.vaultAddress) == 2, \"Vault token not supported\");\n        require(IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this)) >= stakingDetails.amount, \"Not enough LP token available\");\n\n        stakingDetails.lpTokenAddress.safeApprove(stakingDetails.vaultAddress, 0);\n        stakingDetails.lpTokenAddress.safeApprove(stakingDetails.vaultAddress, stakingDetails.amount);\n\n        IBeefyFinance vaultContract = IBeefyFinance(stakingDetails.vaultAddress);\n        uint256 initialVaultToken = vaultContract.balanceOf(address(this));\n\n        vaultContract.deposit(stakingDetails.amount);\n\n        _increaseExposure(tokenManager, stakingDetails.vaultAddress, vaultContract.balanceOf(address(this)) - initialVaultToken);\n        _decreaseExposure(tokenManager, stakingDetails.lpTokenAddress, stakingDetails.amount);\n\n        emit Staked(msg.sender, stakingDetails.lpTokenSymbol, stakingDetails.vaultAddress, stakingDetails.amount, block.timestamp);\n    }\n\n    /**\n              * Unstakes {stakingDetails.lpTokenAddress} LP token in the Beefy protocol\n              * @dev This function uses the redstone-evm-connector\n              * @param stakingDetails IBeefyFinance.BeefyStakingDetails staking details\n    **/\n    function _unstakeLpBeefy(IBeefyFinance.BeefyStakingDetails memory stakingDetails) private {\n        IBeefyFinance vaultContract = IBeefyFinance(stakingDetails.vaultAddress);\n        uint256 initialStakedBalance = vaultContract.balanceOf(address(this));\n        uint256 initialLpBalance = IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this));\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(initialStakedBalance >= stakingDetails.amount, \"Cannot unstake more than was initially staked\");\n\n        vaultContract.withdraw(stakingDetails.amount);\n\n        _decreaseExposure(tokenManager, stakingDetails.vaultAddress, stakingDetails.amount);\n        _increaseExposure(tokenManager, stakingDetails.lpTokenAddress, IERC20(stakingDetails.lpTokenAddress).balanceOf(address(this)) - initialLpBalance);\n\n        emit Unstaked(msg.sender, stakingDetails.lpTokenSymbol, stakingDetails.vaultAddress, stakingDetails.amount, block.timestamp);\n    }\n\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of the vault token\n        * @param amount of the asset that was staked\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param asset the asset that was unstaked\n        * @param vault address of the vault token\n        * @param amount of the asset that was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\n}"
    },
    "contracts/facets/avalanche/CaiFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 6d86e26ff5a23ee2fa4ddb079d0569c41d45f7dd;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@redstone-finance/evm-connector/contracts/data-services/AvalancheDataServiceConsumerBase.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract CaiFacet is\n    ReentrancyGuardKeccak,\n    OnlyOwnerOrInsolvent,\n    AvalancheDataServiceConsumerBase\n{\n    using TransferHelper for address;\n\n    address private constant INDEX_ROUTER =\n        0xD6dd95610fC3A3579a2C32fe06158d8bfB8F4eE9;\n\n    address private constant CAI = 0x48f88A3fE843ccb0b5003e70B4192c1d7448bEf0;\n\n    function mintCai(\n        bytes4 selector,\n        bytes memory data,\n        address fromToken,\n        uint256 fromAmount,\n        uint256 maxSlippage\n    ) external nonReentrant onlyOwner remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(\n            fromAmount > 0,\n            \"Amount of tokens to sell has to be greater than 0\"\n        );\n\n        bytes32 fromTokenSymbol = tokenManager.tokenAddressToSymbol(fromToken);\n\n        address(fromToken).safeApprove(INDEX_ROUTER, 0);\n        address(fromToken).safeApprove(INDEX_ROUTER, fromAmount);\n\n        uint256 beforeCaiBalance = IERC20(CAI).balanceOf(address(this));\n        uint256 beforeFromTokenBalance = IERC20(fromToken).balanceOf(address(this));\n\n        (bool success, ) = INDEX_ROUTER.call((abi.encodePacked(selector, data)));\n        require(success, \"Mint failed\");\n\n        uint256 afterCaiBalance = IERC20(CAI).balanceOf(address(this));\n        uint256 afterFromTokenBalance = IERC20(fromToken).balanceOf(address(this));\n\n        uint256 fromTokenUsed = beforeFromTokenBalance - afterFromTokenBalance;\n        uint256 caiBoughtAmount = afterCaiBalance - beforeCaiBalance;\n\n        CAI.safeApprove(INDEX_ROUTER, 0);\n        CAI.safeApprove(INDEX_ROUTER, type(uint256).max);\n\n        checkSlippage(fromTokenSymbol, fromTokenUsed, \"CAI\", caiBoughtAmount, maxSlippage);\n\n        _increaseExposure(tokenManager, CAI, caiBoughtAmount);\n        _decreaseExposure(tokenManager, fromToken, fromTokenUsed);\n\n        emit CaiMinted(\n            msg.sender,\n            fromTokenSymbol,\n            fromAmount,\n            caiBoughtAmount,\n            block.timestamp\n        );\n    }\n\n    function burnCai(\n        bytes4 selector,\n        bytes memory data,\n        uint256 shares,\n        address toToken,\n        uint256 maxSlippage\n    ) external nonReentrant onlyOwnerOrInsolvent remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(shares > 0, \"Amount of tokens to sell has to be greater than 0\");\n\n        bytes32 toTokenSymbol = tokenManager.tokenAddressToSymbol(toToken);\n\n        uint256 caiBurnt;\n        uint256 boughtAmount;\n\n        {\n            uint256 beforeCaiBalance = IERC20(CAI).balanceOf(address(this));\n            uint256 beforeTokenBalance = IERC20(toToken).balanceOf(address(this));\n\n            (bool success, ) = INDEX_ROUTER.call((abi.encodePacked(selector, data)));\n            require(success, \"Burn failed\");\n\n            uint256 afterCaiBalance = IERC20(CAI).balanceOf(address(this));\n            uint256 afterTokenBalance = IERC20(toToken).balanceOf(address(this));\n\n            caiBurnt = beforeCaiBalance - afterCaiBalance;\n            boughtAmount = afterTokenBalance - beforeTokenBalance;\n        }\n\n        checkSlippage(\"CAI\", caiBurnt, toTokenSymbol, boughtAmount, maxSlippage);\n\n        _decreaseExposure(tokenManager, CAI, caiBurnt);\n        _increaseExposure(tokenManager, toToken, boughtAmount);\n\n        emit CaiBurned(\n            msg.sender,\n            shares,\n            toTokenSymbol,\n            boughtAmount,\n            block.timestamp\n        );\n    }\n\n    function checkSlippage(\n        bytes32 inputAsset,\n        uint256 inputAmount,\n        bytes32 outputAsset,\n        uint256 outputAmount,\n        uint256 maxSlippage\n    ) internal view {        \n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        bytes32[] memory assets = new bytes32[](2);\n        assets[0] = inputAsset;\n        assets[1] = outputAsset;\n\n        uint256[] memory prices = getOracleNumericValuesFromTxMsg(assets);\n\n        IERC20Metadata inputToken = IERC20Metadata(tokenManager.getAssetAddress(inputAsset, true));\n        IERC20Metadata outputToken = IERC20Metadata(tokenManager.getAssetAddress(outputAsset, true));\n\n        uint256 inputValue = prices[0] * inputAmount * 10 ** 10 / 10 ** inputToken.decimals();\n        uint256 outputValue = prices[1] * outputAmount * 10 ** 10 / 10 ** outputToken.decimals();\n        uint256 diff = inputValue > outputValue\n            ? (inputValue - outputValue)\n            : (outputValue - inputValue);\n        uint256 slippage = (diff * 10000) / inputValue;\n\n        require(slippage <= maxSlippage, \"Slippage too high\");\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    /**\n     * @dev emitted after a CAI mint\n     * @param user the address of user minting the CAI\n     * @param soldAsset sold by the user\n     * @param amountSold amount of tokens sold\n     * @param amountMinted amount of CAI minted\n     * @param timestamp time of the mint\n     **/\n    event CaiMinted(\n        address indexed user,\n        bytes32 indexed soldAsset,\n        uint256 amountSold,\n        uint256 amountMinted,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted after a CAI mint\n     * @param user the address of user minting the CAI\n     * @param shares amount of CAI burned\n     * @param buyAsset redeemed by the user\n     * @param amountRedeemed amount of CAI minted\n     * @param timestamp time of the mint\n     **/\n    event CaiBurned(\n        address indexed user,\n        uint256 indexed shares,\n        bytes32 indexed buyAsset,\n        uint256 amountRedeemed,\n        uint256 timestamp\n    );\n}\n"
    },
    "contracts/facets/avalanche/CurveFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 799a1765b64edc5c158198ef84f785af79e234ae;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\nimport \"../../interfaces/ICurvePool.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract CurveFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    // Used to deposit/withdraw tokens\n    address private constant CURVE_POOL_ADDRESS = 0x58e57cA18B7A47112b877E31929798Cd3D703b0f;\n    // crvUSDBTCETH\n    bytes32 private constant CURVE_TOKEN_SYMBOL = \"crvUSDBTCETH\";\n\n    /**\n     * Stakes tokens in Curve atricrypto pool\n     * @param amounts amounts of tokens to be staked\n     **/\n    function stakeCurve(uint256[5] memory amounts) external nonReentrant onlyOwner recalculateAssetsExposure remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        address curveTokenAddress = DeploymentConstants.getTokenManager().getAssetAddress(CURVE_TOKEN_SYMBOL, false);\n        IERC20 curveToken = IERC20(curveTokenAddress);\n        uint256 initialCurveBalance = curveToken.balanceOf(address(this));\n\n        bool allZero = true;\n        uint256 numStakeTokens;\n        for (uint256 i; i < 5; ++i ) {\n            IERC20 token = IERC20(tokenManager.getAssetAddress(getTokenSymbol(i), false));\n            amounts[i] = Math.min(token.balanceOf(address(this)), amounts[i]);\n            if (amounts[i] > 0) {\n                allZero = false;\n                address(token).safeApprove(CURVE_POOL_ADDRESS, 0);\n                address(token).safeApprove(CURVE_POOL_ADDRESS, amounts[i]);\n                ++numStakeTokens;\n            }\n        }\n        require(!allZero, \"Cannot stake 0 tokens\");\n\n        bytes32[] memory stakedAssets = new bytes32[](numStakeTokens);\n        uint256[] memory stakedAmounts = new uint256[](numStakeTokens);\n        uint256 idx;\n        for (uint256 i; i < 5; ++i ) {\n            if (amounts[i] > 0) {\n                stakedAssets[idx] = getTokenSymbol(i);\n                stakedAmounts[idx++] = amounts[i];\n            }\n        }\n\n        ICurvePool(CURVE_POOL_ADDRESS).add_liquidity(amounts, 0);\n\n        // Add/remove owned tokens\n        DiamondStorageLib.addOwnedAsset(CURVE_TOKEN_SYMBOL, curveTokenAddress);\n        for (uint256 i; i < 5; ++i ) {\n            IERC20 token = IERC20(tokenManager.getAssetAddress(getTokenSymbol(i), false));\n            if (amounts[i] > 0 && token.balanceOf(address(this)) == 0) {\n                DiamondStorageLib.removeOwnedAsset(getTokenSymbol(i));\n            }\n        }\n\n        emit Staked(\n            msg.sender,\n            stakedAssets,\n            curveTokenAddress,\n            stakedAmounts,\n            curveToken.balanceOf(address(this)) - initialCurveBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Unstakes tokens from Curve atricrypto pool\n     * @param amount amount of token to be unstaked\n     **/\n    function unstakeCurve(uint256 amount, uint256[5] memory min_amounts) external nonReentrant onlyOwnerOrInsolvent recalculateAssetsExposure {\n        ICurvePool pool = ICurvePool(CURVE_POOL_ADDRESS);\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address curveTokenAddress = tokenManager.getAssetAddress(CURVE_TOKEN_SYMBOL, true);\n        IERC20 curveToken = IERC20(curveTokenAddress);\n        uint256 curveTokenBalance = curveToken.balanceOf(address(this));\n        uint256[5] memory initialDepositTokenBalances;\n        for (uint256 i; i < 5; ++i) {\n            IERC20 depositToken = IERC20(tokenManager.getAssetAddress(getTokenSymbol(i), true));\n            initialDepositTokenBalances[i] = depositToken.balanceOf(address(this));\n        }\n        amount = Math.min(curveTokenBalance, amount);\n\n        curveTokenAddress.safeApprove(CURVE_POOL_ADDRESS, 0);\n        curveTokenAddress.safeApprove(CURVE_POOL_ADDRESS, amount);\n        pool.remove_liquidity(amount, min_amounts);\n\n        // Add/remove owned tokens\n        uint256[5] memory unstakedAmounts;\n        for (uint256 i; i < 5; ++i) {\n            IERC20 depositToken = IERC20(tokenManager.getAssetAddress(getTokenSymbol(i), true));\n            unstakedAmounts[i] = depositToken.balanceOf(address(this)) - initialDepositTokenBalances[i];\n            DiamondStorageLib.addOwnedAsset(getTokenSymbol(i), address(depositToken));\n        }\n        uint256 newCurveTokenBalance = curveToken.balanceOf(address(this));\n        if(newCurveTokenBalance == 0) {\n            DiamondStorageLib.removeOwnedAsset(CURVE_TOKEN_SYMBOL);\n        }\n\n        emit Unstaked(\n            msg.sender,\n            getTokenSymbols(),\n            curveTokenAddress,\n            unstakedAmounts,\n            curveTokenBalance - newCurveTokenBalance,\n            block.timestamp\n        );\n    }\n\n    // TODO: Add slippage control\n    /**\n     * Unstakes one token from Curve atricrypto pool\n     * @param i index of token to be unstaked\n     * @param amount amount of token to be unstaked\n     **/\n    function unstakeOneTokenCurve(uint256 i, uint256 amount) external nonReentrant onlyOwnerOrInsolvent recalculateAssetsExposure {\n        require(i < 5, \"Invalid token index\");\n        ICurvePool pool = ICurvePool(CURVE_POOL_ADDRESS);\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address curveTokenAddress = tokenManager.getAssetAddress(CURVE_TOKEN_SYMBOL, true);\n        IERC20 curveToken = IERC20(curveTokenAddress);\n        IERC20 depositToken = IERC20(tokenManager.getAssetAddress(getTokenSymbol(i), true));\n        uint256 initialDepositTokenBalance = depositToken.balanceOf(address(this));\n        uint256 curveTokenBalance = curveToken.balanceOf(address(this));\n        uint256 maxWithdrawAmount = pool.calc_withdraw_one_coin(curveTokenBalance, i);\n        amount = Math.min(maxWithdrawAmount, amount);\n\n        uint256 burnAmount = curveTokenBalance * amount / maxWithdrawAmount;\n        curveTokenAddress.safeApprove(CURVE_POOL_ADDRESS, 0);\n        curveTokenAddress.safeApprove(CURVE_POOL_ADDRESS, burnAmount);\n        pool.remove_liquidity_one_coin(burnAmount, i, 0);\n\n        // Add/remove owned tokens\n        DiamondStorageLib.addOwnedAsset(getTokenSymbol(i), address(depositToken));\n        uint256 newCurveTokenBalance = curveToken.balanceOf(address(this));\n        if(newCurveTokenBalance == 0) {\n            DiamondStorageLib.removeOwnedAsset(CURVE_TOKEN_SYMBOL);\n        }\n\n        emit UnstakedOneToken(\n            msg.sender,\n            getTokenSymbol(i),\n            curveTokenAddress,\n            depositToken.balanceOf(address(this)) - initialDepositTokenBalance,\n            curveTokenBalance - newCurveTokenBalance,\n            block.timestamp\n        );\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function getTokenSymbols() internal pure returns (bytes32[5] memory tokenSymbols) {\n        tokenSymbols = [\n            bytes32(\"DAIe\"),\n            bytes32(\"USDCe\"),\n            bytes32(\"USDT.e\"),\n            bytes32(\"WBTCe\"),\n            bytes32(\"ETH\")\n        ];\n    }\n\n    function getTokenSymbol(uint256 i) internal pure returns (bytes32) {\n        return getTokenSymbols()[i];\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n        * @dev emitted when user stakes assets\n        * @param user the address executing staking\n        * @param assets the assets that were staked\n        * @param vault address of the vault token\n        * @param depositTokenAmounts how much of deposit tokens was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32[] assets, address indexed vault, uint256[] depositTokenAmounts, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes assets\n        * @param user the address executing staking\n        * @param assets the assets that were unstaked\n        * @param vault address of the vault token\n        * @param depositTokenAmounts how much of deposit tokens was received\n        * @param receiptTokenAmount how much of receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32[5] assets, address indexed vault, uint256[5] depositTokenAmounts, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param vault address of the vault token\n        * @param asset the asset that was unstaked\n        * @param depositTokenAmount how much deposit token was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event UnstakedOneToken(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n}\n"
    },
    "contracts/facets/avalanche/GLPFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 499a35c62f8a913d89f7faf78bf5c6b3cea2ee8b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../../interfaces/facets/avalanche/IGLPRewarder.sol\";\nimport \"../../interfaces/facets/avalanche/IRewardRouterV2.sol\";\nimport \"../../interfaces/facets/avalanche/IRewardTracker.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract GLPFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    // Used to claim GLP fees\n    address private constant REWARD_ROUTER_ADDRESS = 0xa192D0681E2b9484d1fA48083D36B8A2D0Da1809;\n    // Used to mint/redeem GLP\n    address private constant GLP_REWARD_ROUTER_ADDRESS = 0xB70B91CE0771d3f4c81D87660f71Da31d48eB3B3;\n    // Used to approve tokens to mint GLP with\n    address private constant GLP_MANAGER_ADDRESS = 0xD152c7F25db7F4B95b7658323c5F33d176818EE4;\n    // fsGLP\n    address private constant GLP_TOKEN_ADDRESS = 0x9e295B5B976a184B14aD8cd72413aD846C299660;\n\n    function claimGLpFees() external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent {\n        IRewardRouterV2 rewardRouter = IRewardRouterV2(REWARD_ROUTER_ADDRESS);\n        IRewardTracker rewardTracker = IRewardTracker(rewardRouter.feeGlpTracker());\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        require(rewardTracker.claimable(address(this)) > 0, \"There are no claimable fees\");\n\n        IERC20Metadata wavaxToken = getERC20TokenInstance(\"AVAX\", false);\n        uint256 initialWavaxBalance = wavaxToken.balanceOf(address(this));\n\n        rewardRouter.claimFees();\n\n        uint256 postClaimingWavaxBalance = wavaxToken.balanceOf(address(this));\n        uint256 wavaxClaimed = postClaimingWavaxBalance-initialWavaxBalance;\n        _increaseExposure(tokenManager, address(wavaxToken), wavaxClaimed);\n\n        emit GLPFeesClaim(msg.sender, wavaxClaimed, block.timestamp);\n    }\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent{\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        require(tokenManager.isTokenAssetActive(GLP_TOKEN_ADDRESS), \"GLP not supported.\");\n        require(tokenManager.isTokenAssetActive(_token), \"Asset not supported.\");\n\n        IERC20Metadata tokenToMintWith = IERC20Metadata(_token);\n        bytes32 tokenToMintWithSymbol = tokenManager.tokenAddressToSymbol(_token);\n        IGLPRewarder glpRewarder = IGLPRewarder(GLP_REWARD_ROUTER_ADDRESS);\n        IERC20Metadata glpToken = IERC20Metadata(GLP_TOKEN_ADDRESS);\n\n        uint256 glpInitialBalance = glpToken.balanceOf(address(this));\n\n        _amount = Math.min(tokenToMintWith.balanceOf(address(this)), _amount);\n\n        require(_amount > 0, \"Amount of GLP to mint  has to be greater than 0\");\n\n        _token.safeApprove(GLP_MANAGER_ADDRESS, 0);\n        _token.safeApprove(GLP_MANAGER_ADDRESS, _amount);\n\n        uint256 glpOutputAmount = glpRewarder.mintAndStakeGlp(_token, _amount, _minUsdg, _minGlp);\n\n        require((glpToken.balanceOf(address(this)) - glpInitialBalance) == glpOutputAmount, \"GLP minted and balance difference mismatch\");\n        require(glpOutputAmount >=_minGlp, \"Insufficient output amount\");\n\n        _increaseExposure(tokenManager, GLP_TOKEN_ADDRESS, glpOutputAmount);\n        _decreaseExposure(tokenManager, _token, _amount);\n\n        emit GLPMint(\n            msg.sender,\n            tokenToMintWithSymbol,\n            _amount,\n            glpOutputAmount,\n            block.timestamp\n        );\n\n    }\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut) external nonReentrant onlyOwnerOrInsolvent noBorrowInTheSameBlock    {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        require(tokenManager.isTokenAssetActive(_tokenOut), \"Asset not supported.\");\n\n        IERC20Metadata redeemedToken = IERC20Metadata(_tokenOut);\n        bytes32 redeemedTokenSymbol = tokenManager.tokenAddressToSymbol(_tokenOut);\n        IGLPRewarder glpRewarder = IGLPRewarder(GLP_REWARD_ROUTER_ADDRESS);\n        IERC20Metadata glpToken = IERC20Metadata(GLP_TOKEN_ADDRESS);\n\n        uint256 redeemedTokenInitialBalance = redeemedToken.balanceOf(address(this));\n        _glpAmount = Math.min(glpToken.balanceOf(address(this)), _glpAmount);\n\n        require(_glpAmount > 0, \"Amount of GLP to redeem has to be greater than 0\");\n\n        uint256 redeemedAmount = glpRewarder.unstakeAndRedeemGlp(_tokenOut, _glpAmount, _minOut, address(this));\n\n        require((redeemedToken.balanceOf(address(this)) - redeemedTokenInitialBalance) == redeemedAmount, \"Redeemed token amount and balance difference mismatch\");\n        require(redeemedAmount >= _minOut, \"Insufficient output amount\");\n\n        _decreaseExposure(tokenManager, GLP_TOKEN_ADDRESS, _glpAmount);\n        _increaseExposure(tokenManager, _tokenOut, redeemedAmount);\n\n        emit GLPRedemption(\n            msg.sender,\n            redeemedTokenSymbol,\n            _glpAmount,\n            redeemedAmount,\n            block.timestamp\n        );\n\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /**\n     * @dev emitted after a GLP token mint\n     * @param user the address of user minting GLP\n     * @param tokenToMintWith token which GLP was minted with\n     * @param tokenToMintWithAmount amount of token used to mint GLP\n     * @param glpOutputAmount amount of GLP minted\n     * @param timestamp time of the mint\n     **/\n    event GLPMint(address indexed user, bytes32 indexed tokenToMintWith, uint256 tokenToMintWithAmount, uint256 glpOutputAmount, uint256 timestamp);\n\n    /**\n  * @dev emitted after a GLP token redemption\n  * @param user the address of user redeeming GLP\n  * @param redeemedToken token which GLP was redeemed into\n  * @param glpRedeemedAmount amount of GLP redeemed\n  * @param redeemedTokenAmount amount of redeemedToken redeemed\n  * @param timestamp time of the redemption\n  **/\n    event GLPRedemption(address indexed user, bytes32 indexed redeemedToken, uint256 glpRedeemedAmount, uint256 redeemedTokenAmount, uint256 timestamp);\n\n    /**\n    * @dev emitted after claiming GLP fees\n    * @param user the address of user claiming fees\n    * @param wavaxAmountClaimed amount of wavax fees that were claimed\n    * @param timestamp time of claiming the fees\n    **/\n    event GLPFeesClaim(address indexed user, uint256 wavaxAmountClaimed, uint256 timestamp);\n}\n"
    },
    "contracts/facets/avalanche/GMDFacet.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/facets/avalanche/IGMDFacet.sol\";\nimport \"../../interfaces/facets/IGMDVault.sol\";\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract GMDFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent{\n    using TransferHelper for address;\n\n    // CONSTANTS\n\n    address private constant GMDVaultAddress = 0x5517c5F22177BcF7b320A2A5daF2334344eFb38C;\n\n    // PUBLIC FUNCTIONS\n\n    function gmdStakeUSDC(uint256 amountStaked, uint256 minSharesOut) public {\n        IGMDFacet.StakingDetails memory position = IGMDFacet.StakingDetails({\n            asset : 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E,\n            receiptToken: 0x33f0a866d9024d44de2E0602f4C9B94755944B6F,\n            symbol : \"USDC\",\n            identifier : \"gmdUSDC\",\n            amountStaked: amountStaked,\n            minSharesOut: minSharesOut,\n            pid: 0\n        });\n        gmdStakeToken(position);\n    }\n\n    function gmdStakeAVAX(uint256 amountStaked, uint256 minSharesOut) public {\n        IGMDFacet.StakingDetails memory position = IGMDFacet.StakingDetails({\n            asset : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            receiptToken: 0x13AF25f924056d4D4668705C33aB9b70D505050e,\n            symbol : \"AVAX\",\n            identifier : \"gmdWAVAX\",\n            amountStaked: amountStaked,\n            minSharesOut: minSharesOut,\n            pid: 1\n        });\n        gmdStakeToken(position);\n    }\n\n    function gmdStakeBTCb(uint256 amountStaked, uint256 minSharesOut) public {\n        IGMDFacet.StakingDetails memory position = IGMDFacet.StakingDetails({\n            asset : 0x152b9d0FdC40C096757F570A51E494bd4b943E50,\n            receiptToken: 0x8fe3024351B9a51a3439183e940c2aF3994DD52F,\n            symbol : \"BTC\",\n            identifier : \"gmdBTCb\",\n            amountStaked: amountStaked,\n            minSharesOut: minSharesOut,\n            pid: 2\n        });\n        gmdStakeToken(position);\n    }\n\n    function gmdStakeWETHe(uint256 amountStaked, uint256 minSharesOut) public {\n        IGMDFacet.StakingDetails memory position = IGMDFacet.StakingDetails({\n            asset : 0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB,\n            receiptToken: 0xE28c95e9EB0f6D16b05D265cAa4BcEE9E5C2e625,\n            symbol : \"ETH\",\n            identifier : \"gmdWETHe\",\n            amountStaked: amountStaked,\n            minSharesOut: minSharesOut,\n            pid: 3\n        });\n        gmdStakeToken(position);\n    }\n\n    // PUBLIC FUNCTIONS\n\n    function gmdUnstakeUSDC(uint256 amountUnstaked, uint256 minTokenOut) public {\n        IGMDFacet.UnstakingDetails memory position = IGMDFacet.UnstakingDetails({\n            asset : 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E,\n            receiptToken: 0x33f0a866d9024d44de2E0602f4C9B94755944B6F,\n            symbol : \"USDC\",\n            identifier : \"gmdUSDC\",\n            amountUnstaked: amountUnstaked,\n            minTokenOut: minTokenOut,\n            pid: 0\n        });\n        gmdUnstakeToken(position);\n    }\n\n    function gmdUnstakeAVAX(uint256 amountUnstaked, uint256 minTokenOut) public {\n        IGMDFacet.UnstakingDetails memory position = IGMDFacet.UnstakingDetails({\n            asset : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            receiptToken: 0x13AF25f924056d4D4668705C33aB9b70D505050e,\n            symbol : \"AVAX\",\n            identifier : \"gmdWAVAX\",\n            amountUnstaked: amountUnstaked,\n            minTokenOut: minTokenOut,\n            pid: 1\n            });\n        gmdUnstakeToken(position);\n    }\n\n    function gmdUnstakeBTCb(uint256 amountUnstaked, uint256 minTokenOut) public {\n        IGMDFacet.UnstakingDetails memory position = IGMDFacet.UnstakingDetails({\n            asset : 0x152b9d0FdC40C096757F570A51E494bd4b943E50,\n            receiptToken: 0x8fe3024351B9a51a3439183e940c2aF3994DD52F,\n            symbol : \"BTC\",\n            identifier : \"gmdBTCb\",\n            amountUnstaked: amountUnstaked,\n            minTokenOut: minTokenOut,\n            pid: 2\n        });\n        gmdUnstakeToken(position);\n    }\n\n    function gmdUnstakeWETHe(uint256 amountUnstaked, uint256 minTokenOut) public {\n        IGMDFacet.UnstakingDetails memory position = IGMDFacet.UnstakingDetails({\n        asset : 0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB,\n        receiptToken: 0xE28c95e9EB0f6D16b05D265cAa4BcEE9E5C2e625,\n        symbol : \"ETH\",\n        identifier : \"gmdWETHe\",\n        amountUnstaked: amountUnstaked,\n        minTokenOut: minTokenOut,\n        pid: 3\n        });\n        gmdUnstakeToken(position);\n    }\n\n    // INTERNAL FUNCTIONS\n    /**\n    * Stakes token in GMD\n    * @dev This function uses the redstone-evm-connector\n    **/\n    function gmdStakeToken(IGMDFacet.StakingDetails memory position) internal\n    onlyOwner nonReentrant recalculateAssetsExposure remainsSolvent {\n        IGMDVault vault = IGMDVault(GMDVaultAddress);\n        IERC20Metadata stakedToken = getERC20TokenInstance(position.symbol, false);\n        IERC20Metadata receiptToken = IERC20Metadata(position.receiptToken);\n        uint256 initialReceiptTokenBalance = receiptToken.balanceOf(address(this));\n\n        uint256 amountStaked = Math.min(stakedToken.balanceOf(address(this)), position.amountStaked);\n        require(amountStaked > 0, \"Cannot stake 0 tokens\");\n\n        address(stakedToken).safeApprove(GMDVaultAddress, 0);\n        address(stakedToken).safeApprove(GMDVaultAddress, amountStaked);\n\n        vault.enter(amountStaked, position.pid);\n\n        uint256 sharesReceived = receiptToken.balanceOf(address(this)) - initialReceiptTokenBalance;\n        require(sharesReceived >= position.minSharesOut, \"Insufficient shares output\");\n\n        DiamondStorageLib.addOwnedAsset(position.identifier, position.receiptToken);\n        if (stakedToken.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(position.symbol);\n        }\n\n        emit Staked(\n            msg.sender,\n            position.symbol,\n            address(position.receiptToken),\n            amountStaked,\n            sharesReceived,\n            block.timestamp\n        );\n    }\n\n    /**\n    * Unstakes token from GMD\n    * IMPORTANT: This method can be used by anyone when a loan is insolvent. This operation can be gas-costly, that is why\n    * it may be necessary to perform it in a separate transaction to liquidation\n    * @dev This function uses the redstone-evm-connector\n    **/\n    function gmdUnstakeToken(IGMDFacet.UnstakingDetails memory position) internal\n    onlyOwnerOrInsolvent recalculateAssetsExposure nonReentrant {\n        IGMDVault vault = IGMDVault(GMDVaultAddress);\n        IERC20Metadata unstakedToken = getERC20TokenInstance(position.symbol, false);\n        IERC20Metadata receiptToken = IERC20Metadata(position.receiptToken);\n\n        uint256 amountUnstaked = Math.min(receiptToken.balanceOf(address(this)), position.amountUnstaked);\n        require(amountUnstaked > 0, \"Cannot unstake 0 tokens\");\n\n        uint256 initialUnstakedTokenBalance = unstakedToken.balanceOf(address(this));\n\n        vault.leave(amountUnstaked, position.pid);\n\n        uint256 receivedUnstakedToken = unstakedToken.balanceOf(address(this)) - initialUnstakedTokenBalance;\n        require(receivedUnstakedToken >= position.minTokenOut, \"Insufficient staked token output\");\n\n        if (receiptToken.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(position.identifier);\n        }\n        DiamondStorageLib.addOwnedAsset(position.symbol, address(unstakedToken));\n\n        emit Unstaked(\n            msg.sender,\n            position.symbol,\n            address(position.receiptToken),\n            receivedUnstakedToken,\n            amountUnstaked,\n            block.timestamp\n        );\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much of deposit token was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param asset the asset that was unstaked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much deposit token was unstaked\n        * @param receiptTokenAmount how much receipt token was redeemed\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n}\n"
    },
    "contracts/facets/avalanche/GmxV2CallbacksFacetAvalanche.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: cdd7894b30c3edf44909db362f20dc7fde0dab0c;\npragma solidity 0.8.27;\n\n//This path is updated during deployment\nimport \"../GmxV2CallbacksFacet.sol\";\n\ncontract GmxV2CallbacksFacetAvalanche is GmxV2CallbacksFacet {\n    using TransferHelper for address;\n\n    // https://github.com/gmx-io/gmx-synthetics/blob/main/deployments/avalanche/\n    // GMX contracts\n\n    function getGmxV2RoleStore() internal pure override returns (address) {\n        return 0xA44F830B6a2B6fa76657a3B92C1fe74fcB7C6AfD;\n    }\n\n    // Markets\n    address constant GM_BTC_BTCb_USDC = 0xFb02132333A79C8B5Bd0b64E3AbccA5f7fAf2937;\n    address constant GM_ETH_WETHe_USDC = 0xB7e69749E3d2EDd90ea59A4932EFEa2D41E245d7;\n    address constant GM_AVAX_WAVAX_USDC = 0x913C1F46b48b3eD35E7dc3Cf754d4ae8499F31CF;\n    address constant GM_BTC_BTCb = 0x3ce7BCDB37Bf587d1C17B930Fa0A7000A0648D12;\n    address constant GM_ETH_WETHe = 0x2A3Cf4ad7db715DF994393e4482D6f1e58a1b533;\n    address constant GM_AVAX_WAVAX = 0x08b25A2a89036d298D6dB8A74ace9d1ce6Db15E5;\n\n    // Tokens\n    address constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n    address constant BTCb = 0x152b9d0FdC40C096757F570A51E494bd4b943E50;\n    address constant WETHe = 0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB;\n    address constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    // Mappings\n    function marketToLongToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_BTC_BTCb_USDC || market == GM_BTC_BTCb) {\n            return BTCb;\n        } else if (market == GM_ETH_WETHe_USDC || market == GM_ETH_WETHe) {\n            return WETHe;\n        } else if (market == GM_AVAX_WAVAX_USDC || market == GM_AVAX_WAVAX) {\n            return WAVAX;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    function marketToShortToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_BTC_BTCb_USDC) {\n            return USDC;\n        } else if (market == GM_ETH_WETHe_USDC) {\n            return USDC;\n        } else if (market == GM_AVAX_WAVAX_USDC) {\n            return USDC;\n        } else if (market == GM_BTC_BTCb) {\n            return BTCb;\n        } else if (market == GM_ETH_WETHe) {\n            return WETHe;\n        } else if (market == GM_AVAX_WAVAX) {\n            return WAVAX;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n}\n"
    },
    "contracts/facets/avalanche/GmxV2FacetAvalanche.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 68a7a1350e896bfd8e6c0f457a678585d930a0bc;\npragma solidity 0.8.27;\n\n//This path is updated during deployment\nimport \"../GmxV2Facet.sol\";\n\ncontract GmxV2FacetAvalanche is GmxV2Facet {\n    using TransferHelper for address;\n\n    // https://github.com/gmx-io/gmx-synthetics/blob/main/deployments/avalanche/\n    // GMX contracts\n    function getGmxV2Router() internal pure override returns (address) {\n        return 0x820F5FfC5b525cD4d88Cd91aCf2c28F16530Cc68;\n    }\n\n    function getGmxV2ExchangeRouter() internal pure override returns (address) {\n        return 0x3BE24AED1a4CcaDebF2956e02C27a00726D4327d;\n    }\n\n    function getGmxV2DepositVault() internal pure override returns (address) {\n        return 0x90c670825d0C62ede1c5ee9571d6d9a17A722DFF;\n    }\n\n    function getGmxV2WithdrawalVault() internal pure override returns (address) {\n        return 0xf5F30B10141E1F63FC11eD772931A8294a591996;\n    }\n\n    // Markets\n    address constant GM_BTC_BTCb_USDC = 0xFb02132333A79C8B5Bd0b64E3AbccA5f7fAf2937;\n    address constant GM_ETH_WETHe_USDC = 0xB7e69749E3d2EDd90ea59A4932EFEa2D41E245d7;\n    address constant GM_AVAX_WAVAX_USDC = 0x913C1F46b48b3eD35E7dc3Cf754d4ae8499F31CF;\n\n    // Tokens\n    address constant USDC = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n    address constant BTCb = 0x152b9d0FdC40C096757F570A51E494bd4b943E50;\n    address constant WETHe = 0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB;\n    address constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    // Mappings\n    function marketToLongToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_BTC_BTCb_USDC) {\n            return BTCb;\n        } else if (market == GM_ETH_WETHe_USDC) {\n            return WETHe;\n        } else if (market == GM_AVAX_WAVAX_USDC) {\n            return WAVAX;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    function marketToShortToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_BTC_BTCb_USDC) {\n            return USDC;\n        } else if (market == GM_ETH_WETHe_USDC) {\n            return USDC;\n        } else if (market == GM_AVAX_WAVAX_USDC) {\n            return USDC;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    // DEPOSIT\n    function depositBtcUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? BTCb : USDC;\n\n        _deposit(\n            GM_BTC_BTCb_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositEthUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? WETHe : USDC;\n\n        _deposit(\n            GM_ETH_WETHe_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    function depositAvaxUsdcGmxV2(\n        bool isLongToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        address _depositedToken = isLongToken ? WAVAX : USDC;\n\n        _deposit(\n            GM_AVAX_WAVAX_USDC,\n            _depositedToken,\n            tokenAmount,\n            minGmAmount,\n            executionFee\n        );\n    }\n\n    // WITHDRAW\n    function withdrawBtcUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_BTC_BTCb_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawEthUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_ETH_WETHe_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawAvaxUsdcGmxV2(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_AVAX_WAVAX_USDC,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n}\n"
    },
    "contracts/facets/avalanche/GmxV2PlusFacetAvalanche.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c1391d85590ab530af967dbef6f857f87886a119;\npragma solidity 0.8.27;\n\n//This path is updated during deployment\nimport \"../GmxV2PlusFacet.sol\";\n\ncontract GmxV2PlusFacetAvalanche is GmxV2PlusFacet {\n    using TransferHelper for address;\n\n    // https://github.com/gmx-io/gmx-synthetics/blob/main/deployments/avalanche/\n    // GMX contracts\n    function getGmxV2Router() internal pure override returns (address) {\n        return 0x820F5FfC5b525cD4d88Cd91aCf2c28F16530Cc68;\n    }\n\n    function getGmxV2ExchangeRouter() internal pure override returns (address) {\n        return 0x3BE24AED1a4CcaDebF2956e02C27a00726D4327d;\n    }\n\n    function getGmxV2DepositVault() internal pure override returns (address) {\n        return 0x90c670825d0C62ede1c5ee9571d6d9a17A722DFF;\n    }\n\n    function getGmxV2WithdrawalVault() internal pure override returns (address) {\n        return 0xf5F30B10141E1F63FC11eD772931A8294a591996;\n    }\n\n    // Markets\n    address constant GM_BTC_BTCb = 0x3ce7BCDB37Bf587d1C17B930Fa0A7000A0648D12;\n    address constant GM_ETH_WETHe = 0x2A3Cf4ad7db715DF994393e4482D6f1e58a1b533;\n    address constant GM_AVAX_WAVAX = 0x08b25A2a89036d298D6dB8A74ace9d1ce6Db15E5;\n\n    // Tokens\n    address constant BTCb = 0x152b9d0FdC40C096757F570A51E494bd4b943E50;\n    address constant WETHe = 0x49D5c2BdFfac6CE2BFdB6640F4F80f226bc10bAB;\n    address constant WAVAX = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    // Mappings\n    function marketToToken(\n        address market\n    ) internal pure override returns (address) {\n        if (market == GM_BTC_BTCb) {\n            return BTCb;\n        } else if (market == GM_ETH_WETHe) {\n            return WETHe;\n        } else if (market == GM_AVAX_WAVAX) {\n            return WAVAX;\n        } else {\n            revert(\"Market not supported\");\n        }\n    }\n\n    // DEPOSIT\n    function depositBtcGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        _deposit(GM_BTC_BTCb, tokenAmount, minGmAmount, executionFee);\n    }\n\n    function depositEthGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        _deposit(GM_ETH_WETHe, tokenAmount, minGmAmount, executionFee);\n    }\n\n    function depositAvaxGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable {\n        _deposit(GM_AVAX_WAVAX, tokenAmount, minGmAmount, executionFee);\n    }\n\n    // WITHDRAW\n    function withdrawBtcGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_BTC_BTCb,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawEthGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_ETH_WETHe,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n\n    function withdrawAvaxGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable {\n        _withdraw(\n            GM_AVAX_WAVAX,\n            gmAmount,\n            minLongTokenAmount,\n            minShortTokenAmount,\n            executionFee\n        );\n    }\n}\n"
    },
    "contracts/facets/avalanche/GogoPoolFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 499a35c62f8a913d89f7faf78bf5c6b3cea2ee8b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../lib/SolvencyMethods.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\nimport \"../../interfaces/IGgAvax.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract GogoPoolFacet is ReentrancyGuardKeccak, SolvencyMethods {\n    using TransferHelper for address;\n\n    address private constant GG_AVAX =\n        0xA25EaF2906FA1a3a13EdAc9B9657108Af7B703e3;\n\n    function swapToGgAvax(uint256 _amount)\n        external\n        nonReentrant\n        onlyOwner\n        remainsSolvent\n    {\n        IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        _amount = Math.min(wrapped.balanceOf(address(this)), _amount);\n        require(_amount > 0, \"Amount has to be greater than 0\");\n\n        wrapped.withdraw(_amount);\n\n        uint256 initialGgAvaxBalance = IERC20(GG_AVAX).balanceOf(address(this));\n\n        IGgAvax ggAvax = IGgAvax(GG_AVAX);\n        ggAvax.depositAVAX{value: _amount}();\n\n        _increaseExposure(tokenManager, GG_AVAX, IERC20(GG_AVAX).balanceOf(address(this)) - initialGgAvaxBalance);\n        _decreaseExposure(tokenManager, address(wrapped), _amount);\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n}\n"
    },
    "contracts/facets/avalanche/PangolinDEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 499a35c62f8a913d89f7faf78bf5c6b3cea2ee8b;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2DEXFacet.sol\";\n\ncontract PangolinDEXFacet is UniswapV2DEXFacet {\n    function getProtocolID() pure internal override returns (bytes32) {\n        return \"PNG\";\n    }\n\n    /**\n      * Swaps one asset to another\n      * @dev This function uses the redstone-evm-connector\n      * @param _soldAsset asset to be sold\n      * @param _boughtAsset asset to be bought\n      * @param _exactSold exact amount of asset to be sold\n      * @param _minimumBought minimum amount of asset to be bought\n    **/\n    function swapPangolin(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) public noBorrowInTheSameBlock onlyOwner returns (uint256[] memory) {\n        return swapAssets(_soldAsset, _boughtAsset, _exactSold, _minimumBought);\n    }\n\n    function addLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) public onlyOwner {\n        addLiquidity(_firstAsset, _secondAsset, amountADesired, amountBDesired, amountAMin, amountBMin);\n    }\n\n    //onlOwnerOrInsolvent inside UniswapDexFacet\n    function removeLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) public {\n        removeLiquidity(_firstAsset, _secondAsset, liquidity, amountAMin, amountBMin);\n    }\n\n    /**\n     * Returns address of UniswapV2-like exchange\n     **/\n    function getExchangeIntermediaryContract() public override returns (address) {\n        return 0xdB5D94B8Ed491B058F3e74D029775A14477cF7fA;\n    }\n}"
    },
    "contracts/facets/avalanche/SolvencyFacetProdAvalanche.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: e66c63a5228df2ecc68f8d8adb7254dac9157341;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@redstone-finance/evm-connector/contracts/data-services/AvalancheDataServiceConsumerBase.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\nimport \"../../Pool.sol\";\nimport \"../SolvencyFacetProd.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../interfaces/facets/avalanche/ITraderJoeV2Facet.sol\";\nimport \"../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\nimport {PriceHelper} from \"../../lib/joe-v2/PriceHelper.sol\";\nimport {Uint256x256Math} from \"../../lib/joe-v2/math/Uint256x256Math.sol\";\nimport {TickMath} from \"../../lib/uniswap-v3/TickMath.sol\";\nimport {FullMath} from \"../../lib/uniswap-v3/FullMath.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../../interfaces/facets/avalanche/IUniswapV3Facet.sol\";\n\ncontract SolvencyFacetProdAvalanche is SolvencyFacetProd {\n    function getDataServiceId() public view virtual override returns (string memory) {\n        return \"redstone-avalanche-prod\";\n    }\n\n    function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n        return 3;\n    }\n\n    function getAuthorisedSignerIndex(\n        address signerAddress\n    ) public view virtual override returns (uint8) {\n        if (signerAddress == 0x1eA62d73EdF8AC05DfceA1A34b9796E937a29EfF) {\n            return 0;\n        } else if (signerAddress == 0x2c59617248994D12816EE1Fa77CE0a64eEB456BF) {\n            return 1;\n        } else if (signerAddress == 0x12470f7aBA85c8b81D63137DD5925D6EE114952b) {\n            return 2;\n        } else if (signerAddress == 0x109B4a318A4F5ddcbCA6349B45f881B4137deaFB) {\n            return 3;\n        } else if (signerAddress == 0x83cbA8c619fb629b81A65C2e67fE15cf3E3C9747) {\n            return 4;\n        } else {\n            revert SignerNotAuthorised(signerAddress);\n        }\n    }\n}\n"
    },
    "contracts/facets/avalanche/SteakHutFinanceFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2fb058fa4d8089fcdc61eecc5d098914722a8f02;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\nimport \"../../interfaces/facets/avalanche/ISteakHutPool.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract SteakHutFinanceFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    /**\n     * Stakes in SteakHut JOE/AVAX balanced-wide pool\n     * @param amount0Desired amount of JOE to be staked\n     * @param amount1Desired amount of AVAX to be staked\n     * @param amount0Min minimum amount of JOE to be staked\n     * @param amount1Min minimum amount of AVAX to be staked\n     **/\n    function stakeSteakHutJOEAVAX(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external {\n        _stakeTokenSteakHut(ISteakHutPool.StakingDetails({\n            token0Symbol: \"JOE\",\n            token1Symbol: \"AVAX\",\n            vaultTokenSymbol: \"SHLB_JOE-AVAX_B\",\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Unstakes from SteakHut JOE/AVAX balanced-wide pool\n     * @param liquidity amount of shares to be unstaked\n     * @param amount0Min minimum amount of JOE to be unstaked\n     * @param amount1Min minimum amount of AVAX to be unstaked\n     **/\n    function unstakeSteakHutJOEAVAX(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external {\n        _unstakeTokenSteakHut(ISteakHutPool.UnstakingDetails({\n            token0Symbol: \"JOE\",\n            token1Symbol: \"AVAX\",\n            vaultTokenSymbol: \"SHLB_JOE-AVAX_B\",\n            liquidity: liquidity,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Stakes in SteakHut EUROC/USDC balanced-wide pool\n     * @param amount0Desired amount of EUROC to be staked\n     * @param amount1Desired amount of USDC to be staked\n     * @param amount0Min minimum amount of EUROC to be staked\n     * @param amount1Min minimum amount of USDC to be staked\n     **/\n    function stakeSteakHutEUROCUSDC(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external {\n        _stakeTokenSteakHut(ISteakHutPool.StakingDetails({\n            token0Symbol: \"EUROC\",\n            token1Symbol: \"USDC\",\n            vaultTokenSymbol: \"SHLB_EUROC-USDC_V2_1_B\",\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Unstakes from SteakHut EUROC/USDC balanced-wide pool\n     * @param liquidity amount of shares to be unstaked\n     * @param amount0Min minimum amount of EUROC to be unstaked\n     * @param amount1Min minimum amount of USDC to be unstaked\n     **/\n    function unstakeSteakHutEUROCUSDC(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external {\n        _unstakeTokenSteakHut(ISteakHutPool.UnstakingDetails({\n            token0Symbol: \"EUROC\",\n            token1Symbol: \"USDC\",\n            vaultTokenSymbol: \"SHLB_EUROC-USDC_V2_1_B\",\n            liquidity: liquidity,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Stakes in SteakHut AVAX/USDC balanced-wide pool\n     * @param amount0Desired amount of AVAX to be staked\n     * @param amount1Desired amount of USDC to be staked\n     * @param amount0Min minimum amount of AVAX to be staked\n     * @param amount1Min minimum amount of USDC to be staked\n     **/\n    function stakeSteakHutAVAXUSDC(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external {\n        _stakeTokenSteakHut(ISteakHutPool.StakingDetails({\n            token0Symbol: \"AVAX\",\n            token1Symbol: \"USDC\",\n            vaultTokenSymbol: \"SHLB_AVAX-USDC_B\",\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Unstakes from SteakHut AVAX/USDC balanced-wide pool\n     * @param liquidity amount of shares to be unstaked\n     * @param amount0Min minimum amount of AVAX to be unstaked\n     * @param amount1Min minimum amount of USDC to be unstaked\n     **/\n    function unstakeSteakHutAVAXUSDC(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external {\n        _unstakeTokenSteakHut(ISteakHutPool.UnstakingDetails({\n            token0Symbol: \"AVAX\",\n            token1Symbol: \"USDC\",\n            vaultTokenSymbol: \"SHLB_AVAX-USDC_B\",\n            liquidity: liquidity,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Stakes in SteakHut BTC/AVAX balanced-wide pool\n     * @param amount0Desired amount of BTC to be staked\n     * @param amount1Desired amount of AVAX to be staked\n     * @param amount0Min minimum amount of BTC to be staked\n     * @param amount1Min minimum amount of AVAX to be staked\n     **/\n    function stakeSteakHutBTCAVAX(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external {\n        _stakeTokenSteakHut(ISteakHutPool.StakingDetails({\n            token0Symbol: \"BTC\",\n            token1Symbol: \"AVAX\",\n            vaultTokenSymbol: \"SHLB_BTC.b-AVAX_B\",\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Unstakes from SteakHut BTC/AVAX balanced-wide pool\n     * @param liquidity amount of shares to be unstaked\n     * @param amount0Min minimum amount of BTC to be unstaked\n     * @param amount1Min minimum amount of AVAX to be unstaked\n     **/\n    function unstakeSteakHutBTCAVAX(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external {\n        _unstakeTokenSteakHut(ISteakHutPool.UnstakingDetails({\n            token0Symbol: \"BTC\",\n            token1Symbol: \"AVAX\",\n            vaultTokenSymbol: \"SHLB_BTC.b-AVAX_B\",\n            liquidity: liquidity,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Stakes in SteakHut USDT.e/USDT concentrated pool\n     * @param amount0Desired amount of USDT.e to be staked\n     * @param amount1Desired amount of USDT to be staked\n     * @param amount0Min minimum amount of USDT.e to be staked\n     * @param amount1Min minimum amount of USDT to be staked\n     **/\n    function stakeSteakHutUSDTeUSDT(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external {\n        _stakeTokenSteakHut(ISteakHutPool.StakingDetails({\n            token0Symbol: \"USDT.e\",\n            token1Symbol: \"USDT\",\n            vaultTokenSymbol: \"SHLB_USDT.e-USDt_C\",\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Unstakes from SteakHut USDT.e/USDT concentrated pool\n     * @param liquidity amount of shares to be unstaked\n     * @param amount0Min minimum amount of USDT.e to be unstaked\n     * @param amount1Min minimum amount of USDT to be unstaked\n     **/\n    function unstakeSteakHutUSDTeUSDT(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external {\n        _unstakeTokenSteakHut(ISteakHutPool.UnstakingDetails({\n            token0Symbol: \"USDT.e\",\n            token1Symbol: \"USDT\",\n            vaultTokenSymbol: \"SHLB_USDT.e-USDt_C\",\n            liquidity: liquidity,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    // ----- PRIVATE METHODS -----\n\n    /**\n     * Stakes {stakingDetails.token0Address}, {stakingDetails.token1Address} token in the SteakHut pool\n     * @param stakingDetails ISteakHutPool.StakingDetails staking details\n     **/\n    function _stakeTokenSteakHut(ISteakHutPool.StakingDetails memory stakingDetails) private nonReentrant onlyOwner recalculateAssetsExposure remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address vaultAddress = tokenManager.getAssetAddress(stakingDetails.vaultTokenSymbol, false);\n        IERC20 vaultToken = IERC20(vaultAddress);\n        uint256 initialVaultBalance = vaultToken.balanceOf(address(this));\n\n        IERC20 token0 = IERC20(tokenManager.getAssetAddress(stakingDetails.token0Symbol, false));\n        IERC20 token1 = IERC20(tokenManager.getAssetAddress(stakingDetails.token1Symbol, false));\n\n        stakingDetails.amount0Desired = Math.min(token0.balanceOf(address(this)), stakingDetails.amount0Desired);\n        stakingDetails.amount1Desired = Math.min(token1.balanceOf(address(this)), stakingDetails.amount1Desired);\n        require(stakingDetails.amount0Desired > 0 && stakingDetails.amount1Desired > 0, \"Cannot stake 0 tokens\");\n\n        address(token0).safeApprove(vaultAddress, 0);\n        address(token0).safeApprove(vaultAddress, stakingDetails.amount0Desired);\n        address(token1).safeApprove(vaultAddress, 0);\n        address(token1).safeApprove(vaultAddress, stakingDetails.amount1Desired);\n        (, uint256 amount0Actual, uint256 amount1Actual) = ISteakHutPool(vaultAddress).deposit(stakingDetails.amount0Desired, stakingDetails.amount1Desired, stakingDetails.amount0Min, stakingDetails.amount1Min);\n\n        // Add/remove owned tokens\n        DiamondStorageLib.addOwnedAsset(stakingDetails.vaultTokenSymbol, vaultAddress);\n        if(token0.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(stakingDetails.token0Symbol);\n        }\n        if(token1.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(stakingDetails.token1Symbol);\n        }\n\n        emit Staked(\n            msg.sender,\n            stakingDetails.token0Symbol,\n            stakingDetails.token1Symbol,\n            vaultAddress,\n            amount0Actual,\n            amount1Actual,\n            vaultToken.balanceOf(address(this)) - initialVaultBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Unstakes {UnstakingDetails.token0Address}, {UnstakingDetails.token1Address} token from the SteakHut pool\n     * @param unstakingDetails ISteakHutPool.UnstakingDetails unstaking details\n     **/\n    function _unstakeTokenSteakHut(ISteakHutPool.UnstakingDetails memory unstakingDetails) private nonReentrant onlyOwnerOrInsolvent recalculateAssetsExposure {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address vaultAddress = tokenManager.getAssetAddress(unstakingDetails.vaultTokenSymbol, true);\n        uint256 vaultTokenBalance = IERC20(vaultAddress).balanceOf(address(this));\n\n        uint256 amount0Unstaked;\n        uint256 amount1Unstaked;\n        {\n            IERC20 depositToken0 = IERC20(tokenManager.getAssetAddress(unstakingDetails.token0Symbol, false));\n            IERC20 depositToken1 = IERC20(tokenManager.getAssetAddress(unstakingDetails.token1Symbol, false));\n            {\n                uint256 initialDepositTokenBalance0 = depositToken0.balanceOf(address(this));\n                uint256 initialDepositTokenBalance1 = depositToken1.balanceOf(address(this));\n                unstakingDetails.liquidity = Math.min(IERC20(vaultAddress).balanceOf(address(this)), unstakingDetails.liquidity);\n\n                ISteakHutPool(vaultAddress).withdraw(unstakingDetails.liquidity);\n\n                amount0Unstaked = depositToken0.balanceOf(address(this)) - initialDepositTokenBalance0;\n                amount1Unstaked = depositToken1.balanceOf(address(this)) - initialDepositTokenBalance1;\n                require(amount0Unstaked >= unstakingDetails.amount0Min && amount1Unstaked >= unstakingDetails.amount1Min, \"Unstaked less tokens than expected\");\n            }\n\n            // Add/remove owned tokens\n            DiamondStorageLib.addOwnedAsset(unstakingDetails.token0Symbol, address(depositToken0));\n            DiamondStorageLib.addOwnedAsset(unstakingDetails.token1Symbol, address(depositToken1));\n        }\n        uint256 newVaultTokenBalance = IERC20(vaultAddress).balanceOf(address(this));\n        if(newVaultTokenBalance == 0) {\n            DiamondStorageLib.removeOwnedAsset(unstakingDetails.vaultTokenSymbol);\n        }\n\n        emit Unstaked(\n            msg.sender,\n            unstakingDetails.token0Symbol,\n            unstakingDetails.token1Symbol,\n            vaultAddress,\n            amount0Unstaked,\n            amount1Unstaked,\n            vaultTokenBalance - newVaultTokenBalance,\n            block.timestamp\n        );\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset0 the asset that was unstaked\n        * @param asset1 the asset that was unstaked\n        * @param vault address of the vault token\n        * @param depositTokenAmount0 how much deposit token0 was received\n        * @param depositTokenAmount1 how much deposit token1 was received\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 asset0, bytes32 asset1, address indexed vault, uint256 depositTokenAmount0, uint256 depositTokenAmount1, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param vault address of the vault token\n        * @param asset0 the asset that was unstaked\n        * @param asset1 the asset that was unstaked\n        * @param depositTokenAmount0 how much deposit token0 was received\n        * @param depositTokenAmount1 how much deposit token1 was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 asset0, bytes32 asset1, address indexed vault, uint256 depositTokenAmount0, uint256 depositTokenAmount1, uint256 receiptTokenAmount, uint256 timestamp);\n}\n"
    },
    "contracts/facets/avalanche/TraderJoeDEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 991f66d82490413f8ba0b6c862ef5c28302bb6ad;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2DEXFacet.sol\";\n\ncontract TraderJoeDEXFacet is UniswapV2DEXFacet {\n    function getProtocolID() pure internal override returns (bytes32) {\n        return \"TJ\";\n    }\n\n    /**\n      * Swaps one asset to another\n      * @dev This function uses the redstone-evm-connector\n      * @param _soldAsset asset to be sold\n      * @param _boughtAsset asset to be bought\n      * @param _exactSold exact amount of asset to be sold\n      * @param _minimumBought minimum amount of asset to be bought\n    **/\n    function swapTraderJoe(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) public noBorrowInTheSameBlock onlyOwner returns (uint256[] memory) {\n        return swapAssets(_soldAsset, _boughtAsset, _exactSold, _minimumBought);\n    }\n\n    function addLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) public onlyOwner {\n        addLiquidity(_firstAsset, _secondAsset, amountADesired, amountBDesired, amountAMin, amountBMin);\n    }\n\n    //onlOwnerOrInsolvent inside UniswapDexFacet\n    function removeLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) public {\n        removeLiquidity(_firstAsset, _secondAsset, liquidity, amountAMin, amountBMin);\n    }\n\n    /**\n     * Returns address of UniswapV2-like exchange\n     **/\n    function getExchangeIntermediaryContract() public override returns (address) {\n        return 0x4eEcb72b47a32786e08581D6226e95d9AE3bB1Af;\n    }\n}"
    },
    "contracts/facets/avalanche/TraderJoeV2AutopoolsFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: a33c92df6b73b24f43fe2acf6c3faf2d4ed3e03c;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\nimport \"../../interfaces/facets/avalanche/ITraderJoeV2Autopool.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../../interfaces/facets/avalanche/ITraderJoeV2AutopoolsFacet.sol\";\n\ncontract TraderJoeV2AutopoolsFacet is ITraderJoeV2AutopoolsFacet, ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    /**\n     * Stakes in TraderJoe V2 AVAX/USDC auto-pool\n     * @param amount0Desired amount of AVAX to be staked\n     * @param amount1Desired amount of USDC to be staked\n     * @param amount0Min minimum amount of AVAX to be staked\n     * @param amount1Min minimum amount of USDC to be staked\n     **/\n    function stakeTraderJoeV2AutopoolAVAXUSDC(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external {\n        stakeTokenTraderJoeV2Autopool(ITraderJoeV2Autopool.StakingDetails({\n            token0Symbol: \"AVAX\",\n            token1Symbol: \"USDC\",\n            vaultTokenSymbol: \"TJ_AVAX_USDC_AUTO\",\n            amount0Desired: amount0Desired,\n            amount1Desired: amount1Desired,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    /**\n     * Unstakes from SteakHut AVAX/USDC balanced-wide pool\n     * @param liquidity amount of shares to be unstaked\n     * @param amount0Min minimum amount of AVAX to be unstaked\n     * @param amount1Min minimum amount of USDC to be unstaked\n     **/\n    function unstakeTraderJoeV2AutopoolAVAXUSDC(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external {\n        unstakeTokenTraderJoeV2Autopool(ITraderJoeV2Autopool.UnstakingDetails({\n            token0Symbol: \"AVAX\",\n            token1Symbol: \"USDC\",\n            vaultTokenSymbol: \"TJ_AVAX_USDC_AUTO\",\n            liquidity: liquidity,\n            amount0Min: amount0Min,\n            amount1Min: amount1Min\n        }));\n    }\n\n    // ----- PRIVATE METHODS -----\n\n    /**\n     * Stakes {stakingDetails.token0Address}, {stakingDetails.token1Address} token in the SteakHut pool\n     * @param stakingDetails ITraderJoeV2Autopool.StakingDetails staking details\n     **/\n    function stakeTokenTraderJoeV2Autopool(ITraderJoeV2Autopool.StakingDetails memory stakingDetails) private nonReentrant onlyOwner remainsSolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address vaultAddress = tokenManager.getAssetAddress(stakingDetails.vaultTokenSymbol, false);\n        IERC20 vaultToken = IERC20(vaultAddress);\n        uint256 initialVaultBalance = vaultToken.balanceOf(address(this));\n\n        IERC20 token0 = IERC20(tokenManager.getAssetAddress(stakingDetails.token0Symbol, false));\n        IERC20 token1 = IERC20(tokenManager.getAssetAddress(stakingDetails.token1Symbol, false));\n\n        stakingDetails.amount0Desired = Math.min(token0.balanceOf(address(this)), stakingDetails.amount0Desired);\n        stakingDetails.amount1Desired = Math.min(token1.balanceOf(address(this)), stakingDetails.amount1Desired);\n        require(stakingDetails.amount0Desired > 0 && stakingDetails.amount1Desired > 0, \"Cannot stake 0 tokens\");\n\n        address(token0).safeApprove(vaultAddress, 0);\n        address(token0).safeApprove(vaultAddress, stakingDetails.amount0Desired);\n        address(token1).safeApprove(vaultAddress, 0);\n        address(token1).safeApprove(vaultAddress, stakingDetails.amount1Desired);\n        (, uint256 amount0Actual, uint256 amount1Actual) = ITraderJoeV2Autopool(vaultAddress).deposit(stakingDetails.amount0Desired, stakingDetails.amount1Desired);\n\n        //TODO: difference to Steakhut\n        require(amount0Actual >= stakingDetails.amount0Min && amount1Actual >= stakingDetails.amount1Min, \"Staked less tokens than expected\");\n\n        _decreaseExposure(tokenManager, address(token0), amount0Actual);\n        _decreaseExposure(tokenManager, address(token1), amount1Actual);\n\n        uint256 vaultTokenReceived = vaultToken.balanceOf(address(this)) - initialVaultBalance;\n        _increaseExposure(tokenManager, address(vaultToken), vaultTokenReceived);\n\n        emit Staked(\n            msg.sender,\n            stakingDetails.token0Symbol,\n            stakingDetails.token1Symbol,\n            vaultAddress,\n            amount0Actual,\n            amount1Actual,\n            vaultTokenReceived,\n            block.timestamp\n        );\n    }\n\n    /**\n     * Unstakes {UnstakingDetails.token0Address}, {UnstakingDetails.token1Address} token from the SteakHut pool\n     * @param unstakingDetails ITraderJoeV2Autopool.UnstakingDetails unstaking details\n     **/\n    function unstakeTokenTraderJoeV2Autopool(ITraderJoeV2Autopool.UnstakingDetails memory unstakingDetails) private nonReentrant onlyOwnerOrInsolvent {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address vaultAddress = tokenManager.getAssetAddress(unstakingDetails.vaultTokenSymbol, true);\n        uint256 vaultTokenBalance = IERC20(vaultAddress).balanceOf(address(this));\n\n        uint256 amount0Unstaked;\n        uint256 amount1Unstaked;\n        {\n            IERC20 depositToken0 = IERC20(tokenManager.getAssetAddress(unstakingDetails.token0Symbol, false));\n            IERC20 depositToken1 = IERC20(tokenManager.getAssetAddress(unstakingDetails.token1Symbol, false));\n            {\n                uint256 initialDepositTokenBalance0 = depositToken0.balanceOf(address(this));\n                uint256 initialDepositTokenBalance1 = depositToken1.balanceOf(address(this));\n                unstakingDetails.liquidity = Math.min(IERC20(vaultAddress).balanceOf(address(this)), unstakingDetails.liquidity);\n\n                //TODO: replace with the immediate withdrawal, that code CAN'T GO TO PROD\n                ITraderJoeV2Autopool(vaultAddress).queueWithdrawal(unstakingDetails.liquidity, address(this));\n\n                amount0Unstaked = depositToken0.balanceOf(address(this)) - initialDepositTokenBalance0;\n                amount1Unstaked = depositToken1.balanceOf(address(this)) - initialDepositTokenBalance1;\n                require(amount0Unstaked >= unstakingDetails.amount0Min && amount1Unstaked >= unstakingDetails.amount1Min, \"Unstaked less tokens than expected\");\n            }\n            _increaseExposure(tokenManager, address(depositToken0), amount0Unstaked);\n            _increaseExposure(tokenManager, address(depositToken1), amount1Unstaked);\n        }\n        uint256 newVaultTokenBalance = IERC20(vaultAddress).balanceOf(address(this));\n\n        _decreaseExposure(tokenManager, vaultAddress, vaultTokenBalance - newVaultTokenBalance);\n\n        emit Unstaked(\n            msg.sender,\n            unstakingDetails.token0Symbol,\n            unstakingDetails.token1Symbol,\n            vaultAddress,\n            amount0Unstaked,\n            amount1Unstaked,\n            vaultTokenBalance - newVaultTokenBalance,\n            block.timestamp\n        );\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset0 the asset that was unstaked\n        * @param asset1 the asset that was unstaked\n        * @param vault address of the vault token\n        * @param depositTokenAmount0 how much deposit token0 was received\n        * @param depositTokenAmount1 how much deposit token1 was received\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 asset0, bytes32 asset1, address indexed vault, uint256 depositTokenAmount0, uint256 depositTokenAmount1, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param vault address of the vault token\n        * @param asset0 the asset that was unstaked\n        * @param asset1 the asset that was unstaked\n        * @param depositTokenAmount0 how much deposit token0 was received\n        * @param depositTokenAmount1 how much deposit token1 was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 asset0, bytes32 asset1, address indexed vault, uint256 depositTokenAmount0, uint256 depositTokenAmount1, uint256 receiptTokenAmount, uint256 timestamp);\n}\n"
    },
    "contracts/facets/avalanche/TraderJoeV2AvalancheFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../TraderJoeV2Facet.sol\";\n\ncontract TraderJoeV2AvalancheFacet is TraderJoeV2Facet {\n    function maxBinsPerPrimeAccount() public pure override returns (uint256) {\n        return 80;\n    }\n\n    function getWhitelistedTraderJoeV2Pairs() internal pure override returns (ILBPair[] memory pools) {\n        pools = new ILBPair[](6);\n        // TJLB_WAVAX_USDC\n        pools[0] = ILBPair(0xD446eb1660F766d533BeCeEf890Df7A69d26f7d1);\n        // TJLB_WETH.e_WAVAX\n        pools[1] = ILBPair(0x1901011a39B11271578a1283D620373aBeD66faA);\n        // TJLB_BTCb_WAVAX\n        pools[2] = ILBPair(0xD9fa522F5BC6cfa40211944F2C8DA785773Ad99D);\n        // TJLB_USDt_USDC\n        pools[3] = ILBPair(0x2823299af89285fF1a1abF58DB37cE57006FEf5D);\n        // TJLB_JOE_WAVAX\n        pools[4] = ILBPair(0xEA7309636E7025Fda0Ee2282733Ea248c3898495);\n        // TJ_WETH.e_BTC.b\n        pools[5] = ILBPair(0x632349B44Af299Ab83cB9F21F65c218122fD4772);\n    }\n}\n"
    },
    "contracts/facets/avalanche/UniswapV3Facet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/joe-v2/ILBRouter.sol\";\nimport \"../../interfaces/joe-v2/ILBFactory.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../lib/uniswap-v3/OracleLibrary.sol\";\nimport \"@redstone-finance/evm-connector/contracts/data-services/AvalancheDataServiceConsumerBase.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\ncontract UniswapV3Facet is IUniswapV3Facet, AvalancheDataServiceConsumerBase, ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n\n    address private constant NONFUNGIBLE_POSITION_MANAGER_ADDRESS = 0x655C406EBFa14EE2006250925e54ec43AD184f8B;\n    address private constant UNISWAP_V3_FACTORY_ADDRESS = 0x740b1c1de25031C31FF4fC9A62f554A55cdC1baD;\n    uint256 public constant ACCEPTED_UNISWAP_SLIPPAGE = 0.05e18;\n\n    using TransferHelper for address;\n\n    uint256 constant MAX_OWNED_UNISWAP_V3_POSITIONS = 100; //TODO: dummy number, update after running gas tests\n\n    function getTokenIds() internal returns (uint256[] storage result){\n        return DiamondStorageLib.getUV3OwnedTokenIds();\n    }\n\n    function getOwnedUniswapV3TokenIds() public view returns (uint256[] memory result){\n        return DiamondStorageLib.getUV3OwnedTokenIdsView();\n    }\n\n    function getWhitelistedUniswapV3Pools() internal view returns (IUniswapV3Pool[2] memory pools){\n        return [\n            IUniswapV3Pool(0xfAe3f424a0a47706811521E3ee268f00cFb5c45E),\n            IUniswapV3Pool(0x7b602f98D71715916E7c963f51bfEbC754aDE2d0)\n        ];\n    }\n\n    //TODO: optimize it (mapping?)\n    function isPoolWhitelisted(address pool) internal view returns (bool){\n        IUniswapV3Pool[2] memory pools = getWhitelistedUniswapV3Pools();\n\n        for (uint i; i < pools.length; ++i) {\n            if (pool == address(pools[i])) return true;\n        }\n        return false;\n    }\n\n    function mintLiquidityUniswapV3(INonfungiblePositionManager.MintParams memory params) external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent {\n        address poolAddress = PoolAddress.computeAddress(UNISWAP_V3_FACTORY_ADDRESS, PoolAddress.getPoolKey(params.token0, params.token1, params.fee));\n\n        if (!isPoolWhitelisted(poolAddress)) revert UniswapV3PoolNotWhitelisted();\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        bytes32 token0 = tokenManager.tokenAddressToSymbol(address(params.token0));\n        bytes32 token1 = tokenManager.tokenAddressToSymbol(address(params.token1));\n\n        params.recipient = address(this);\n\n        {\n            //TODO: write tests for that\n\n            bytes32[] memory symbols = new bytes32[](2);\n\n            symbols[0] = token0;\n            symbols[1] = token1;\n\n            uint256[] memory prices = getOracleNumericValuesFromTxMsg(symbols);\n            (,int24 tick,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n            uint256 poolPrice = OracleLibrary.getQuoteAtTick(tick, uint128(10 ** IERC20Metadata(params.token0).decimals()), params.token0, params.token1);\n            uint256 oraclePrice = prices[0] * (10 ** IERC20Metadata(params.token1).decimals()) / prices[1];\n\n            if (oraclePrice > poolPrice) {\n                if ((oraclePrice - poolPrice) * 1e18 / oraclePrice > ACCEPTED_UNISWAP_SLIPPAGE) revert SlippageTooHigh();\n            } else {\n                if ((poolPrice - oraclePrice) * 1e18 / oraclePrice > ACCEPTED_UNISWAP_SLIPPAGE) revert SlippageTooHigh();\n            }\n        }\n\n        address(params.token0).safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), 0);\n        address(params.token1).safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), 0);\n\n        address(params.token0).safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), params.amount0Desired);\n        address(params.token1).safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), params.amount1Desired);\n\n        (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        ) = INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS).mint(params);\n\n        {\n            uint256[] storage tokenIds = DiamondStorageLib.getUV3OwnedTokenIds();\n            if (tokenIds.length >= MAX_OWNED_UNISWAP_V3_POSITIONS) revert TooManyUniswapV3Positions();\n            tokenIds.push(tokenId);\n        }\n\n        _decreaseExposure(tokenManager, params.token0, amount0);\n        _decreaseExposure(tokenManager, params.token1, amount1);\n\n        emit AddLiquidityUniswapV3(msg.sender, poolAddress, tokenId, token0, token1, liquidity, amount0, amount1, block.timestamp);\n    }\n\n    function increaseLiquidityUniswapV3(INonfungiblePositionManager.IncreaseLiquidityParams memory params) external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent {\n        (\n        ,,\n        address token0Address,\n        address token1Address,\n        uint24 fee,\n        ,,,,,,\n        ) = INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS).positions(params.tokenId);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        bytes32 token0 = tokenManager.tokenAddressToSymbol(token0Address);\n        bytes32 token1 = tokenManager.tokenAddressToSymbol(token1Address);\n\n        address poolAddress = PoolAddress.computeAddress(UNISWAP_V3_FACTORY_ADDRESS, PoolAddress.getPoolKey(token0Address, token1Address, fee));\n\n        if (!isPoolWhitelisted(poolAddress)) revert UniswapV3PoolNotWhitelisted();\n\n        {\n            bytes32[] memory symbols = new bytes32[](2);\n\n            symbols[0] = token0;\n            symbols[1] = token1;\n\n            uint256[] memory prices = getOracleNumericValuesFromTxMsg(symbols);\n            (,int24 tick,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n            uint256 poolPrice = OracleLibrary.getQuoteAtTick(tick, uint128(10 ** IERC20Metadata(token0Address).decimals()), token0Address, token1Address);\n            uint256 oraclePrice = prices[0] * (10 ** IERC20Metadata(token1Address).decimals()) / prices[1];\n\n\n            if (oraclePrice > poolPrice) {\n                if ((oraclePrice - poolPrice) * 1e18 / oraclePrice > ACCEPTED_UNISWAP_SLIPPAGE) revert SlippageTooHigh();\n            } else {\n                if ((poolPrice - oraclePrice) * 1e18 / oraclePrice > ACCEPTED_UNISWAP_SLIPPAGE) revert SlippageTooHigh();\n            }\n        }\n\n        token0Address.safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), 0);\n        token1Address.safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), 0);\n\n        token0Address.safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), params.amount0Desired);\n        token1Address.safeApprove(address(NONFUNGIBLE_POSITION_MANAGER_ADDRESS), params.amount1Desired);\n\n        (\n        ,\n        uint256 amount0,\n        uint256 amount1\n        ) = INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS).increaseLiquidity(params);\n\n        _decreaseExposure(tokenManager, token0Address, amount0);\n        _decreaseExposure(tokenManager, token1Address, amount1);\n\n        emit IncreaseLiquidityUniswapV3(msg.sender, poolAddress, params.tokenId, token0, token1, amount0, amount1, block.timestamp);\n    }\n\n    function decreaseLiquidityUniswapV3(INonfungiblePositionManager.DecreaseLiquidityParams memory params) external nonReentrant noBorrowInTheSameBlock onlyOwnerOrInsolvent {\n        (\n        ,,\n        address token0Address,\n        address token1Address,\n        uint24 fee,\n        ,,,,,,\n        ) = INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS).positions(params.tokenId);\n        address poolAddress = PoolAddress.computeAddress(UNISWAP_V3_FACTORY_ADDRESS, PoolAddress.getPoolKey(token0Address, token1Address, fee));\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        bytes32 token0 = tokenManager.tokenAddressToSymbol(token0Address);\n        bytes32 token1 = tokenManager.tokenAddressToSymbol(token1Address);\n\n        {\n            bytes32[] memory symbols = new bytes32[](2);\n\n            symbols[0] = token0;\n            symbols[1] = token1;\n\n            uint256[] memory prices = getOracleNumericValuesFromTxMsg(symbols);\n            (,int24 tick,,,,,) = IUniswapV3Pool(poolAddress).slot0();\n\n            uint256 poolPrice = OracleLibrary.getQuoteAtTick(tick, uint128(10 ** IERC20Metadata(token0Address).decimals()), token0Address, token1Address);\n            uint256 oraclePrice = prices[0] * (10 ** IERC20Metadata(token1Address).decimals()) / prices[1];\n\n\n            if (oraclePrice > poolPrice) {\n                if ((oraclePrice - poolPrice) * 1e18 / oraclePrice > ACCEPTED_UNISWAP_SLIPPAGE) revert SlippageTooHigh();\n            } else {\n                if ((poolPrice - oraclePrice) * 1e18 / oraclePrice > ACCEPTED_UNISWAP_SLIPPAGE) revert SlippageTooHigh();\n            }\n        }\n\n        (\n            uint256 amount0,\n            uint256 amount1\n        ) = INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS).decreaseLiquidity(params);\n\n        //TODO: check risks of uint256 to uint128 conversion\n        INonfungiblePositionManager.CollectParams memory collectParams = INonfungiblePositionManager.CollectParams(params.tokenId, address(this), uint128(amount0), uint128(amount1));\n\n        INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS).collect(collectParams);\n\n        _increaseExposure(tokenManager, token0Address, amount0);\n        _increaseExposure(tokenManager, token1Address, amount1);\n\n        emit DecreaseLiquidityUniswapV3(msg.sender, poolAddress, params.tokenId, token0, token1, amount0, amount1, block.timestamp);\n    }\n\n    function burnLiquidityUniswapV3(uint256 tokenId) external nonReentrant noBorrowInTheSameBlock onlyOwnerOrInsolvent {\n        uint256[] storage tokenIds = getTokenIds();\n        for (uint256 i; i < tokenIds.length; i++) {\n            if (tokenIds[i] == tokenId) {\n                INonfungiblePositionManager(NONFUNGIBLE_POSITION_MANAGER_ADDRESS).burn(tokenId);\n                tokenIds[i] = tokenIds[tokenIds.length - 1];\n                tokenIds.pop();\n                emit BurnLiquidityUniswapV3(msg.sender, tokenId, block.timestamp);\n\n                break;\n            }\n        }\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // pool must be whitelisted\n    error UniswapV3PoolNotWhitelisted();\n\n    error TooManyUniswapV3Positions();\n\n    error SlippageTooHigh();\n\n    /**\n     * @dev emitted after minting liquidity\n     * @param user the address of user providing liquidity\n     * @param pool UniswapV3 pool\n     * @param tokenId the if of NFT LP position\n     * @param firstAsset first asset provided for liquidity\n     * @param secondAsset second asset provided for liquidity\n     * @param liquidity amount of liquidity (LP token) added\n     * @param firstAmount amount of the first asset used\n     * @param secondAmount amount of the second asset used\n     * @param timestamp time of the transaction\n     **/\n    event AddLiquidityUniswapV3(address indexed user, address indexed pool, uint256 indexed tokenId, bytes32 firstAsset, bytes32 secondAsset, uint liquidity, uint firstAmount, uint secondAmount, uint256 timestamp);\n\n    /**\n     * @dev emitted after increasing liquidity\n     * @param user the address of user providing liquidity\n     * @param pool UniswapV3 pool\n     * @param tokenId the if of NFT LP position\n     * @param firstAsset first asset provided for liquidity\n     * @param secondAsset second asset provided for liquidity\n     * @param firstAmount amount of the first asset used\n     * @param secondAmount amount of the second asset used\n     * @param timestamp time of the transaction\n     **/\n    event IncreaseLiquidityUniswapV3(address indexed user, address indexed pool, uint256 indexed tokenId, bytes32 firstAsset, bytes32 secondAsset, uint firstAmount, uint secondAmount, uint256 timestamp);\n\n    /**\n     * @dev emitted after decreasing liquidity\n     * @param user the address of user decreasing liquidity\n     * @param pool UniswapV3 pool\n     * @param tokenId the if of NFT LP position\n     * @param firstAsset first asset received\n     * @param secondAsset second asset received\n     * @param firstAmount amount of the first asset received\n     * @param secondAmount amount of the second asset received\n     * @param timestamp time of the transaction\n     **/\n    event DecreaseLiquidityUniswapV3(address indexed user, address indexed pool, uint256 indexed tokenId, bytes32 firstAsset, bytes32 secondAsset, uint firstAmount, uint secondAmount, uint256 timestamp);\n\n    /**\n     * @dev emitted after burning Uniswap V3 token\n     * @param user the address of user decreasing liquidity\n     * @param tokenId the if of NFT LP position\n     * @param timestamp time of the transaction\n     **/\n    event BurnLiquidityUniswapV3(address indexed user, uint256 tokenId, uint256 timestamp);\n\n}\n"
    },
    "contracts/facets/avalanche/VectorFinanceFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: e0b7d4c696bf3135b985e7f92053898942be20bc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../interfaces/IVectorFinanceStaking.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/IVectorFinanceMainStaking.sol\";\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract VectorFinanceFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    // CONSTANTS\n\n    address private constant VectorMainStaking = 0x8B3d9F0017FA369cD8C164D0Cc078bf4cA588aE5;\n\n    // PUBLIC FUNCTIONS\n\n    function vectorStakeUSDC1Auto(uint256 amount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0x06f01502327De1c37076Bea4689a7e44279155e9,\n            symbol : \"USDC\",\n            identifier : \"VF_USDC_MAIN_AUTO\",\n            balanceSelector : this.vectorUSDC1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeUSDC1Auto.selector\n        });\n        stakeToken(amount, position);\n    }\n\n    function vectorUnstakeUSDC1Auto(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0x06f01502327De1c37076Bea4689a7e44279155e9,\n            symbol : \"USDC\",\n            identifier : \"VF_USDC_MAIN_AUTO\",\n            balanceSelector : this.vectorUSDC1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeUSDC1Auto.selector\n        });\n        unstakeToken(amount, minAmount, position);\n    }\n\n    function vectorUSDC1BalanceAuto() public view returns (uint256 _stakedBalance) {\n        IVectorFinanceCompounder compounder = getAssetCompounder(0x06f01502327De1c37076Bea4689a7e44279155e9);\n        uint256 shares = compounder.balanceOf(address(this));\n        _stakedBalance = compounder.getDepositTokensForShares(shares);\n    }\n\n    function vectorStakeUSDT1Auto(uint256 amount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0x836648A8cE166Ba7CaFb27F0E6AD21d5C91b7774,\n            symbol : \"USDT\",\n            identifier : \"VF_USDT_MAIN_AUTO\",\n            balanceSelector : this.vectorUSDT1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeUSDT1Auto.selector\n        });\n        stakeToken(amount, position);\n    }\n\n    function vectorUnstakeUSDT1Auto(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0x836648A8cE166Ba7CaFb27F0E6AD21d5C91b7774,\n            symbol : \"USDT\",\n            identifier : \"VF_USDT_MAIN_AUTO\",\n            balanceSelector : this.vectorUSDT1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeUSDT1Auto.selector\n        });\n        unstakeToken(amount, minAmount, position);\n    }\n\n    function vectorUSDT1BalanceAuto() public view returns (uint256 _stakedBalance) {\n        IVectorFinanceCompounder compounder = getAssetCompounder(0x836648A8cE166Ba7CaFb27F0E6AD21d5C91b7774);\n        uint256 shares = compounder.balanceOf(address(this));\n        _stakedBalance = compounder.getDepositTokensForShares(shares);\n    }\n\n    function vectorStakeWAVAX1Auto(uint256 amount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            symbol : \"AVAX\",\n            identifier : \"VF_AVAX_SAVAX_AUTO\",\n            balanceSelector : this.vectorWAVAX1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeWAVAX1Auto.selector\n        });\n        stakeToken(amount, position);\n    }\n\n    function vectorUnstakeWAVAX1Auto(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            symbol : \"AVAX\",\n            identifier : \"VF_AVAX_SAVAX_AUTO\",\n            balanceSelector : this.vectorWAVAX1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeWAVAX1Auto.selector\n        });\n        unstakeToken(amount, minAmount, position);\n    }\n\n    function vectorWAVAX1BalanceAuto() public view returns (uint256 _stakedBalance) {\n        IVectorFinanceCompounder compounder = getAssetCompounder(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n        uint256 shares = compounder.balanceOf(address(this));\n        _stakedBalance = compounder.getDepositTokensForShares(shares);\n    }\n\n    function vectorStakeSAVAX1Auto(uint256 amount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\n            symbol : \"sAVAX\",\n            identifier : \"VF_SAVAX_MAIN_AUTO\",\n            balanceSelector : this.vectorSAVAX1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeSAVAX1Auto.selector\n        });\n        stakeToken(amount, position);\n    }\n\n    function vectorUnstakeSAVAX1Auto(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\n            symbol : \"sAVAX\",\n            identifier : \"VF_SAVAX_MAIN_AUTO\",\n            balanceSelector : this.vectorSAVAX1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeSAVAX1Auto.selector\n        });\n        unstakeToken(amount, minAmount, position);\n    }\n\n    function vectorSAVAX1BalanceAuto() public view returns (uint256 _stakedBalance) {\n        IVectorFinanceCompounder compounder = getAssetCompounder(0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE);\n        uint256 shares = compounder.balanceOf(address(this));\n        _stakedBalance = compounder.getDepositTokensForShares(shares);\n    }\n\n    function vectorMigrateAvax() public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            symbol : \"AVAX\",\n            identifier : \"VF_AVAX_SAVAX_AUTO\",\n            balanceSelector : this.vectorWAVAX1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeWAVAX1Auto.selector\n        });\n        require(migrateStake(position, \"VF_AVAX_SAVAX\") > 0, \"Cannot migrate 0 tokens\");\n    }\n\n    function vectorMigrateSAvax() public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset : 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\n            symbol : \"sAVAX\",\n            identifier : \"VF_SAVAX_MAIN_AUTO\",\n            balanceSelector : this.vectorSAVAX1BalanceAuto.selector,\n            unstakeSelector : this.vectorUnstakeSAVAX1Auto.selector\n        });\n        require(migrateStake(position, \"VF_SAVAX_MAIN\") > 0, \"Cannot migrate 0 tokens\");\n    }\n\n    // INTERNAL FUNCTIONS\n    /**\n    * @dev This function uses the redstone-evm-connector\n    **/\n    function stakeToken(uint256 amount, IStakingPositions.StakedPosition memory position) internal\n    onlyOwner nonReentrant recalculateAssetsExposure remainsSolvent {\n        IVectorFinanceCompounder compounder = getAssetCompounder(position.asset);\n        IERC20Metadata stakedToken = getERC20TokenInstance(position.symbol, false);\n        uint256 initialReceiptTokenBalance = compounder.balanceOf(address(this));\n\n        amount = Math.min(stakedToken.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot stake 0 tokens\");\n\n        address(stakedToken).safeApprove(address(compounder), 0);\n        address(stakedToken).safeApprove(address(compounder), amount);\n\n        compounder.deposit(amount);\n\n        DiamondStorageLib.addStakedPosition(position);\n\n        if (stakedToken.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(position.symbol);\n        }\n\n        emit Staked(\n            msg.sender,\n            position.symbol,\n            address(compounder),\n            amount,\n            compounder.balanceOf(address(this)) - initialReceiptTokenBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n    * Unstakes token from Vector Finance\n    * IMPORTANT: This method can be used by anyone when a loan is insolvent. This operation can be costly, that is why\n    * if needed it has to be performed in a separate transaction to liquidation\n    * @dev This function uses the redstone-evm-connector\n    **/\n    function unstakeToken(uint256 amount, uint256 minAmount, IStakingPositions.StakedPosition memory position) internal\n    onlyOwnerOrInsolvent recalculateAssetsExposure nonReentrant returns (uint256 unstaked) {\n        IVectorFinanceCompounder compounder = getAssetCompounder(position.asset);\n        IERC20Metadata unstakedToken = getERC20TokenInstance(position.symbol, false);\n        uint256 initialReceiptTokenBalance = compounder.balanceOf(address(this));\n\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        amount = Math.min(compounder.depositTracking(address(this)), amount);\n\n        uint256 balance = unstakedToken.balanceOf(address(this));\n\n        compounder.withdraw(amount, minAmount);\n\n        uint256 newBalance = unstakedToken.balanceOf(address(this));\n\n        if (compounder.depositTracking(address(this)) == 0) {\n            DiamondStorageLib.removeStakedPosition(position.identifier);\n        }\n        DiamondStorageLib.addOwnedAsset(position.symbol, address(unstakedToken));\n\n        emit Unstaked(\n            msg.sender,\n            position.symbol,\n            address(compounder),\n            newBalance - balance,\n            initialReceiptTokenBalance - compounder.balanceOf(address(this)),\n            block.timestamp\n        );\n\n        return newBalance - balance;\n    }\n\n    /**\n     * @notice Withdraws all previous balance from the pool helper, and deposits into the compounder.\n     */\n    function migrateStake(IStakingPositions.StakedPosition memory position, bytes32 oldIdentifier) internal\n    onlyOwner nonReentrant recalculateAssetsExposure remainsSolvent returns (uint256 migrated) {\n        IVectorFinanceStaking poolHelper = getAssetPoolHelper(position.asset);\n        IVectorFinanceCompounder compounder = getAssetCompounder(position.asset);\n\n        migrated = poolHelper.balance(address(this));\n        if (migrated > 0) {\n            compounder.migrateAllUserDepositsFromManual();\n\n            DiamondStorageLib.removeStakedPosition(oldIdentifier);\n\n            DiamondStorageLib.addStakedPosition(position);\n\n            emit Migrated(\n                msg.sender,\n                position.symbol,\n                address(compounder),\n                migrated,\n                block.timestamp\n            );\n        }\n    }\n\n    function getAssetCompounder(address asset) internal pure returns (IVectorFinanceCompounder compounder){\n        if(asset == 0x06f01502327De1c37076Bea4689a7e44279155e9){ // USDC\n            return IVectorFinanceCompounder(0x1DBd41f9Efde5b387E820e9B43BDa00c4154a82A);\n        } else if (asset == 0x836648A8cE166Ba7CaFb27F0E6AD21d5C91b7774){ // USDT\n            return IVectorFinanceCompounder(0x951CbF0DDA285FD8011F2cB7Ed435fA095f803a0);\n        } else if (asset == 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7){ // WAVAX\n            return IVectorFinanceCompounder(0xe2406Af0E26769D3231682C80D4bB7bBdF329A88);\n        } else if (asset == 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE){ // SAVAX\n            return IVectorFinanceCompounder(0x1636bE3843E86826cB6aDC141B5d40d782763B85);\n        } else {\n            revert(\"Asset not supported\");\n        }\n    }\n\n    function getAssetPoolHelper(address asset) internal view returns (IVectorFinanceStaking){\n        IVectorFinanceMainStaking mainStaking = IVectorFinanceMainStaking(VectorMainStaking);\n        return IVectorFinanceStaking(mainStaking.getPoolInfo(asset).helper);\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much of deposit token was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param asset the asset that was unstaked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much deposit token was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of receipt token\n        * @param migratedAmount how much of receipt token was migrated\n        * @param timestamp of staking\n    **/\n    event Migrated(address indexed user, bytes32 indexed asset, address indexed vault, uint256 migratedAmount, uint256 timestamp);\n}\n"
    },
    "contracts/facets/avalanche/VectorFinanceFacetOld.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: e0b7d4c696bf3135b985e7f92053898942be20bc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../interfaces/IVectorFinanceStaking.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract VectorFinanceFacetOld is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n\n    // CONSTANTS\n\n    address private constant VectorMainStaking = 0x8B3d9F0017FA369cD8C164D0Cc078bf4cA588aE5;\n\n    // PUBLIC FUNCTIONS\n\n    function vectorStakeUSDC1(uint256 amount) public pure {\n        revert(\"Manual VF vaults are no longer supported.\");\n    }\n\n    function vectorUnstakeUSDC1(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E,\n            symbol: \"USDC\",\n            identifier: \"VF_USDC_MAIN\",\n            balanceSelector: this.vectorUSDC1Balance.selector,\n            unstakeSelector: this.vectorUnstakeUSDC1.selector\n        });\n        unstakeToken(position);\n    }\n\n    function vectorUSDC1Balance() public view returns(uint256 _stakedBalance) {\n        IVectorFinanceStaking stakingContract = getAssetPoolHelper(0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E);\n        _stakedBalance = stakingContract.balance(address(this));\n    }\n\n    function vectorStakeWAVAX1(uint256 amount) public pure {\n        revert(\"Manual VF vaults are no longer supported.\");\n    }\n\n    function vectorUnstakeWAVAX1(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            symbol: \"AVAX\",\n            identifier: \"VF_AVAX_SAVAX\",\n            balanceSelector: this.vectorWAVAX1Balance.selector,\n            unstakeSelector: this.vectorUnstakeWAVAX1.selector\n        });\n        unstakeToken(position);\n    }\n\n    function vectorWAVAX1Balance() public view returns(uint256 _stakedBalance) {\n        IVectorFinanceStaking stakingContract = getAssetPoolHelper(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7);\n        _stakedBalance = stakingContract.balance(address(this));\n    }\n\n    function vectorStakeSAVAX1(uint256 amount) public pure {\n        revert(\"Manual VF vaults are no longer supported.\");\n    }\n\n    function vectorUnstakeSAVAX1(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\n            symbol: \"sAVAX\",\n            identifier: \"VF_SAVAX_MAIN\",\n            balanceSelector: this.vectorSAVAX1Balance.selector,\n            unstakeSelector: this.vectorUnstakeSAVAX1.selector\n        });\n        unstakeToken(position);\n    }\n\n    function vectorSAVAX1Balance() public view returns(uint256 _stakedBalance) {\n        IVectorFinanceStaking stakingContract = getAssetPoolHelper(0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE);\n        _stakedBalance = stakingContract.balance(address(this));\n    }\n\n    // INTERNAL FUNCTIONS\n\n    /**\n    * Unstakes token from Vector Finance\n    * IMPORTANT: This method can be used by anyone when a loan is insolvent. This operation can be costly, that is why\n    * if needed it has to be performed in a separate transaction to liquidation\n    * @dev This function uses the redstone-evm-connector\n    **/\n    function unstakeToken(IStakingPositions.StakedPosition memory position) internal\n    onlyOwnerOrInsolvent recalculateAssetsExposure nonReentrant returns (uint256 unstaked) {\n        IVectorFinanceStaking poolHelper = getAssetPoolHelper(position.asset);\n        IERC20Metadata unstakedToken = getERC20TokenInstance(position.symbol, false);\n\n        uint256 amount = poolHelper.balance(address(this));\n\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        uint256 balance = unstakedToken.balanceOf(address(this));\n\n        poolHelper.withdraw(amount, 0);\n\n        uint256 newBalance = unstakedToken.balanceOf(address(this));\n\n        if (poolHelper.balance(address(this)) == 0) {\n            DiamondStorageLib.removeStakedPosition(position.identifier);\n        }\n        DiamondStorageLib.addOwnedAsset(position.symbol, address(unstakedToken));\n\n        emit Unstaked(\n            msg.sender,\n            position.symbol,\n            address(poolHelper),\n            newBalance - balance,\n            amount,\n            block.timestamp\n        );\n\n        _handleRewards(poolHelper);\n\n        return newBalance - balance;\n    }\n\n    function _handleRewards(IVectorFinanceStaking stakingContract) internal {\n        IVectorRewarder rewarder = stakingContract.rewarder();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        uint256 index;\n\n        // We do not want to revert in case of unsupported rewardTokens in order not to block the unstaking/liquidation process\n        while(true) {\n            // No access to the length of rewardTokens[]. Need to iterate until indexOutOfRange\n            (bool success, bytes memory result) = address(rewarder).call(abi.encodeWithSignature(\"rewardTokens(uint256)\", index));\n            if(!success) {\n                break;\n            }\n            address rewardToken = abi.decode(result, (address));\n            bytes32 rewardTokenSymbol = tokenManager.tokenAddressToSymbol(rewardToken);\n            if(rewardTokenSymbol == \"\") {\n                emit UnsupportedRewardToken(msg.sender, rewardToken, block.timestamp);\n                index += 1;\n                continue;\n            }\n            if(IERC20(rewardToken).balanceOf(address(this)) > 0) {\n                DiamondStorageLib.addOwnedAsset(rewardTokenSymbol, rewardToken);\n            }\n            index += 1;\n        }\n    }\n\n    function getAssetPoolHelper(address asset) internal view returns(IVectorFinanceStaking){\n        if(asset == 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E){\n            return IVectorFinanceStaking(0x7d44f9eb1ffa6848362a966EF7D6340D14f4AF7E);\n        } else if (asset == 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7){\n            return IVectorFinanceStaking(0xab42ed09F43DDa849aa7F62500885A973A38a8Bc);\n        } else if (asset == 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE){\n            return IVectorFinanceStaking(0x91F78865b239432A1F1Cc1fFeC0Ac6203079E6D7);\n        } else {\n            revert(\"asset not supported\");\n        }\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much of deposit token was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param asset the asset that was unstaked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much deposit token was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user collects rewards in tokens that are not supported\n        * @param user the address collecting rewards\n        * @param asset reward token that was collected\n        * @param timestamp of collecting rewards\n    **/\n    event UnsupportedRewardToken(address indexed user, address indexed asset, uint256 timestamp);\n}"
    },
    "contracts/facets/avalanche/WombatFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/facets/avalanche/IWombatPool.sol\";\nimport \"../../interfaces/facets/avalanche/IWombatMaster.sol\";\nimport \"../../interfaces/facets/avalanche/IWombatRouter.sol\";\nimport \"../../interfaces/facets/avalanche/IRewarder.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract WombatFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    address public constant WOM_TOKEN =\n        0xa15E4544D141aa98C4581a1EA10Eb9048c3b3382;\n    address public constant WOMBAT_ROUTER =\n        0x4A88C44B8D9B9f3F2BA4D97236F737CF03DF76CD;\n    address public constant WOMBAT_MASTER =\n        0x6521a549834F5E6d253CD2e5F4fbe4048f86cd7b;\n    address public constant sAVAX_AVAX_POOL =\n        0xE3Abc29B035874a9f6dCDB06f8F20d9975069D87;\n    address public constant ggAVAX_AVAX_POOL =\n        0xBbA43749efC1bC29eA434d88ebaf8A97DC7aEB77;\n    bytes32 public constant WOMBAT_ggAVAX_AVAX_LP_AVAX =\n        \"WOMBAT_ggAVAX_AVAX_LP_AVAX\";\n    bytes32 public constant WOMBAT_ggAVAX_AVAX_LP_ggAVAX =\n        \"WOMBAT_ggAVAX_AVAX_LP_ggAVAX\";\n    bytes32 public constant WOMBAT_sAVAX_AVAX_LP_AVAX =\n        \"WOMBAT_sAVAX_AVAX_LP_AVAX\";\n    bytes32 public constant WOMBAT_sAVAX_AVAX_LP_sAVAX =\n        \"WOMBAT_sAVAX_AVAX_LP_sAVAX\";\n\n    function depositSavaxToAvaxSavax(uint256 amount, uint256 minLpOut) external {\n        _depositToken(\n            \"sAVAX\",\n            WOMBAT_sAVAX_AVAX_LP_sAVAX,\n            sAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.sAvaxBalanceAvaxSavax.selector,\n            this.withdrawSavaxFromAvaxSavax.selector\n        );\n    }\n\n    function withdrawSavaxFromAvaxSavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"sAVAX\",\n                \"sAVAX\",\n                WOMBAT_sAVAX_AVAX_LP_sAVAX,\n                sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function sAvaxBalanceAvaxSavax()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(WOMBAT_sAVAX_AVAX_LP_sAVAX);\n    }\n\n    function depositGgavaxToAvaxGgavax(\n        uint256 amount,\n        uint256 minLpOut\n    ) external {\n        _depositToken(\n            \"ggAVAX\",\n            WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n            ggAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.ggAvaxBalanceAvaxGgavax.selector,\n            this.withdrawGgavaxFromAvaxGgavax.selector\n        );\n    }\n\n    function withdrawGgavaxFromAvaxGgavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"ggAVAX\",\n                \"ggAVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n                ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function ggAvaxBalanceAvaxGgavax()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(WOMBAT_ggAVAX_AVAX_LP_ggAVAX);\n    }\n\n    function depositAvaxToAvaxSavax(uint256 amount, uint256 minLpOut) external {\n        _depositNative(\n            WOMBAT_sAVAX_AVAX_LP_AVAX,\n            sAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.avaxBalanceAvaxSavax.selector,\n            this.withdrawAvaxFromAvaxSavax.selector\n        );\n    }\n\n    function withdrawAvaxFromAvaxSavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"AVAX\",\n                WOMBAT_sAVAX_AVAX_LP_AVAX,\n                sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function avaxBalanceAvaxSavax()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(WOMBAT_sAVAX_AVAX_LP_AVAX);\n    }\n\n    function depositAvaxToAvaxGgavax(uint256 amount, uint256 minLpOut) external {\n        _depositNative(\n            WOMBAT_ggAVAX_AVAX_LP_AVAX,\n            ggAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.avaxBalanceAvaxGgavax.selector,\n            this.withdrawAvaxFromAvaxGgavax.selector\n        );\n    }\n\n    function withdrawAvaxFromAvaxGgavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"AVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_AVAX,\n                ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function avaxBalanceAvaxGgavax()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(WOMBAT_ggAVAX_AVAX_LP_AVAX);\n    }\n\n    function withdrawSavaxFromAvaxSavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"AVAX\",\n                \"sAVAX\",\n                WOMBAT_sAVAX_AVAX_LP_AVAX,\n                sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function withdrawGgavaxFromAvaxGgavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"AVAX\",\n                \"ggAVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_AVAX,\n                ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function withdrawAvaxFromAvaxSavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"sAVAX\",\n                WOMBAT_sAVAX_AVAX_LP_sAVAX,\n                sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function withdrawAvaxFromAvaxGgavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"ggAVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n                ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function depositAndStakeAvaxSavaxLpSavax(uint256 amount) external {\n        _depositAndStakeWombatLP(\n            WOMBAT_sAVAX_AVAX_LP_sAVAX,\n            amount,\n            this.sAvaxBalanceAvaxSavax.selector,\n            this.unstakeAndWithdrawAvaxSavaxLpSavax.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxSavaxLpSavax(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return _unstakeAndWithdrawWombatLP(WOMBAT_sAVAX_AVAX_LP_sAVAX, amount);\n    }\n\n    function depositAndStakeAvaxSavaxLpAvax(uint256 amount) external {\n        _depositAndStakeWombatLP(\n            WOMBAT_sAVAX_AVAX_LP_AVAX,\n            amount,\n            this.avaxBalanceAvaxSavax.selector,\n            this.unstakeAndWithdrawAvaxSavaxLpAvax.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxSavaxLpAvax(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return _unstakeAndWithdrawWombatLP(WOMBAT_sAVAX_AVAX_LP_AVAX, amount);\n    }\n\n    function depositAvaxGgavaxLpGgavax(uint256 amount) external {\n        _depositAndStakeWombatLP(\n            WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n            amount,\n            this.ggAvaxBalanceAvaxGgavax.selector,\n            this.unstakeAndWithdrawAvaxGgavaxLpGgavax.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxGgavaxLpGgavax(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return _unstakeAndWithdrawWombatLP(WOMBAT_ggAVAX_AVAX_LP_ggAVAX, amount);\n    }\n\n    function depositAndStakeAvaxGgavaxLpAvax(uint256 amount) external {\n        _depositAndStakeWombatLP(\n            WOMBAT_ggAVAX_AVAX_LP_AVAX,\n            amount,\n            this.avaxBalanceAvaxGgavax.selector,\n            this.unstakeAndWithdrawAvaxGgavaxLpAvax.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxGgavaxLpAvax(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return _unstakeAndWithdrawWombatLP(WOMBAT_ggAVAX_AVAX_LP_AVAX, amount);\n    }\n\n    function claimAllWombatRewards()\n        external\n        onlyOwner\n        nonReentrant\n        remainsSolvent\n    {\n        bytes32[4] memory lpAssets = [\n            WOMBAT_ggAVAX_AVAX_LP_AVAX,\n            WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n            WOMBAT_sAVAX_AVAX_LP_AVAX,\n            WOMBAT_sAVAX_AVAX_LP_sAVAX\n        ];\n        for (uint256 i; i != 4; ++i) {\n            IERC20Metadata lpToken = getERC20TokenInstance(lpAssets[i], false);\n            uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(address(lpToken));\n            (uint256 reward, uint256[] memory additionalRewards) = IWombatMaster(\n                WOMBAT_MASTER\n            ).withdraw(pid, 0);\n            handleRewards(pid, reward, additionalRewards);\n        }\n    }\n\n    function pendingRewardsForAvaxSavaxLpSavax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        )\n    {\n        return _pendingRewardsForLp(WOMBAT_sAVAX_AVAX_LP_sAVAX);\n    }\n\n    function pendingRewardsForAvaxSavaxLpAvax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        )\n    {\n        return _pendingRewardsForLp(WOMBAT_sAVAX_AVAX_LP_AVAX);\n    }\n\n    function pendingRewardsForAvaxGgavaxLpGgavax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        )\n    {\n        return _pendingRewardsForLp(WOMBAT_ggAVAX_AVAX_LP_ggAVAX);\n    }\n\n    function pendingRewardsForAvaxGgavaxLpAvax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        )\n    {\n        return _pendingRewardsForLp(WOMBAT_ggAVAX_AVAX_LP_AVAX);\n    }\n\n    function _pendingRewardsForLp(\n        bytes32 lpAsset\n    ) internal view returns (address[] memory, uint256[] memory) {\n        IERC20Metadata lpToken = getERC20TokenInstance(lpAsset, false);\n        uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(address(lpToken));\n        (\n            uint256 pendingWomRewards,\n            address[] memory rewardTokenAddresses_,\n            ,\n            uint256[] memory pendingRewards_\n        ) = IWombatMaster(WOMBAT_MASTER).pendingTokens(pid, address(this));\n\n        address[] memory rewardTokenAddresses = new address[](\n            rewardTokenAddresses_.length + 1\n        );\n        uint256[] memory pendingRewards = new uint256[](pendingRewards_.length + 1);\n\n        rewardTokenAddresses[0] = WOM_TOKEN;\n        pendingRewards[0] = pendingWomRewards;\n\n        for (uint256 i; i != rewardTokenAddresses_.length; ++i) {\n            rewardTokenAddresses[i + 1] = rewardTokenAddresses_[i];\n        }\n        for (uint256 i; i != pendingRewards_.length; ++i) {\n            pendingRewards[i + 1] = pendingRewards_[i];\n        }\n\n        return (rewardTokenAddresses, pendingRewards);\n    }\n\n    function _depositToken(\n        bytes32 stakeAsset,\n        bytes32 lpAsset,\n        address pool,\n        uint256 amount,\n        uint256 minLpOut,\n        bytes4 balanceSelector,\n        bytes4 unstakeSelector\n    ) internal onlyOwner nonReentrant remainsSolvent {\n        IERC20Metadata stakeToken = getERC20TokenInstance(stakeAsset, false);\n        IERC20Metadata lpToken = getERC20TokenInstance(lpAsset, false);\n\n        amount = Math.min(stakeToken.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot deposit 0 tokens\");\n\n        address(stakeToken).safeApprove(pool, 0);\n        address(stakeToken).safeApprove(pool, amount);\n\n        IWombatPool(pool).deposit(\n            address(stakeToken),\n            amount,\n            minLpOut,\n            address(this),\n            block.timestamp,\n            true\n        );\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, address(stakeToken), amount);\n\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: address(lpToken),\n                symbol: lpAsset,\n                identifier: lpAsset,\n                balanceSelector: balanceSelector,\n                unstakeSelector: unstakeSelector\n            });\n        DiamondStorageLib.addStakedPosition(position);\n    }\n\n    function _withdrawToken(\n        bytes32 fromAsset,\n        bytes32 toAsset,\n        bytes32 lpAsset,\n        address pool,\n        uint256 amount,\n        uint256 minOut\n    ) internal onlyOwnerOrInsolvent nonReentrant returns (uint256 amountOut) {\n        IERC20Metadata fromToken = getERC20TokenInstance(fromAsset, false);\n        IERC20Metadata toToken = getERC20TokenInstance(toAsset, false);\n        IERC20Metadata lpToken = getERC20TokenInstance(lpAsset, false);\n        uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(address(lpToken));\n\n        amount = Math.min(amount, getLpTokenBalance(lpAsset));\n        require(amount > 0, \"Cannot withdraw 0 tokens\");\n\n        (uint256 reward, uint256[] memory additionalRewards) = IWombatMaster(\n            WOMBAT_MASTER\n        ).withdraw(pid, amount);\n\n        address(lpToken).safeApprove(pool, 0);\n        address(lpToken).safeApprove(pool, amount);\n\n        if (fromAsset == toAsset) {\n            amountOut = IWombatPool(pool).withdraw(\n                address(fromToken),\n                amount,\n                minOut,\n                address(this),\n                block.timestamp\n            );\n        } else {\n            amountOut = IWombatPool(pool).withdrawFromOtherAsset(\n                address(fromToken),\n                address(toToken),\n                amount,\n                minOut,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        if (getLpTokenBalance(lpAsset) == 0) {\n            DiamondStorageLib.removeStakedPosition(lpAsset);\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(toToken), amountOut);\n        handleRewards(pid, reward, additionalRewards);\n    }\n\n    function _depositNative(\n        bytes32 lpAsset,\n        address pool,\n        uint256 amount,\n        uint256 minLpOut,\n        bytes4 balanceSelector,\n        bytes4 unstakeSelector\n    ) internal onlyOwner nonReentrant remainsSolvent {\n        IWrappedNativeToken wrapped = IWrappedNativeToken(\n            DeploymentConstants.getNativeToken()\n        );\n        IERC20Metadata lpToken = getERC20TokenInstance(lpAsset, false);\n\n        amount = Math.min(wrapped.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot deposit 0 tokens\");\n\n        wrapped.withdraw(amount);\n\n        IWombatRouter(WOMBAT_ROUTER).addLiquidityNative{value: amount}(\n            pool,\n            minLpOut,\n            address(this),\n            block.timestamp,\n            true\n        );\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, address(wrapped), amount);\n\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: address(lpToken),\n                symbol: lpAsset,\n                identifier: lpAsset,\n                balanceSelector: balanceSelector,\n                unstakeSelector: unstakeSelector\n            });\n        DiamondStorageLib.addStakedPosition(position);\n    }\n\n    function _withdrawNative(\n        bytes32 fromAsset,\n        bytes32 lpAsset,\n        address pool,\n        uint256 amount,\n        uint256 minOut\n    ) internal onlyOwnerOrInsolvent nonReentrant returns (uint256 amountOut) {\n        IERC20Metadata fromToken = getERC20TokenInstance(fromAsset, false);\n        IWrappedNativeToken wrapped = IWrappedNativeToken(\n            DeploymentConstants.getNativeToken()\n        );\n        IERC20Metadata lpToken = getERC20TokenInstance(lpAsset, false);\n        uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(address(lpToken));\n\n        amount = Math.min(amount, getLpTokenBalance(lpAsset));\n        require(amount > 0, \"Cannot withdraw 0 tokens\");\n\n        (uint256 reward, uint256[] memory additionalRewards) = IWombatMaster(\n            WOMBAT_MASTER\n        ).withdraw(pid, amount);\n\n        address(lpToken).safeApprove(WOMBAT_ROUTER, 0);\n        address(lpToken).safeApprove(WOMBAT_ROUTER, amount);\n\n        if (fromAsset == bytes32(\"AVAX\")) {\n            amountOut = IWombatRouter(WOMBAT_ROUTER).removeLiquidityNative(\n                pool,\n                amount,\n                minOut,\n                address(this),\n                block.timestamp\n            );\n        } else {\n            amountOut = IWombatRouter(WOMBAT_ROUTER)\n                .removeLiquidityFromOtherAssetAsNative(\n                    pool,\n                    address(fromToken),\n                    amount,\n                    minOut,\n                    address(this),\n                    block.timestamp\n                );\n        }\n\n        wrapped.deposit{value: amountOut}();\n\n        if (getLpTokenBalance(lpAsset) == 0) {\n            DiamondStorageLib.removeStakedPosition(lpAsset);\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(wrapped), amountOut);\n        handleRewards(pid, reward, additionalRewards);\n    }\n\n    function _depositAndStakeWombatLP(\n        bytes32 lpAsset,\n        uint256 amount,\n        bytes4 balanceSelector,\n        bytes4 unstakeSelector\n    ) internal onlyOwner nonReentrant remainsSolvent {\n        IERC20Metadata lpToken = getERC20TokenInstance(lpAsset, false);\n\n        amount = Math.min(amount, lpToken.balanceOf(msg.sender));\n        require(amount > 0, \"Cannot deposit 0 tokens\");\n\n        address(lpToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        address(lpToken).safeApprove(WOMBAT_MASTER, 0);\n        address(lpToken).safeApprove(WOMBAT_MASTER, amount);\n\n        uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(address(lpToken));\n\n        IWombatMaster(WOMBAT_MASTER).deposit(pid, amount);\n\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: address(lpToken),\n                symbol: lpAsset,\n                identifier: lpAsset,\n                balanceSelector: balanceSelector,\n                unstakeSelector: unstakeSelector\n            });\n        DiamondStorageLib.addStakedPosition(position);\n    }\n\n    function _unstakeAndWithdrawWombatLP(\n        bytes32 lpAsset,\n        uint256 amount\n    )\n        internal\n        onlyOwner\n        nonReentrant\n        remainsSolvent\n        canRepayDebtFully\n        returns (uint256 amountOut)\n    {\n        IERC20Metadata lpToken = getERC20TokenInstance(lpAsset, false);\n        uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(address(lpToken));\n\n        amount = Math.min(amount, getLpTokenBalance(lpAsset));\n        require(amount > 0, \"Cannot withdraw 0 tokens\");\n\n        (uint256 reward, uint256[] memory additionalRewards) = IWombatMaster(\n            WOMBAT_MASTER\n        ).withdraw(pid, amount);\n\n        address(lpToken).safeTransfer(msg.sender, amount);\n\n        if (getLpTokenBalance(lpAsset) == 0) {\n            DiamondStorageLib.removeStakedPosition(lpAsset);\n        }\n\n        handleRewards(pid, reward, additionalRewards);\n\n        return amount;\n    }\n\n    function handleRewards(\n        uint256 pid,\n        uint256 reward,\n        uint256[] memory additionalRewards\n    ) internal {\n        (, , address rewarder, , , , ) = IWombatMaster(WOMBAT_MASTER).poolInfo(pid);\n        address boostedRewarder = IWombatMaster(WOMBAT_MASTER).boostedRewarders(\n            pid\n        );\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address owner = DiamondStorageLib.contractOwner();\n\n        if (reward > 0 && tokenManager.isTokenAssetActive(WOM_TOKEN)) {\n            _increaseExposure(tokenManager, WOM_TOKEN, reward);\n        } else if (reward > 0) {\n            WOM_TOKEN.safeTransfer(owner, reward);\n        }\n\n        uint256 baseIdx;\n        if (rewarder != address(0)) {\n            address[] memory rewardTokens = IRewarder(rewarder).rewardTokens();\n            baseIdx = rewardTokens.length;\n            for (uint256 i; i != baseIdx; ++i) {\n                address rewardToken = rewardTokens[i];\n                uint256 pendingReward = additionalRewards[i];\n\n                if (pendingReward == 0) {\n                    continue;\n                }\n\n                if (tokenManager.isTokenAssetActive(rewardToken)) {\n                    _increaseExposure(tokenManager, rewardToken, pendingReward);\n                } else {\n                    rewardToken.safeTransfer(owner, pendingReward);\n                }\n            }\n        }\n        if (boostedRewarder != address(0)) {\n            address[] memory rewardTokens = IRewarder(boostedRewarder).rewardTokens();\n            for (uint256 i; i != rewardTokens.length; ++i) {\n                address rewardToken = rewardTokens[i];\n                uint256 pendingReward = additionalRewards[baseIdx + i];\n\n                if (pendingReward == 0) {\n                    continue;\n                }\n\n                if (tokenManager.isTokenAssetActive(rewardToken)) {\n                    _increaseExposure(tokenManager, rewardToken, pendingReward);\n                } else {\n                    rewardToken.safeTransfer(owner, pendingReward);\n                }\n            }\n        }\n    }\n\n    function getLpTokenBalance(bytes32 asset) internal view returns (uint256) {\n        IERC20Metadata lpToken = getERC20TokenInstance(asset, false);\n        uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(address(lpToken));\n        IWombatMaster.UserInfo memory userInfo = IWombatMaster(WOMBAT_MASTER)\n            .userInfo(pid, address(this));\n        return userInfo.amount;\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n}\n"
    },
    "contracts/facets/avalanche/YieldYakFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ec6e7a0ed7ef3d10f4007e7ebad336dc88392717;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../lib/SolvencyMethods.sol\";\nimport \"../../interfaces/facets/avalanche/IYieldYak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\n\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract YieldYakFacet is ReentrancyGuardKeccak, SolvencyMethods, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    // Staking Vaults tokens\n    address private constant YY_AAVE_AVAX = 0xaAc0F2d0630d1D09ab2B5A400412a4840B866d95;\n    address private constant YY_PTP_sAVAX = 0xb8f531c0d3c53B1760bcb7F57d87762Fd25c4977;\n    address private constant YY_GLP = 0x9f637540149f922145c06e1aa3f38dcDc32Aff5C;\n\n    // Staking Vaults LPs\n    address private constant YY_PNG_AVAX_USDC_LP = 0xC0cd58661b68e10b49D3Bec4bC5E44e7A7c20656;\n    address private constant YY_PNG_AVAX_ETH_LP = 0xFCD2050E213cC54db2c9c99632AC870574FbC261;\n    address private constant YY_TJ_AVAX_USDC_LP = 0xDEf94a13fF31FB6363f1e03bF18fe0F59Db83BBC;\n    address private constant YY_TJ_AVAX_ETH_LP = 0x5219558ee591b030E075892acc41334A1694fd8A;\n    address private constant YY_TJ_AVAX_sAVAX_LP = 0x22EDe03f1115666CF05a4bAfafaEe8F43D42cD56;\n\n    // Tokens\n    address private constant SAVAX_TOKEN = 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE;\n    address private constant AVAX_TOKEN = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    address private constant GLP_TOKEN = 0x9e295B5B976a184B14aD8cd72413aD846C299660;\n    // Older version of stakedGLP token (without decimals() that YieldYak uses\n    address private constant sGLP_TOKEN = 0x5643F4b25E36478eE1E90418d5343cb6591BcB9d;\n    // LPs\n    address private constant PNG_AVAX_USDC_LP = 0x0e0100Ab771E9288e0Aa97e11557E6654C3a9665;\n    address private constant PNG_AVAX_ETH_LP = 0x7c05d54fc5CB6e4Ad87c6f5db3b807C94bB89c52;\n\n    address private constant TJ_AVAX_USDC_LP = 0xf4003F4efBE8691B60249E6afbD307aBE7758adb;\n    address private constant TJ_AVAX_ETH_LP = 0xFE15c2695F1F920da45C30AAE47d11dE51007AF9;\n    address private constant TJ_AVAX_sAVAX_LP = 0x4b946c91C2B1a7d7C40FB3C130CdfBaf8389094d;\n\n    // ----- STAKE -----\n\n    /**\n        * Stakes AVAX in Yield Yak protocol\n        * @dev This function uses the redstone-evm-connector\n        * @param amount amount of AVAX to be staked\n    **/\n    function stakeAVAXYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        require(amount > 0, \"Cannot stake 0 tokens\");\n        amount = Math.min(IWrappedNativeToken(AVAX_TOKEN).balanceOf(address(this)), amount);\n        IERC20Metadata yrtToken = IERC20Metadata(YY_AAVE_AVAX);\n        uint256 initialYRTBalance = yrtToken.balanceOf(address(this));\n\n        IWrappedNativeToken(AVAX_TOKEN).withdraw(amount);\n        IYieldYak(YY_AAVE_AVAX).deposit{value: amount}();\n\n        uint256 yrtTokenReceived = yrtToken.balanceOf(address(this)) - initialYRTBalance;\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, AVAX_TOKEN, amount);\n        _increaseExposure(tokenManager, YY_AAVE_AVAX, yrtTokenReceived);\n\n        emit Staked(\n            msg.sender,\n            \"AVAX\",\n            YY_AAVE_AVAX,\n            amount,\n            yrtTokenReceived,\n            block.timestamp\n        );\n    }\n\n    /**\n       * Stakes sAVAX in Yield Yak protocol\n       * @dev This function uses the redstone-evm-connector\n       * @param amount amount of sAVAX to be staked\n    **/\n    function stakeSAVAXYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n            tokenAddress: SAVAX_TOKEN,\n            vaultAddress: YY_PTP_sAVAX,\n            tokenSymbol: \"sAVAX\",\n            vaultTokenSymbol: \"YY_PTP_sAVAX\",\n            amount: amount\n        }));\n    }\n\n    /**\n       * Stakes GLP in Yield Yak protocol\n       * @dev This function uses the redstone-evm-connector\n       * @param amount amount of GLP to be staked\n    **/\n    function stakeGLPYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        // Extra approve for the stakedGLP contract that is being used to transfer fsGLP\n        sGLP_TOKEN.safeApprove(YY_GLP, 0);\n        sGLP_TOKEN.safeApprove(YY_GLP, amount);\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: GLP_TOKEN,\n        vaultAddress: YY_GLP,\n        tokenSymbol: \"GLP\",\n        vaultTokenSymbol: \"YY_GLP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Stakes PNG_AVAX_USDC_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_USDC_LP to be staked\n    **/\n    function stakePNGAVAXUSDCYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: PNG_AVAX_USDC_LP,\n        vaultAddress: YY_PNG_AVAX_USDC_LP,\n        tokenSymbol: \"PNG_AVAX_USDC_LP\",\n        vaultTokenSymbol: \"YY_PNG_AVAX_USDC_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Stakes PNG_AVAX_ETH_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_ETH_LP to be staked\n    **/\n    function stakePNGAVAXETHYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: PNG_AVAX_ETH_LP,\n        vaultAddress: YY_PNG_AVAX_ETH_LP,\n        tokenSymbol: \"PNG_AVAX_ETH_LP\",\n        vaultTokenSymbol: \"YY_PNG_AVAX_ETH_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Stakes TJ_AVAX_USDC in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_USDC to be staked\n    **/\n    function stakeTJAVAXUSDCYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: TJ_AVAX_USDC_LP,\n        vaultAddress: YY_TJ_AVAX_USDC_LP,\n        tokenSymbol: \"TJ_AVAX_USDC_LP\",\n        vaultTokenSymbol: \"YY_TJ_AVAX_USDC_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Stakes TJ_AVAX_ETH_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_ETH_LP to be staked\n    **/\n    function stakeTJAVAXETHYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: TJ_AVAX_ETH_LP,\n        vaultAddress: YY_TJ_AVAX_ETH_LP,\n        tokenSymbol: \"TJ_AVAX_ETH_LP\",\n        vaultTokenSymbol: \"YY_TJ_AVAX_ETH_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Stakes TJ_AVAX_sAVAX_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_sAVAX_LP to be staked\n    **/\n    function stakeTJAVAXSAVAXYak(uint256 amount) public onlyOwner nonReentrant remainsSolvent {\n        _stakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: TJ_AVAX_sAVAX_LP,\n        vaultAddress: YY_TJ_AVAX_sAVAX_LP,\n        tokenSymbol: \"TJ_AVAX_sAVAX_LP\",\n        vaultTokenSymbol: \"YY_TJ_AVAX_sAVAX_LP\",\n        amount: amount\n        }));\n    }\n\n    // ----- UNSTAKE -----\n\n\n    //TODO: make common method for unstaking single assets\n\n    /**\n        * Unstakes AVAX from Yield Yak protocol\n        * @dev This function uses the redstone-evm-connector\n        * @param amount amount of AVAX to be unstaked\n    **/\n    function unstakeAVAXYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        IYieldYak yakStakingContract = IYieldYak(YY_AAVE_AVAX);\n\n        amount = Math.min(yakStakingContract.balanceOf(address(this)), amount);\n\n        yakStakingContract.withdraw(amount);\n\n        uint256 depositTokenBalanceAfterWithdrawal = address(this).balance;\n\n        IWrappedNativeToken(AVAX_TOKEN).deposit{value: depositTokenBalanceAfterWithdrawal}();\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, AVAX_TOKEN, depositTokenBalanceAfterWithdrawal);\n        _decreaseExposure(tokenManager, YY_AAVE_AVAX, amount);\n\n        emit Unstaked(\n            msg.sender,\n            \"AVAX\",\n            YY_AAVE_AVAX,\n            depositTokenBalanceAfterWithdrawal,\n            amount,\n            block.timestamp\n        );\n    }\n\n    /**\n    * Unstakes sAVAX from Yield Yak protocol\n    * @dev This function uses the redstone-evm-connector\n        * @param amount amount of sAVAX to be unstaked\n    **/\n    function unstakeSAVAXYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: SAVAX_TOKEN,\n        vaultAddress: YY_PTP_sAVAX,\n        tokenSymbol: \"sAVAX\",\n        vaultTokenSymbol: \"YY_PTP_sAVAX\",\n        amount: amount\n        }));\n    }\n\n    /**\n    * Unstakes GLP from Yield Yak protocol\n    * @dev This function uses the redstone-evm-connector\n        * @param amount amount of GLP to be unstaked\n    **/\n    function unstakeGLPYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: GLP_TOKEN,\n        vaultAddress: YY_GLP,\n        tokenSymbol: \"GLP\",\n        vaultTokenSymbol: \"YY_GLP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Unstakes PNG_AVAX_USDC_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_USDC_LP to be staked\n    **/\n    function unstakePNGAVAXUSDCYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: PNG_AVAX_USDC_LP,\n        vaultAddress: YY_PNG_AVAX_USDC_LP,\n        tokenSymbol: \"PNG_AVAX_USDC_LP\",\n        vaultTokenSymbol: \"YY_PNG_AVAX_USDC_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Unstakes PNG_AVAX_ETH_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of PNG_AVAX_ETH_LP to be unstaked\n    **/\n    function unstakePNGAVAXETHYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: PNG_AVAX_ETH_LP,\n        vaultAddress: YY_PNG_AVAX_ETH_LP,\n        tokenSymbol: \"PNG_AVAX_ETH_LP\",\n        vaultTokenSymbol: \"YY_PNG_AVAX_ETH_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Unstakes TJ_AVAX_USDC in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_USDC to be unstaked\n    **/\n    function unstakeTJAVAXUSDCYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: TJ_AVAX_USDC_LP,\n        vaultAddress: YY_TJ_AVAX_USDC_LP,\n        tokenSymbol: \"TJ_AVAX_USDC_LP\",\n        vaultTokenSymbol: \"YY_TJ_AVAX_USDC_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Unstakes TJ_AVAX_ETH_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_ETH_LP to be unstaked\n    **/\n    function unstakeTJAVAXETHYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: TJ_AVAX_ETH_LP,\n        vaultAddress: YY_TJ_AVAX_ETH_LP,\n        tokenSymbol: \"TJ_AVAX_ETH_LP\",\n        vaultTokenSymbol: \"YY_TJ_AVAX_ETH_LP\",\n        amount: amount\n        }));\n    }\n\n    /**\n      * Unstakes TJ_AVAX_sAVAX_LP in Yield Yak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param amount amount of TJ_AVAX_sAVAX_LP to be unstaked\n    **/\n    function unstakeTJAVAXSAVAXYak(uint256 amount) public onlyOwnerOrInsolvent nonReentrant {\n        _unstakeTokenYY(IYieldYak.YYStakingDetails({\n        tokenAddress: TJ_AVAX_sAVAX_LP,\n        vaultAddress: YY_TJ_AVAX_sAVAX_LP,\n        tokenSymbol: \"TJ_AVAX_sAVAX_LP\",\n        vaultTokenSymbol: \"YY_TJ_AVAX_sAVAX_LP\",\n        amount: amount\n        }));\n    }\n\n    // ----- PRIVATE METHODS -----\n\n    /**\n      * Stakes {stakingDetails.tokenAddress} token in the YieldYak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param stakingDetails IYieldYak.YYStakingDetails staking details\n    **/\n    function _stakeTokenYY(IYieldYak.YYStakingDetails memory stakingDetails) private {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        IERC20Metadata yrtToken = IERC20Metadata(stakingDetails.vaultAddress);\n        uint256 initialYRTBalance = yrtToken.balanceOf(address(this));\n\n        stakingDetails.amount = Math.min(IERC20Metadata(stakingDetails.tokenAddress).balanceOf(address(this)), stakingDetails.amount);\n        require(stakingDetails.amount > 0, \"Cannot stake 0 tokens\");\n        // _ACTIVE = 2\n        require(tokenManager.tokenToStatus(stakingDetails.tokenAddress) == 2, \"Token not supported\");\n        require(tokenManager.tokenToStatus(stakingDetails.vaultAddress) == 2, \"Vault token not supported\");\n\n        stakingDetails.tokenAddress.safeApprove(stakingDetails.vaultAddress, 0);\n        stakingDetails.tokenAddress.safeApprove(stakingDetails.vaultAddress, stakingDetails.amount);\n        IYieldYak(stakingDetails.vaultAddress).deposit(stakingDetails.amount);\n\n        uint256 yrtTokenReceived = yrtToken.balanceOf(address(this)) - initialYRTBalance;\n        _increaseExposure(tokenManager, stakingDetails.vaultAddress, yrtTokenReceived);\n        _decreaseExposure(tokenManager, stakingDetails.tokenAddress, stakingDetails.amount);\n\n        emit Staked(\n            msg.sender,\n            stakingDetails.tokenSymbol,\n            stakingDetails.vaultAddress,\n            stakingDetails.amount,\n            yrtTokenReceived,\n            block.timestamp);\n    }\n\n    /**\n      * Unstakes {stakingDetails.tokenAddress} token in the YieldYak protocol\n      * @dev This function uses the redstone-evm-connector\n      * @param stakingDetails IYieldYak.YYStakingDetails staking details\n    **/\n    function _unstakeTokenYY(IYieldYak.YYStakingDetails memory stakingDetails) private {\n        IYieldYak vaultContract = IYieldYak(stakingDetails.vaultAddress);\n        IERC20Metadata depositToken = IERC20Metadata(stakingDetails.tokenAddress);\n        uint256 initialDepositTokenBalance = depositToken.balanceOf(address(this));\n        stakingDetails.amount = Math.min(vaultContract.balanceOf(address(this)), stakingDetails.amount);\n\n        vaultContract.withdraw(stakingDetails.amount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        uint256 depositTokenReceived = depositToken.balanceOf(address(this)) - initialDepositTokenBalance;\n        _increaseExposure(tokenManager, stakingDetails.tokenAddress, depositTokenReceived);\n        _decreaseExposure(tokenManager, stakingDetails.vaultAddress, stakingDetails.amount);\n\n        emit Unstaked(\n            msg.sender,\n            stakingDetails.tokenSymbol,\n            stakingDetails.vaultAddress,\n            depositToken.balanceOf(address(this)) - initialDepositTokenBalance,\n            stakingDetails.amount,\n            block.timestamp);\n    }\n\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of the vault token\n        * @param depositTokenAmount how much of deposit token was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param vault address of the vault token\n        * @param asset the asset that was unstaked\n        * @param depositTokenAmount how much deposit token was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n}"
    },
    "contracts/facets/avalanche/YieldYakSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ec6e7a0ed7ef3d10f4007e7ebad336dc88392717;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../../interfaces/facets/IYieldYakRouter.sol\";\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../lib/SolvencyMethods.sol\";\nimport \"../../interfaces/ITokenManager.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract YieldYakSwapFacet is ReentrancyGuardKeccak, SolvencyMethods {\n    using TransferHelper for address;\n\n    struct SwapTokensDetails {\n        bytes32 tokenSoldSymbol;\n        bytes32 tokenBoughtSymbol;\n        IERC20Metadata soldToken;\n        IERC20Metadata boughtToken;\n        uint256 initialSoldTokenBalance;\n        uint256 initialBoughtTokenBalance;\n    }\n\n    function getInitialTokensDetails(address _soldTokenAddress, address _boughtTokenAddress) internal returns (SwapTokensDetails memory){\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        if (_boughtTokenAddress == 0xaE64d55a6f09E4263421737397D1fdFA71896a69) {\n            _boughtTokenAddress = 0x9e295B5B976a184B14aD8cd72413aD846C299660;\n        }\n\n        if (_soldTokenAddress == 0x9e295B5B976a184B14aD8cd72413aD846C299660) {\n            _soldTokenAddress = 0xaE64d55a6f09E4263421737397D1fdFA71896a69;\n        }\n\n        bytes32 _tokenSoldSymbol = tokenManager.tokenAddressToSymbol(_soldTokenAddress);\n        bytes32 _tokenBoughtSymbol = tokenManager.tokenAddressToSymbol(_boughtTokenAddress);\n\n        require(tokenManager.isTokenAssetActive(_boughtTokenAddress), \"Asset not supported.\");\n\n        IERC20Metadata _soldToken = IERC20Metadata(_soldTokenAddress);\n        IERC20Metadata _boughtToken = IERC20Metadata(_boughtTokenAddress);\n\n        return SwapTokensDetails({\n            tokenSoldSymbol: _tokenSoldSymbol,\n            tokenBoughtSymbol: _tokenBoughtSymbol,\n            soldToken: _soldToken,\n            boughtToken: _boughtToken,\n            initialSoldTokenBalance: _soldToken.balanceOf(address(this)),\n            initialBoughtTokenBalance: _boughtToken.balanceOf(address(this))\n        });\n    }\n\n    function yakSwap(uint256 _amountIn, uint256 _amountOut, address[] calldata _path, address[] calldata _adapters) external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent{\n        SwapTokensDetails memory swapTokensDetails = getInitialTokensDetails(_path[0], _path[_path.length - 1]);\n\n        _amountIn = Math.min(swapTokensDetails.soldToken.balanceOf(address(this)), _amountIn);\n        require(_amountIn > 0, \"Amount of tokens to sell has to be greater than 0\");\n\n        address(swapTokensDetails.soldToken).safeApprove(YY_ROUTER(), 0);\n        address(swapTokensDetails.soldToken).safeApprove(YY_ROUTER(), _amountIn);\n\n        IYieldYakRouter router = IYieldYakRouter(YY_ROUTER());\n\n        IYieldYakRouter.Trade memory trade = IYieldYakRouter.Trade({\n            amountIn: _amountIn,\n            amountOut: _amountOut,\n            path: _path,\n            adapters: _adapters\n        });\n\n        router.swapNoSplit(trade, address(this), 0);\n\n        uint256 boughtTokenFinalAmount = swapTokensDetails.boughtToken.balanceOf(address(this)) - swapTokensDetails.initialBoughtTokenBalance;\n        require(boughtTokenFinalAmount >= _amountOut, \"Insufficient output amount\");\n\n        uint256 soldTokenFinalAmount = swapTokensDetails.initialSoldTokenBalance - swapTokensDetails.soldToken.balanceOf(address(this));\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(swapTokensDetails.boughtToken), boughtTokenFinalAmount);\n        _decreaseExposure(tokenManager, address(swapTokensDetails.soldToken), soldTokenFinalAmount);\n\n        emit Swap(\n            msg.sender,\n            swapTokensDetails.tokenSoldSymbol,\n            swapTokensDetails.tokenBoughtSymbol,\n            soldTokenFinalAmount,\n            boughtTokenFinalAmount,\n            block.timestamp\n        );\n\n    }\n\n    function YY_ROUTER() internal virtual pure returns (address) {\n        return 0xC4729E56b831d74bBc18797e0e17A295fA77488c;\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /**\n     * @dev emitted after a swap of assets\n     * @param user the address of user making the purchase\n     * @param soldAsset sold by the user\n     * @param boughtAsset bought by the user\n     * @param amountSold amount of tokens sold\n     * @param amountBought amount of tokens bought\n     * @param timestamp time of the swap\n     **/\n    event Swap(address indexed user, bytes32 indexed soldAsset, bytes32 indexed boughtAsset, uint256 amountSold, uint256 amountBought, uint256 timestamp);\n}\n"
    },
    "contracts/facets/avalanche/YieldYakWombatFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/facets/avalanche/IWombatPool.sol\";\nimport \"../../interfaces/facets/avalanche/IYYWombatPool.sol\";\nimport \"../../interfaces/facets/avalanche/IWombatMaster.sol\";\nimport \"../../interfaces/facets/avalanche/IWombatRouter.sol\";\nimport \"../../interfaces/facets/avalanche/IRewarder.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract YieldYakWombatFacet is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    address public constant WOM_TOKEN =\n        0xa15E4544D141aa98C4581a1EA10Eb9048c3b3382;\n    address public constant WOMBAT_ROUTER =\n        0x4A88C44B8D9B9f3F2BA4D97236F737CF03DF76CD;\n    address public constant WOMBAT_MASTER =\n        0x6521a549834F5E6d253CD2e5F4fbe4048f86cd7b;\n    address public constant WOMBAT_sAVAX_AVAX_POOL =\n        0xE3Abc29B035874a9f6dCDB06f8F20d9975069D87;\n    address public constant WOMBAT_ggAVAX_AVAX_POOL =\n        0xBbA43749efC1bC29eA434d88ebaf8A97DC7aEB77;\n\n    bytes32 public constant WOMBAT_ggAVAX_AVAX_LP_AVAX =\n        \"WOMBAT_ggAVAX_AVAX_LP_AVAX\";\n    bytes32 public constant WOMBAT_ggAVAX_AVAX_LP_ggAVAX =\n        \"WOMBAT_ggAVAX_AVAX_LP_ggAVAX\";\n    bytes32 public constant WOMBAT_sAVAX_AVAX_LP_AVAX =\n        \"WOMBAT_sAVAX_AVAX_LP_AVAX\";\n    bytes32 public constant WOMBAT_sAVAX_AVAX_LP_sAVAX =\n        \"WOMBAT_sAVAX_AVAX_LP_sAVAX\";\n\n    bytes32 public constant YY_ggAVAX_AVAX_LP_AVAX = \"YY_ggAVAX_AVAX_LP_AVAX\";\n    bytes32 public constant YY_ggAVAX_AVAX_LP_ggAVAX = \"YY_ggAVAX_AVAX_LP_ggAVAX\";\n    bytes32 public constant YY_sAVAX_AVAX_LP_AVAX = \"YY_sAVAX_AVAX_LP_AVAX\";\n    bytes32 public constant YY_sAVAX_AVAX_LP_sAVAX = \"YY_sAVAX_AVAX_LP_sAVAX\";\n\n    function depositSavaxToAvaxSavaxYY(\n        uint256 amount,\n        uint256 minLpOut\n    ) external {\n        _depositToken(\n            \"sAVAX\",\n            WOMBAT_sAVAX_AVAX_LP_sAVAX,\n            YY_sAVAX_AVAX_LP_sAVAX,\n            WOMBAT_sAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.sAvaxBalanceAvaxSavaxYY.selector,\n            this.withdrawSavaxFromAvaxSavaxYY.selector\n        );\n    }\n\n    function withdrawSavaxFromAvaxSavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"sAVAX\",\n                \"sAVAX\",\n                WOMBAT_sAVAX_AVAX_LP_sAVAX,\n                YY_sAVAX_AVAX_LP_sAVAX,\n                WOMBAT_sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function sAvaxBalanceAvaxSavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(YY_sAVAX_AVAX_LP_sAVAX);\n    }\n\n    function depositGgavaxToAvaxGgavaxYY(\n        uint256 amount,\n        uint256 minLpOut\n    ) external {\n        _depositToken(\n            \"ggAVAX\",\n            WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n            YY_ggAVAX_AVAX_LP_ggAVAX,\n            WOMBAT_ggAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.ggAvaxBalanceAvaxGgavaxYY.selector,\n            this.withdrawGgavaxFromAvaxGgavaxYY.selector\n        );\n    }\n\n    function withdrawGgavaxFromAvaxGgavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"ggAVAX\",\n                \"ggAVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n                YY_ggAVAX_AVAX_LP_ggAVAX,\n                WOMBAT_ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function ggAvaxBalanceAvaxGgavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(YY_ggAVAX_AVAX_LP_ggAVAX);\n    }\n\n    function depositAvaxToAvaxSavaxYY(uint256 amount, uint256 minLpOut) external {\n        _depositNative(\n            WOMBAT_sAVAX_AVAX_LP_AVAX,\n            YY_sAVAX_AVAX_LP_AVAX,\n            WOMBAT_sAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.avaxBalanceAvaxSavaxYY.selector,\n            this.withdrawAvaxFromAvaxSavaxYY.selector\n        );\n    }\n\n    function withdrawAvaxFromAvaxSavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"AVAX\",\n                WOMBAT_sAVAX_AVAX_LP_AVAX,\n                YY_sAVAX_AVAX_LP_AVAX,\n                WOMBAT_sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function avaxBalanceAvaxSavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(YY_sAVAX_AVAX_LP_AVAX);\n    }\n\n    function depositAvaxToAvaxGgavaxYY(\n        uint256 amount,\n        uint256 minLpOut\n    ) external {\n        _depositNative(\n            WOMBAT_ggAVAX_AVAX_LP_AVAX,\n            YY_ggAVAX_AVAX_LP_AVAX,\n            WOMBAT_ggAVAX_AVAX_POOL,\n            amount,\n            minLpOut,\n            this.avaxBalanceAvaxGgavaxYY.selector,\n            this.withdrawAvaxFromAvaxGgavaxYY.selector\n        );\n    }\n\n    function withdrawAvaxFromAvaxGgavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"AVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_AVAX,\n                YY_ggAVAX_AVAX_LP_AVAX,\n                WOMBAT_ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function avaxBalanceAvaxGgavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance)\n    {\n        return getLpTokenBalance(YY_ggAVAX_AVAX_LP_AVAX);\n    }\n\n    function withdrawSavaxFromAvaxSavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"AVAX\",\n                \"sAVAX\",\n                WOMBAT_sAVAX_AVAX_LP_AVAX,\n                YY_sAVAX_AVAX_LP_AVAX,\n                WOMBAT_sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function withdrawGgavaxFromAvaxGgavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawToken(\n                \"AVAX\",\n                \"ggAVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_AVAX,\n                YY_ggAVAX_AVAX_LP_AVAX,\n                WOMBAT_ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function withdrawAvaxFromAvaxSavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"sAVAX\",\n                WOMBAT_sAVAX_AVAX_LP_sAVAX,\n                YY_sAVAX_AVAX_LP_sAVAX,\n                WOMBAT_sAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function withdrawAvaxFromAvaxGgavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut) {\n        return\n            _withdrawNative(\n                \"ggAVAX\",\n                WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n                YY_ggAVAX_AVAX_LP_ggAVAX,\n                WOMBAT_ggAVAX_AVAX_POOL,\n                amount,\n                minOut\n            );\n    }\n\n    function depositAndStakeAvaxSavaxLpSavaxYY(uint256 amount) external {\n        _depositAndStakeWombatLPYY(\n            WOMBAT_sAVAX_AVAX_LP_sAVAX,\n            YY_sAVAX_AVAX_LP_sAVAX,\n            amount,\n            this.sAvaxBalanceAvaxSavaxYY.selector,\n            this.unstakeAndWithdrawAvaxSavaxLpSavaxYY.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxSavaxLpSavaxYY(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return\n            _unstakeAndWithdrawWombatLP(\n                WOMBAT_sAVAX_AVAX_LP_sAVAX,\n                YY_sAVAX_AVAX_LP_sAVAX,\n                amount\n            );\n    }\n\n    function depositAndStakeAvaxSavaxLpAvaxYY(uint256 amount) external {\n        _depositAndStakeWombatLPYY(\n            WOMBAT_sAVAX_AVAX_LP_AVAX,\n            YY_sAVAX_AVAX_LP_AVAX,\n            amount,\n            this.avaxBalanceAvaxSavaxYY.selector,\n            this.unstakeAndWithdrawAvaxSavaxLpAvaxYY.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxSavaxLpAvaxYY(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return\n            _unstakeAndWithdrawWombatLP(\n                WOMBAT_sAVAX_AVAX_LP_AVAX,\n                YY_sAVAX_AVAX_LP_AVAX,\n                amount\n            );\n    }\n\n    function depositAvaxGgavaxLpGgavaxYY(uint256 amount) external {\n        _depositAndStakeWombatLPYY(\n            WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n            YY_ggAVAX_AVAX_LP_ggAVAX,\n            amount,\n            this.ggAvaxBalanceAvaxGgavaxYY.selector,\n            this.unstakeAndWithdrawAvaxGgavaxLpGgavaxYY.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxGgavaxLpGgavaxYY(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return\n            _unstakeAndWithdrawWombatLP(\n                WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n                YY_ggAVAX_AVAX_LP_ggAVAX,\n                amount\n            );\n    }\n\n    function depositAndStakeAvaxGgavaxLpAvaxYY(uint256 amount) external {\n        _depositAndStakeWombatLPYY(\n            WOMBAT_ggAVAX_AVAX_LP_AVAX,\n            YY_ggAVAX_AVAX_LP_AVAX,\n            amount,\n            this.avaxBalanceAvaxGgavaxYY.selector,\n            this.unstakeAndWithdrawAvaxGgavaxLpAvaxYY.selector\n        );\n    }\n\n    function unstakeAndWithdrawAvaxGgavaxLpAvaxYY(\n        uint256 amount\n    ) external returns (uint256 amountOut) {\n        return\n            _unstakeAndWithdrawWombatLP(\n                WOMBAT_ggAVAX_AVAX_LP_AVAX,\n                YY_ggAVAX_AVAX_LP_AVAX,\n                amount\n            );\n    }\n\n    function migrateAvaxSavaxLpSavaxFromWombatToYY() external {\n        _migrate(\n            WOMBAT_sAVAX_AVAX_LP_sAVAX,\n            YY_sAVAX_AVAX_LP_sAVAX,\n            this.sAvaxBalanceAvaxSavaxYY.selector,\n            this.withdrawSavaxFromAvaxSavaxYY.selector\n        );\n    }\n\n    function migrateAvaxGgavaxLpGgavaxFromWombatToYY() external {\n        _migrate(\n            WOMBAT_ggAVAX_AVAX_LP_ggAVAX,\n            YY_ggAVAX_AVAX_LP_ggAVAX,\n            this.ggAvaxBalanceAvaxGgavaxYY.selector,\n            this.withdrawGgavaxFromAvaxGgavaxYY.selector\n        );\n    }\n\n    function migrateAvaxSavaxLpAvaxFromWombatToYY() external {\n        _migrate(\n            WOMBAT_sAVAX_AVAX_LP_AVAX,\n            YY_sAVAX_AVAX_LP_AVAX,\n            this.avaxBalanceAvaxSavaxYY.selector,\n            this.withdrawAvaxFromAvaxSavaxYY.selector\n        );\n    }\n\n    function migrateAvaxGgavaxLpAvaxFromWombatToYY() external {\n        _migrate(\n            WOMBAT_ggAVAX_AVAX_LP_AVAX,\n            YY_ggAVAX_AVAX_LP_AVAX,\n            this.avaxBalanceAvaxGgavaxYY.selector,\n            this.withdrawAvaxFromAvaxGgavaxYY.selector\n        );\n    }\n\n    function _depositToken(\n        bytes32 stakeAsset,\n        bytes32 wombatLpAsset,\n        bytes32 yyLpAsset,\n        address wombatPool,\n        uint256 amount,\n        uint256 minLpOut,\n        bytes4 balanceSelector,\n        bytes4 unstakeSelector\n    ) internal onlyOwner nonReentrant remainsSolvent {\n        IERC20Metadata stakeToken = getERC20TokenInstance(stakeAsset, false);\n        IERC20Metadata wombatLpToken = getERC20TokenInstance(wombatLpAsset, false);\n        address yyLpToken = _getYRT(yyLpAsset);\n\n        amount = Math.min(stakeToken.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot deposit 0 tokens\");\n\n        address(stakeToken).safeApprove(wombatPool, 0);\n        address(stakeToken).safeApprove(wombatPool, amount);\n\n        IWombatPool(wombatPool).deposit(\n            address(stakeToken),\n            amount,\n            minLpOut,\n            address(this),\n            block.timestamp,\n            false\n        );\n\n        uint256 wombatLpAmount = wombatLpToken.balanceOf(address(this));\n\n        address(wombatLpToken).safeApprove(yyLpToken, 0);\n        address(wombatLpToken).safeApprove(yyLpToken, wombatLpAmount);\n\n        IYYWombatPool(yyLpToken).deposit(wombatLpAmount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, address(stakeToken), amount);\n\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: address(wombatLpToken),\n                symbol: wombatLpAsset,\n                identifier: yyLpAsset,\n                balanceSelector: balanceSelector,\n                unstakeSelector: unstakeSelector\n            });\n        DiamondStorageLib.addStakedPosition(position);\n    }\n\n    function _withdrawToken(\n        bytes32 fromAsset,\n        bytes32 toAsset,\n        bytes32 wombatLpAsset,\n        bytes32 yyLpAsset,\n        address pool,\n        uint256 amount,\n        uint256 minOut\n    ) internal onlyOwnerOrInsolvent nonReentrant returns (uint256 amountOut) {\n        IERC20Metadata fromToken = getERC20TokenInstance(fromAsset, false);\n        IERC20Metadata toToken = getERC20TokenInstance(toAsset, false);\n        IERC20Metadata wombatLpToken = getERC20TokenInstance(wombatLpAsset, false);\n        address yyLpToken = _getYRT(yyLpAsset);\n\n        amount = Math.min(amount, IERC20Metadata(yyLpToken).balanceOf(address(this)));\n        require(amount > 0, \"Cannot withdraw 0 tokens\");\n\n        IYYWombatPool(yyLpToken).withdraw(amount);\n\n        uint256 wombatLpAmount = wombatLpToken.balanceOf(address(this));\n\n        address(wombatLpToken).safeApprove(pool, 0);\n        address(wombatLpToken).safeApprove(pool, wombatLpAmount);\n\n        if (fromAsset == toAsset) {\n            amountOut = IWombatPool(pool).withdraw(\n                address(fromToken),\n                wombatLpAmount,\n                minOut,\n                address(this),\n                block.timestamp\n            );\n        } else {\n            amountOut = IWombatPool(pool).withdrawFromOtherAsset(\n                address(fromToken),\n                address(toToken),\n                wombatLpAmount,\n                minOut,\n                address(this),\n                block.timestamp\n            );\n        }\n\n        if (getLpTokenBalance(yyLpAsset) == 0) {\n            DiamondStorageLib.removeStakedPosition(yyLpAsset);\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(toToken), amountOut);\n    }\n\n    function _depositNative(\n        bytes32 wombatLpAsset,\n        bytes32 yyLpAsset,\n        address pool,\n        uint256 amount,\n        uint256 minLpOut,\n        bytes4 balanceSelector,\n        bytes4 unstakeSelector\n    ) internal onlyOwner nonReentrant remainsSolvent {\n        IWrappedNativeToken wrapped = IWrappedNativeToken(\n            DeploymentConstants.getNativeToken()\n        );\n        IERC20Metadata wombatLpToken = getERC20TokenInstance(wombatLpAsset, false);\n        address yyLpToken = _getYRT(yyLpAsset);\n\n        amount = Math.min(wrapped.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot deposit 0 tokens\");\n\n        wrapped.withdraw(amount);\n\n        IWombatRouter(WOMBAT_ROUTER).addLiquidityNative{value: amount}(\n            pool,\n            minLpOut,\n            address(this),\n            block.timestamp,\n            false\n        );\n\n        uint256 wombatLpAmount = wombatLpToken.balanceOf(address(this));\n\n        address(wombatLpToken).safeApprove(yyLpToken, 0);\n        address(wombatLpToken).safeApprove(yyLpToken, wombatLpAmount);\n\n        IYYWombatPool(yyLpToken).deposit(wombatLpAmount);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, address(wrapped), amount);\n\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: address(wombatLpToken),\n                symbol: wombatLpAsset,\n                identifier: yyLpAsset,\n                balanceSelector: balanceSelector,\n                unstakeSelector: unstakeSelector\n            });\n        DiamondStorageLib.addStakedPosition(position);\n    }\n\n    function _withdrawNative(\n        bytes32 fromAsset,\n        bytes32 wombatLpAsset,\n        bytes32 yyLpAsset,\n        address pool,\n        uint256 amount,\n        uint256 minOut\n    ) internal onlyOwnerOrInsolvent nonReentrant returns (uint256 amountOut) {\n        IERC20Metadata fromToken = getERC20TokenInstance(fromAsset, false);\n        IWrappedNativeToken wrapped = IWrappedNativeToken(\n            DeploymentConstants.getNativeToken()\n        );\n        IERC20Metadata wombatLpToken = getERC20TokenInstance(wombatLpAsset, false);\n        address yyLpToken = _getYRT(yyLpAsset);\n\n        amount = Math.min(amount, IERC20Metadata(yyLpToken).balanceOf(address(this)));\n        require(amount > 0, \"Cannot withdraw 0 tokens\");\n\n        IYYWombatPool(yyLpToken).withdraw(amount);\n\n        uint256 wombatLpAmount = wombatLpToken.balanceOf(address(this));\n\n        address(wombatLpToken).safeApprove(WOMBAT_ROUTER, 0);\n        address(wombatLpToken).safeApprove(WOMBAT_ROUTER, wombatLpAmount);\n\n        if (fromAsset == bytes32(\"AVAX\")) {\n            amountOut = IWombatRouter(WOMBAT_ROUTER).removeLiquidityNative(\n                pool,\n                wombatLpAmount,\n                minOut,\n                address(this),\n                block.timestamp\n            );\n        } else {\n            amountOut = IWombatRouter(WOMBAT_ROUTER)\n                .removeLiquidityFromOtherAssetAsNative(\n                    pool,\n                    address(fromToken),\n                    wombatLpAmount,\n                    minOut,\n                    address(this),\n                    block.timestamp\n                );\n        }\n\n        wrapped.deposit{value: amountOut}();\n\n        if (getLpTokenBalance(yyLpAsset) == 0) {\n            DiamondStorageLib.removeStakedPosition(yyLpAsset);\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(wrapped), amountOut);\n    }\n\n    function _depositAndStakeWombatLPYY(\n        bytes32 wombatLpAsset,\n        bytes32 yyLpAsset,\n        uint256 amount,\n        bytes4 balanceSelector,\n        bytes4 unstakeSelector\n    ) internal onlyOwner nonReentrant remainsSolvent {\n        IERC20Metadata wombatLpToken = getERC20TokenInstance(wombatLpAsset, false);\n        address yyLpToken = _getYRT(yyLpAsset);\n\n        amount = Math.min(amount, wombatLpToken.balanceOf(msg.sender));\n        require(amount > 0, \"Cannot deposit 0 tokens\");\n\n        address(wombatLpToken).safeTransferFrom(msg.sender, address(this), amount);\n\n        address(wombatLpToken).safeApprove(yyLpToken, 0);\n        address(wombatLpToken).safeApprove(yyLpToken, amount);\n\n        IYYWombatPool(yyLpToken).deposit(amount);\n\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: address(wombatLpToken),\n                symbol: wombatLpAsset,\n                identifier: yyLpAsset,\n                balanceSelector: balanceSelector,\n                unstakeSelector: unstakeSelector\n            });\n        DiamondStorageLib.addStakedPosition(position);\n    }\n\n    function _unstakeAndWithdrawWombatLP(\n        bytes32 wombatLpAsset,\n        bytes32 yyLpAsset,\n        uint256 amount\n    )\n        internal\n        onlyOwner\n        nonReentrant\n        remainsSolvent\n        canRepayDebtFully\n        returns (uint256 amountOut)\n    {\n        IERC20Metadata wombatLpToken = getERC20TokenInstance(wombatLpAsset, false);\n        address yyLpToken = _getYRT(yyLpAsset);\n\n        amount = Math.min(amount, IERC20Metadata(yyLpToken).balanceOf(address(this)));\n        require(amount > 0, \"Cannot withdraw 0 tokens\");\n\n        IYYWombatPool(yyLpToken).withdraw(amount);\n\n        address(wombatLpToken).safeTransfer(\n            msg.sender,\n            wombatLpToken.balanceOf(address(this))\n        );\n\n        if (getLpTokenBalance(yyLpAsset) == 0) {\n            DiamondStorageLib.removeStakedPosition(yyLpAsset);\n        }\n\n        return amount;\n    }\n\n    function _migrate(\n        bytes32 wombatLpAsset,\n        bytes32 yyLpAsset,\n        bytes4 balanceSelector,\n        bytes4 unstakeSelector\n    ) internal onlyOwner nonReentrant remainsSolvent {\n        IERC20Metadata wombatLpToken = getERC20TokenInstance(wombatLpAsset, false);\n        address yyLpToken = _getYRT(yyLpAsset);\n        uint256 pid = IWombatMaster(WOMBAT_MASTER).getAssetPid(\n            address(wombatLpToken)\n        );\n\n        IWombatMaster.UserInfo memory userInfo = IWombatMaster(WOMBAT_MASTER)\n            .userInfo(pid, address(this));\n        uint256 wombatLpAmount = userInfo.amount;\n        if (wombatLpAmount == 0) {\n            return;\n        }\n\n        (uint256 reward, uint256[] memory additionalRewards) = IWombatMaster(\n            WOMBAT_MASTER\n        ).withdraw(pid, wombatLpAmount);\n\n        address(wombatLpToken).safeApprove(yyLpToken, 0);\n        address(wombatLpToken).safeApprove(yyLpToken, wombatLpAmount);\n\n        IYYWombatPool(yyLpToken).deposit(wombatLpAmount);\n\n        DiamondStorageLib.removeStakedPosition(wombatLpAsset);\n        IStakingPositions.StakedPosition memory position = IStakingPositions\n            .StakedPosition({\n                asset: address(wombatLpToken),\n                symbol: wombatLpAsset,\n                identifier: yyLpAsset,\n                balanceSelector: balanceSelector,\n                unstakeSelector: unstakeSelector\n            });\n        DiamondStorageLib.addStakedPosition(position);\n\n        handleRewards(pid, reward, additionalRewards);\n    }\n\n    function _getYRT(bytes32 yyLpAsset) internal view returns (address) {\n        if (yyLpAsset == YY_ggAVAX_AVAX_LP_AVAX) {\n            return 0x7f0eB376eabF4b2B4290D09EFb2f4da99B3ea311;\n        }\n        if (yyLpAsset == YY_ggAVAX_AVAX_LP_ggAVAX) {\n            return 0x13404B1C715aF60869fc658d6D99c117e3543592;\n        }\n        if (yyLpAsset == YY_sAVAX_AVAX_LP_AVAX) {\n            return 0xa84D83787eA216F616C6Bd02C6edC6D6d63f042f;\n        }\n        if (yyLpAsset == YY_sAVAX_AVAX_LP_sAVAX) {\n            return 0x9B5d890d563EE4c9255bB500a790Ca6B1FB9dB6b;\n        }\n    }\n\n    function handleRewards(\n        uint256 pid,\n        uint256 reward,\n        uint256[] memory additionalRewards\n    ) internal {\n        (, , address rewarder, , , , ) = IWombatMaster(WOMBAT_MASTER).poolInfo(pid);\n        address boostedRewarder = IWombatMaster(WOMBAT_MASTER).boostedRewarders(\n            pid\n        );\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address owner = DiamondStorageLib.contractOwner();\n\n        if (reward > 0 && tokenManager.isTokenAssetActive(WOM_TOKEN)) {\n            _increaseExposure(tokenManager, WOM_TOKEN, reward);\n        } else if (reward > 0) {\n            WOM_TOKEN.safeTransfer(owner, reward);\n        }\n\n        uint256 baseIdx;\n        if (rewarder != address(0)) {\n            address[] memory rewardTokens = IRewarder(rewarder).rewardTokens();\n            baseIdx = rewardTokens.length;\n            for (uint256 i; i != baseIdx; ++i) {\n                address rewardToken = rewardTokens[i];\n                uint256 pendingReward = additionalRewards[i];\n\n                if (pendingReward == 0) {\n                    continue;\n                }\n\n                if (tokenManager.isTokenAssetActive(rewardToken)) {\n                    _increaseExposure(tokenManager, rewardToken, pendingReward);\n                } else {\n                    rewardToken.safeTransfer(owner, pendingReward);\n                }\n            }\n        }\n        if (boostedRewarder != address(0)) {\n            address[] memory rewardTokens = IRewarder(boostedRewarder).rewardTokens();\n            for (uint256 i; i != rewardTokens.length; ++i) {\n                address rewardToken = rewardTokens[i];\n                uint256 pendingReward = additionalRewards[baseIdx + i];\n\n                if (pendingReward == 0) {\n                    continue;\n                }\n\n                if (tokenManager.isTokenAssetActive(rewardToken)) {\n                    _increaseExposure(tokenManager, rewardToken, pendingReward);\n                } else {\n                    rewardToken.safeTransfer(owner, pendingReward);\n                }\n            }\n        }\n    }\n\n    function getLpTokenBalance(bytes32 asset) internal view returns (uint256) {\n        address lpToken = _getYRT(asset);\n        uint256 balance = IERC20Metadata(lpToken).balanceOf(address(this));\n        return IYYWombatPool(lpToken).getDepositTokensForShares(balance);\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n}\n"
    },
    "contracts/facets/celo/UbeswapDEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2DEXFacet.sol\";\n\ncontract UbeswapDEXFacet is UniswapV2DEXFacet {\n\n    /**\n    * Swaps one asset to another\n    * @dev This function uses the redstone-evm-connector\n    * @param _soldAsset asset to be sold\n    * @param _boughtAsset asset to be bought\n    * @param _exactSold exact amount of asset to be sold\n    * @param _minimumBought minimum amount of asset to be bought\n    **/\n    function swapUbeswap(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) public onlyOwner returns (uint256[] memory) {\n        return swapAssets(_soldAsset, _boughtAsset, _exactSold, _minimumBought);\n    }\n\n    /**\n     * Returns address of UniswapV2-like exchange\n     **/\n    function getExchangeIntermediaryContract() public override returns (address) {\n        return 0xd8edCc7162281abFFbd65d4a1b260ef1275e1EAc;\n    }\n}"
    },
    "contracts/facets/DiamondCutFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\ncontract DiamondCutFacet is IDiamondCut {\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external override paused {\n        require(address(this) == 0x62Cf82FB0484aF382714cD09296260edc1DC0c6c, \"This can be called only on the DiamondBeacon contract\"); // DiamondBeacon address on Arbitrum TODO: Replace with relevant address prior to deploying\n        DiamondStorageLib.enforceIsContractOwner();\n        DiamondStorageLib.diamondCut(_diamondCut, _init, _calldata);\n    }\n\n    function unpause() external override {\n        DiamondStorageLib.enforceIsPauseAdmin();\n\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        require(!ds._active, \"ProtocolUpgrade: already unpaused.\");\n        ds._active = true;\n    }\n\n    function pause() external override {\n        DiamondStorageLib.enforceIsPauseAdmin();\n\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        require(ds._active, \"ProtocolUpgrade: already paused.\");\n        ds._active = false;\n    }\n\n    modifier paused() {\n        DiamondStorageLib.DiamondStorage storage ds;\n        bytes32 position = DiamondStorageLib.DIAMOND_STORAGE_POSITION;\n        // get diamond storage\n        assembly {\n            ds.slot := position\n        }\n        require(!ds._active, \"ProtocolUpgrade: not paused.\");\n\n        _;\n    }\n}"
    },
    "contracts/facets/DiamondInit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n*\n* Implementation of a diamond.\n/******************************************************************************/\n\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport {IERC173} from \"../interfaces/IERC173.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n// It is exapected that this contract is customized if you want to deploy your diamond\n// with data from a deployment script. Use the init function to initialize state variables\n// of your diamond. Add parameters to the init funciton if you need to.\n\ncontract DiamondInit {\n\n    // You can add parameters to this function in order to pass in \n    // data to set your own state variables\n    function init() external {\n        // DiamondStorage\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n\n        require(!ds._initialized, \"DiamondInit: contract is already initialized\");\n\n        // adding ERC165 data\n        ds.supportedInterfaces[type(IERC165).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondCut).interfaceId] = true;\n        ds.supportedInterfaces[type(IDiamondLoupe).interfaceId] = true;\n        ds.supportedInterfaces[type(IERC173).interfaceId] = true;\n\n        DiamondStorageLib.setContractOwner(msg.sender);\n        ds._initialized = true;\n        ds._active = false;\n\n        // add your own state variables \n        // EIP-2535 specifies that the `diamondCut` function takes two optional \n        // arguments: address _init and bytes calldata _calldata\n        // These arguments are used to execute an arbitrary function using delegatecall\n        // in order to set state variables in the diamond during deployment or an upgrade\n        // More info here: https://eips.ethereum.org/EIPS/eip-2535#diamond-interface \n    }\n\n\n}"
    },
    "contracts/facets/DiamondLoupeFacet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\nimport {DiamondStorageLib} from  \"../lib/DiamondStorageLib.sol\";\nimport {IDiamondLoupe} from \"../interfaces/IDiamondLoupe.sol\";\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n// The functions in DiamondLoupeFacet MUST be added to a diamond.\n// The EIP-2535 Diamond standard requires these functions.\n\ncontract DiamondLoupeFacet is IDiamondLoupe, IERC165 {\n    // Diamond Loupe Functions\n    ////////////////////////////////////////////////////////////////////\n    /// These functions are expected to be called frequently by tools.\n    //\n    // struct Facet {\n    //     address facetAddress;\n    //     bytes4[] functionSelectors;\n    // }\n\n    /// @notice Gets all facets and their selectors.\n    /// @return facets_ Facet\n    function facets() external override view returns (Facet[] memory facets_) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        uint256 numFacets = ds.facetAddresses.length;\n        facets_ = new Facet[](numFacets);\n        for (uint256 i; i < numFacets; i++) {\n            address facetAddress_ = ds.facetAddresses[i];\n            facets_[i].facetAddress = facetAddress_;\n            facets_[i].functionSelectors = ds.facetFunctionSelectors[facetAddress_].functionSelectors;\n        }\n    }\n\n    /// @notice Gets all the function selectors provided by a facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external override view returns (bytes4[] memory facetFunctionSelectors_) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        facetFunctionSelectors_ = ds.facetFunctionSelectors[_facet].functionSelectors;\n    }\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external override view returns (address[] memory facetAddresses_) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        facetAddresses_ = ds.facetAddresses;\n    }\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external override view returns (address facetAddress_) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        facetAddress_ = ds.selectorToFacetAndPosition[_functionSelector].facetAddress;\n    }\n\n    // This implements ERC-165.\n    function supportsInterface(bytes4 _interfaceId) external override view returns (bool) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        return ds.supportedInterfaces[_interfaceId];\n    }\n}"
    },
    "contracts/facets/GmxV2CallbacksFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 799a1765b64edc5c158198ef84f785af79e234ae;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"../lib/SolvencyMethods.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport \"../interfaces/ITokenManager.sol\";\nimport \"../interfaces/IWrappedNativeToken.sol\";\n\nimport \"../interfaces/gmx-v2/Deposit.sol\";\nimport \"../interfaces/gmx-v2/Withdrawal.sol\";\nimport \"../interfaces/gmx-v2/IRoleStore.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/gmx-v2/IDepositCallbackReceiver.sol\";\nimport \"../interfaces/gmx-v2/EventUtils.sol\";\nimport \"../interfaces/gmx-v2/IWithdrawalCallbackReceiver.sol\";\nimport \"../interfaces/gmx-v2/IGasFeeCallbackReceiver.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\nabstract contract GmxV2CallbacksFacet is IDepositCallbackReceiver, IWithdrawalCallbackReceiver, IGasFeeCallbackReceiver, ReentrancyGuardKeccak, SolvencyMethods {\n    using TransferHelper for address;\n    using Deposit for Deposit.Props;\n    using Withdrawal for Withdrawal.Props;\n\n    // CONSTANTS\n    bytes32 constant public CONTROLLER = keccak256(abi.encode(\"CONTROLLER\"));\n\n    // GMX contracts\n    function getGmxV2RoleStore() internal pure virtual returns (address);\n\n    // Mappings\n    function marketToLongToken(address market) internal virtual pure returns (address);\n\n    function marketToShortToken(address market) internal virtual pure returns (address);\n\n    function isCallerAuthorized(address _caller) internal view returns (bool){\n        IRoleStore roleStore = IRoleStore(getGmxV2RoleStore());\n        if(roleStore.hasRole(_caller, CONTROLLER)){\n            return true;\n        }\n        return false;\n    }\n\n    function wrapNativeToken() internal {\n        uint256 balance = address(this).balance;\n        if(balance > 0){\n            IWrappedNativeToken nativeToken = IWrappedNativeToken(DeploymentConstants.getNativeToken());\n            nativeToken.deposit{value : balance}();\n            ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n            _increaseExposure(tokenManager, address(nativeToken), balance);\n        }\n    }\n\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external onlyGmxV2Keeper nonReentrant override {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        uint256 receivedMarketTokens = eventData.uintItems.items[0].value;\n        address gmToken = deposit.addresses.market;\n\n        uint256 gmTokenBalance = IERC20Metadata(gmToken).balanceOf(address(this));\n        // Add owned assets\n        if( gmTokenBalance > 0){\n            DiamondStorageLib.addOwnedAsset(tokenManager.tokenAddressToSymbol(gmToken), gmToken);\n        }\n\n        // Native token transfer happens after execution of this method, but the amounts should be dust ones anyway and by wrapping here we get a chance to wrap any previously sent native token\n        wrapNativeToken();\n\n        tokenManager.increaseProtocolExposure(\n            tokenManager.tokenAddressToSymbol(gmToken),\n            receivedMarketTokens * 1e18 / 10**IERC20Metadata(gmToken).decimals()\n        );\n\n        tokenManager.setPendingExposureToZero(tokenManager.tokenAddressToSymbol(gmToken), deposit.account());\n        \n        // Unfreeze account\n        DiamondStorageLib.unfreezeAccount(msg.sender);\n\n        emit DepositExecuted(\n            msg.sender,\n            deposit.addresses.market,\n            receivedMarketTokens,\n            deposit.numbers.executionFee\n        );\n    }\n\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external onlyGmxV2Keeper nonReentrant override {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address longToken = marketToLongToken(deposit.addresses.market);\n        address shortToken = marketToShortToken(deposit.addresses.market);\n\n\n        // Add owned assets\n        if(IERC20Metadata(longToken).balanceOf(address(this)) > 0){\n            DiamondStorageLib.addOwnedAsset(tokenManager.tokenAddressToSymbol(longToken), longToken);\n        }\n        if(IERC20Metadata(shortToken).balanceOf(address(this)) > 0){\n            DiamondStorageLib.addOwnedAsset(tokenManager.tokenAddressToSymbol(shortToken), shortToken);\n        }\n\n        // Native token transfer happens after execution of this method, but the amounts should be dust ones anyway and by wrapping here we get a chance to wrap any previously sent native token\n        wrapNativeToken();\n\n        if(deposit.numbers.initialLongTokenAmount > 0) {\n            tokenManager.increaseProtocolExposure(\n                tokenManager.tokenAddressToSymbol(longToken),\n                deposit.numbers.initialLongTokenAmount * 1e18 / 10**IERC20Metadata(longToken).decimals()\n            );\n        }\n        if(deposit.numbers.initialShortTokenAmount > 0) {\n            tokenManager.increaseProtocolExposure(\n                tokenManager.tokenAddressToSymbol(shortToken),\n                deposit.numbers.initialShortTokenAmount * 1e18 / 10**IERC20Metadata(shortToken).decimals()\n            );\n        }\n\n        tokenManager.setPendingExposureToZero(tokenManager.tokenAddressToSymbol(deposit.addresses.market), deposit.account());\n\n        DiamondStorageLib.unfreezeAccount(msg.sender);\n        emit DepositCancelled(\n            msg.sender,\n            deposit.addresses.market,\n            deposit.numbers.executionFee\n        );\n    }\n\n    function afterWithdrawalExecution(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external onlyGmxV2Keeper nonReentrant override {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address longToken = marketToLongToken(withdrawal.addresses.market);\n        address shortToken = marketToShortToken(withdrawal.addresses.market);\n        uint256 longOutputAmount = eventData.uintItems.items[0].value;\n        uint256 shortOutputAmount = eventData.uintItems.items[1].value;\n\n        // Add owned assets\n        if(IERC20Metadata(longToken).balanceOf(address(this)) > 0){\n            DiamondStorageLib.addOwnedAsset(tokenManager.tokenAddressToSymbol(longToken), longToken);\n        }\n        if(IERC20Metadata(shortToken).balanceOf(address(this)) > 0){\n            DiamondStorageLib.addOwnedAsset(tokenManager.tokenAddressToSymbol(shortToken), shortToken);\n        }\n        \n        if(longOutputAmount > 0) {\n            tokenManager.increaseProtocolExposure(\n                tokenManager.tokenAddressToSymbol(longToken),\n                longOutputAmount * 1e18 / 10**IERC20Metadata(longToken).decimals()\n            );\n        }\n        if(shortOutputAmount > 0) {\n            tokenManager.increaseProtocolExposure(\n                tokenManager.tokenAddressToSymbol(shortToken),\n                shortOutputAmount * 1e18 / 10**IERC20Metadata(shortToken).decimals()\n            );\n        }\n\n        tokenManager.setPendingExposureToZero(tokenManager.tokenAddressToSymbol(longToken), withdrawal.account());\n        tokenManager.setPendingExposureToZero(tokenManager.tokenAddressToSymbol(shortToken), withdrawal.account());\n        \n        // Native token transfer happens after execution of this method, but the amounts should be dust ones anyway and by wrapping here we get a chance to wrap any previously sent native token\n        wrapNativeToken();\n\n        DiamondStorageLib.unfreezeAccount(msg.sender);\n        emit WithdrawalExecuted(\n            msg.sender,\n            withdrawal.addresses.market,\n            longOutputAmount,\n            shortOutputAmount,\n            withdrawal.numbers.executionFee\n        );\n    }\n\n    function afterWithdrawalCancellation(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external onlyGmxV2Keeper nonReentrant override {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        address longToken = marketToLongToken(withdrawal.addresses.market);\n        address shortToken = marketToShortToken(withdrawal.addresses.market);\n        \n        // Add owned assets\n        if(IERC20Metadata(withdrawal.addresses.market).balanceOf(address(this)) > 0){\n            DiamondStorageLib.addOwnedAsset(tokenManager.tokenAddressToSymbol(withdrawal.addresses.market), withdrawal.addresses.market);\n        }\n\n        // Native token transfer happens after execution of this method, but the amounts should be dust ones anyway and by wrapping here we get a chance to wrap any previously sent native token\n        wrapNativeToken();\n\n        tokenManager.increaseProtocolExposure(\n            tokenManager.tokenAddressToSymbol(withdrawal.addresses.market),\n            withdrawal.numbers.marketTokenAmount * 1e18 / 10**IERC20Metadata(withdrawal.addresses.market).decimals()\n        );\n\n        tokenManager.setPendingExposureToZero(tokenManager.tokenAddressToSymbol(longToken), withdrawal.account());\n        tokenManager.setPendingExposureToZero(tokenManager.tokenAddressToSymbol(shortToken), withdrawal.account());\n\n        DiamondStorageLib.unfreezeAccount(msg.sender);\n        emit WithdrawalCancelled(\n            msg.sender,\n            withdrawal.addresses.market,\n            withdrawal.numbers.executionFee\n        );\n    }\n\n    function refundExecutionFee(bytes32 /* key */, EventUtils.EventLogData memory /* eventData */) external payable {\n        wrapNativeToken();\n\n        emit GasFeeRefunded(msg.value);\n    }\n\n    // MODIFIERS\n    modifier onlyGmxV2Keeper() {\n        require(isCallerAuthorized(msg.sender), \"Must be a GMX V2 authorized Keeper\");\n        _;\n    }\n\n    /**\n     * @dev emitted after depositing collateral to gm market\n     * @param accountAddress address of a SmartLoanDiamondBeacon\n     * @param market address of a gm market\n     * @param gmAmount amount of gm tokens received\n     * @param executionFee amount of execution fee paid\n    **/\n    event DepositExecuted(address indexed accountAddress, address indexed market, uint256 gmAmount, uint256 executionFee);\n\n    /**\n     * @dev emitted after gm market deposit order was cancelled\n     * @param accountAddress address of a SmartLoanDiamondBeacon\n     * @param market address of a gm market\n     * @param executionFee amount of execution fee paid\n    **/\n    event DepositCancelled(address indexed accountAddress, address indexed market, uint256 executionFee);\n\n    /**\n     * @dev emitted after withdrawing collateral from gm market\n     * @param accountAddress address of a SmartLoanDiamondBeacon\n     * @param market address of a gm market\n     * @param longTokenAmount amount of long tokens received\n     * @param shortTokenAmount amount of short tokens received\n     * @param executionFee amount of execution fee paid\n    **/\n    event WithdrawalExecuted(address indexed accountAddress, address indexed market, uint256 longTokenAmount, uint256 shortTokenAmount, uint256 executionFee);\n\n    /**\n     * @dev emitted after gm market withdrawal order was cancelled\n     * @param accountAddress address of a SmartLoanDiamondBeacon\n     * @param market address of a gm market\n     * @param executionFee amount of execution fee paid\n    **/\n    event WithdrawalCancelled(address indexed accountAddress, address indexed market, uint256 executionFee);\n\n    /**\n     * @dev emitted after gmx execution fee is refunded\n     * @param refundedFee amount of execution fee refunded\n    **/\n    event GasFeeRefunded(uint256 refundedFee);\n}\n"
    },
    "contracts/facets/GmxV2Facet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./GmxV2FacetCommon.sol\";\n\nabstract contract GmxV2Facet is GmxV2FacetCommon {\n    using TransferHelper for address;\n\n    // Mappings\n    function marketToLongToken(\n        address market\n    ) internal pure virtual returns (address);\n\n    function marketToShortToken(\n        address market\n    ) internal pure virtual returns (address);\n\n    function _deposit(\n        address gmToken,\n        address depositedToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) internal nonReentrant noBorrowInTheSameBlock onlyOwner {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        tokenAmount = IERC20(depositedToken).balanceOf(address(this)) < tokenAmount\n            ? IERC20(depositedToken).balanceOf(address(this))\n            : tokenAmount;\n\n        bytes[] memory data = new bytes[](3);\n        data[0] = abi.encodeWithSelector(\n            IGmxV2Router.sendWnt.selector,\n            getGmxV2DepositVault(),\n            executionFee\n        );\n        data[1] = abi.encodeWithSelector(\n            IGmxV2Router.sendTokens.selector,\n            depositedToken,\n            getGmxV2DepositVault(),\n            tokenAmount\n        );\n        data[2] = abi.encodeWithSelector(\n            IDepositUtils.createDeposit.selector,\n            IDepositUtils.CreateDepositParams({\n                receiver: address(this), //receiver\n                callbackContract: address(this), //callbackContract\n                uiFeeReceiver: address(0), //uiFeeReceiver\n                market: gmToken, //market\n                initialLongToken: marketToLongToken(gmToken), //initialLongToken\n                initialShortToken: marketToShortToken(gmToken), //initialShortToken\n                longTokenSwapPath: new address[](0), //longTokenSwapPath\n                shortTokenSwapPath: new address[](0), //shortTokenSwapPath\n                minMarketTokens: minGmAmount, //minMarketTokens\n                shouldUnwrapNativeToken: false, //shouldUnwrapNativeToken\n                executionFee: executionFee, //executionFee\n                callbackGasLimit: 500000 //callbackGasLimit\n            })\n        );\n\n        depositedToken.safeApprove(getGmxV2Router(), 0);\n        depositedToken.safeApprove(getGmxV2Router(), tokenAmount);\n        BasicMulticall(getGmxV2ExchangeRouter()).multicall{value: msg.value}(data);\n\n        // Simulate solvency check\n        {\n            bytes32[] memory dataFeedIds = new bytes32[](2);\n            dataFeedIds[0] = tokenManager.tokenAddressToSymbol(gmToken);\n            dataFeedIds[1] = tokenManager.tokenAddressToSymbol(depositedToken);\n\n            uint256 gmTokenUsdPrice = SolvencyMethods.getPrices(dataFeedIds)[0];\n            uint256 depositTokenUsdPrice = SolvencyMethods.getPrices(dataFeedIds)[1];\n            require(\n                isWithinBounds(\n                    (depositTokenUsdPrice * tokenAmount) /\n                        10 ** IERC20Metadata(depositedToken).decimals(), // Deposit Amount In USD\n                    (minGmAmount * gmTokenUsdPrice) /\n                        10 ** IERC20Metadata(gmToken).decimals()\n                ), // Output Amount In USD\n                \"Invalid min output value\"\n            );\n\n            uint256 gmTokensWeightedUsdValue = (gmTokenUsdPrice *\n                minGmAmount *\n                tokenManager.debtCoverage(gmToken)) /\n                (10 ** IERC20Metadata(gmToken).decimals() * 1e8);\n            require(\n                (_getThresholdWeightedValuePayable() + gmTokensWeightedUsdValue) >\n                    _getDebtPayable(),\n                \"The action may cause the account to become insolvent\"\n            );\n        }\n\n        // Freeze account\n        DiamondStorageLib.freezeAccount(gmToken);\n\n        tokenManager.increasePendingExposure(\n            tokenManager.tokenAddressToSymbol(gmToken),\n            address(this),\n            (minGmAmount * 1e18) / 10 ** IERC20Metadata(gmToken).decimals()\n        );\n\n        // Update exposures\n        tokenManager.decreaseProtocolExposure(\n            tokenManager.tokenAddressToSymbol(depositedToken),\n            (tokenAmount * 1e18) / 10 ** IERC20Metadata(depositedToken).decimals()\n        );\n\n        // Update owned assets\n        if (IERC20Metadata(depositedToken).balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(\n                tokenManager.tokenAddressToSymbol(depositedToken)\n            );\n        }\n    }\n\n    function _withdraw(\n        address gmToken,\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    )\n        internal\n        nonReentrant\n        noBorrowInTheSameBlock\n        onlyOwnerNoStaySolventOrInsolventPayable\n    {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        gmAmount = IERC20(gmToken).balanceOf(address(this)) < gmAmount\n            ? IERC20(gmToken).balanceOf(address(this))\n            : gmAmount;\n\n        bytes[] memory data = new bytes[](3);\n        data[0] = abi.encodeWithSelector(\n            IGmxV2Router.sendWnt.selector,\n            getGmxV2WithdrawalVault(),\n            executionFee\n        );\n\n        data[1] = abi.encodeWithSelector(\n            IGmxV2Router.sendTokens.selector,\n            gmToken,\n            getGmxV2WithdrawalVault(),\n            gmAmount\n        );\n\n        data[2] = abi.encodeWithSelector(\n            IWithdrawalUtils.createWithdrawal.selector,\n            IWithdrawalUtils.CreateWithdrawalParams({\n                receiver: address(this), //receiver\n                callbackContract: address(this), //callbackContract\n                uiFeeReceiver: address(0), //uiFeeReceiver\n                market: gmToken, //market\n                longTokenSwapPath: new address[](0), //longTokenSwapPath\n                shortTokenSwapPath: new address[](0), //shortTokenSwapPath\n                minLongTokenAmount: minLongTokenAmount,\n                minShortTokenAmount: minShortTokenAmount,\n                shouldUnwrapNativeToken: false, //shouldUnwrapNativeToken\n                executionFee: executionFee, //executionFee\n                callbackGasLimit: 500000 //callbackGasLimit\n            })\n        );\n\n        IERC20(gmToken).approve(getGmxV2Router(), gmAmount);\n        BasicMulticall(getGmxV2ExchangeRouter()).multicall{value: msg.value}(data);\n\n        address longToken = marketToLongToken(gmToken);\n        address shortToken = marketToShortToken(gmToken);\n\n        // Simulate solvency check\n        if (msg.sender == DiamondStorageLib.contractOwner()) {\n            // Only owner can call this method or else it's liquidator when the account is already insolvent\n            uint256[] memory tokenPrices;\n\n            {\n                bytes32[] memory tokenSymbols = new bytes32[](3);\n                tokenSymbols[0] = tokenManager.tokenAddressToSymbol(longToken);\n                tokenSymbols[1] = tokenManager.tokenAddressToSymbol(shortToken);\n                tokenSymbols[2] = tokenManager.tokenAddressToSymbol(gmToken);\n                tokenPrices = getPrices(tokenSymbols);\n            }\n            require(\n                isWithinBounds(\n                    (tokenPrices[2] * gmAmount) /\n                        10 ** IERC20Metadata(gmToken).decimals(), // Deposit Amount In USD\n                    (tokenPrices[0] * minLongTokenAmount) /\n                        10 ** IERC20Metadata(longToken).decimals() +\n                        (tokenPrices[1] * minShortTokenAmount) /\n                        10 ** IERC20Metadata(shortToken).decimals()\n                ), // Output Amount In USD\n                \"Invalid min output value\"\n            );\n\n            uint256 receivedTokensWeightedUsdValue = (((tokenPrices[0] *\n                minLongTokenAmount *\n                tokenManager.debtCoverage(longToken)) /\n                10 ** IERC20Metadata(longToken).decimals()) +\n                ((tokenPrices[1] *\n                    minShortTokenAmount *\n                    tokenManager.debtCoverage(shortToken)) /\n                    10 ** IERC20Metadata(shortToken).decimals())) / 1e8;\n            require(\n                (_getThresholdWeightedValuePayable() + receivedTokensWeightedUsdValue) >\n                    _getDebtPayable(),\n                \"The action may cause the account to become insolvent\"\n            );\n        }\n\n        // Freeze account\n        DiamondStorageLib.freezeAccount(gmToken);\n\n        tokenManager.increasePendingExposure(\n            tokenManager.tokenAddressToSymbol(longToken),\n            address(this),\n            (minLongTokenAmount * 1e18) / 10 ** IERC20Metadata(longToken).decimals()\n        );\n        tokenManager.increasePendingExposure(\n            tokenManager.tokenAddressToSymbol(shortToken),\n            address(this),\n            (minShortTokenAmount * 1e18) / 10 ** IERC20Metadata(shortToken).decimals()\n        );\n\n        // Update exposures\n        tokenManager.decreaseProtocolExposure(\n            tokenManager.tokenAddressToSymbol(gmToken),\n            (gmAmount * 1e18) / 10 ** IERC20Metadata(gmToken).decimals()\n        );\n\n        // Remove GM token from owned assets if whole balance was used\n        if (IERC20Metadata(gmToken).balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(\n                tokenManager.tokenAddressToSymbol(gmToken)\n            );\n        }\n    }\n}\n"
    },
    "contracts/facets/GmxV2FacetCommon.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 799a1765b64edc5c158198ef84f785af79e234ae;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport \"../OnlyOwnerOrInsolvent.sol\";\nimport \"../interfaces/ITokenManager.sol\";\n\nimport \"../interfaces/gmx-v2/BasicMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/gmx-v2/EventUtils.sol\";\nimport \"../interfaces/gmx-v2/IDepositUtils.sol\";\nimport \"../interfaces/gmx-v2/IWithdrawalUtils.sol\";\nimport \"../interfaces/gmx-v2/IGmxV2Router.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\nabstract contract GmxV2FacetCommon is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    // GMX contracts\n    function getGmxV2Router() internal pure virtual returns (address);\n\n    function getGmxV2ExchangeRouter() internal pure virtual returns (address);\n\n    function getGmxV2DepositVault() internal pure virtual returns (address);\n\n    function getGmxV2WithdrawalVault() internal pure virtual returns (address);\n\n    function isWithinBounds(uint256 _estimate, uint256 _userInput) internal pure returns(bool) {\n        if(_estimate * 95 / 100 <= _userInput && _estimate * 105 / 100 >= _userInput) {\n            return true;\n        }\n        return false;\n    }\n\n    // MODIFIERS\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n}\n"
    },
    "contracts/facets/GmxV2PlusFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./GmxV2FacetCommon.sol\";\n\nabstract contract GmxV2PlusFacet is GmxV2FacetCommon {\n    using TransferHelper for address;\n\n    // Mappings\n    function marketToToken(\n        address market\n    ) internal pure virtual returns (address);\n\n    function _deposit(\n        address gmToken,\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) internal nonReentrant noBorrowInTheSameBlock onlyOwner {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        address depositedToken = marketToToken(gmToken);\n        tokenAmount = IERC20(depositedToken).balanceOf(address(this)) < tokenAmount\n            ? IERC20(depositedToken).balanceOf(address(this))\n            : tokenAmount;\n\n        bytes[] memory data = new bytes[](4);\n        data[0] = abi.encodeWithSelector(\n            IGmxV2Router.sendWnt.selector,\n            getGmxV2DepositVault(),\n            executionFee\n        );\n        data[1] = abi.encodeWithSelector(\n            IGmxV2Router.sendTokens.selector,\n            depositedToken,\n            getGmxV2DepositVault(),\n            tokenAmount / 2\n        );\n        data[2] = abi.encodeWithSelector(\n            IGmxV2Router.sendTokens.selector,\n            depositedToken,\n            getGmxV2DepositVault(),\n            tokenAmount / 2\n        );\n        data[3] = abi.encodeWithSelector(\n            IDepositUtils.createDeposit.selector,\n            IDepositUtils.CreateDepositParams({\n                receiver: address(this), //receiver\n                callbackContract: address(this), //callbackContract\n                uiFeeReceiver: address(0), //uiFeeReceiver\n                market: gmToken, //market\n                initialLongToken: depositedToken, //initialLongToken\n                initialShortToken: depositedToken, //initialShortToken\n                longTokenSwapPath: new address[](0), //longTokenSwapPath\n                shortTokenSwapPath: new address[](0), //shortTokenSwapPath\n                minMarketTokens: minGmAmount, //minMarketTokens\n                shouldUnwrapNativeToken: false, //shouldUnwrapNativeToken\n                executionFee: executionFee, //executionFee\n                callbackGasLimit: 500000 //callbackGasLimit\n            })\n        );\n\n        depositedToken.safeApprove(getGmxV2Router(), 0);\n        depositedToken.safeApprove(getGmxV2Router(), tokenAmount);\n        BasicMulticall(getGmxV2ExchangeRouter()).multicall{value: msg.value}(data);\n\n        // Simulate solvency check\n        {\n            bytes32[] memory dataFeedIds = new bytes32[](2);\n            dataFeedIds[0] = tokenManager.tokenAddressToSymbol(gmToken);\n            dataFeedIds[1] = tokenManager.tokenAddressToSymbol(depositedToken);\n\n            uint256 gmTokenUsdPrice = SolvencyMethods.getPrices(dataFeedIds)[0];\n            uint256 depositTokenUsdPrice = SolvencyMethods.getPrices(dataFeedIds)[1];\n            require(\n                isWithinBounds(\n                    (depositTokenUsdPrice * tokenAmount) /\n                        10 ** IERC20Metadata(depositedToken).decimals(), // Deposit Amount In USD\n                    (minGmAmount * gmTokenUsdPrice) /\n                        10 ** IERC20Metadata(gmToken).decimals()\n                ), // Output Amount In USD\n                \"Invalid min output value\"\n            );\n\n            uint256 gmTokensWeightedUsdValue = (gmTokenUsdPrice *\n                minGmAmount *\n                tokenManager.debtCoverage(gmToken)) /\n                (10 ** IERC20Metadata(gmToken).decimals() * 1e8);\n            require(\n                (_getThresholdWeightedValuePayable() + gmTokensWeightedUsdValue) >\n                    _getDebtPayable(),\n                \"The action may cause the account to become insolvent\"\n            );\n        }\n\n        // Freeze account\n        DiamondStorageLib.freezeAccount(gmToken);\n\n        tokenManager.increasePendingExposure(\n            tokenManager.tokenAddressToSymbol(gmToken),\n            address(this),\n            (minGmAmount * 1e18) / 10 ** IERC20Metadata(gmToken).decimals()\n        );\n\n        // Update exposures\n        tokenManager.decreaseProtocolExposure(\n            tokenManager.tokenAddressToSymbol(depositedToken),\n            (tokenAmount * 1e18) / 10 ** IERC20Metadata(depositedToken).decimals()\n        );\n\n        // Update owned assets\n        if (IERC20Metadata(depositedToken).balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(\n                tokenManager.tokenAddressToSymbol(depositedToken)\n            );\n        }\n    }\n\n    function _withdraw(\n        address gmToken,\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    )\n        internal\n        nonReentrant\n        noBorrowInTheSameBlock\n        onlyOwnerNoStaySolventOrInsolventPayable\n    {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        gmAmount = IERC20(gmToken).balanceOf(address(this)) < gmAmount\n            ? IERC20(gmToken).balanceOf(address(this))\n            : gmAmount;\n\n        bytes[] memory data = new bytes[](3);\n        data[0] = abi.encodeWithSelector(\n            IGmxV2Router.sendWnt.selector,\n            getGmxV2WithdrawalVault(),\n            executionFee\n        );\n\n        data[1] = abi.encodeWithSelector(\n            IGmxV2Router.sendTokens.selector,\n            gmToken,\n            getGmxV2WithdrawalVault(),\n            gmAmount\n        );\n\n        data[2] = abi.encodeWithSelector(\n            IWithdrawalUtils.createWithdrawal.selector,\n            IWithdrawalUtils.CreateWithdrawalParams({\n                receiver: address(this), //receiver\n                callbackContract: address(this), //callbackContract\n                uiFeeReceiver: address(0), //uiFeeReceiver\n                market: gmToken, //market\n                longTokenSwapPath: new address[](0), //longTokenSwapPath\n                shortTokenSwapPath: new address[](0), //shortTokenSwapPath\n                minLongTokenAmount: minLongTokenAmount,\n                minShortTokenAmount: minShortTokenAmount,\n                shouldUnwrapNativeToken: false, //shouldUnwrapNativeToken\n                executionFee: executionFee, //executionFee\n                callbackGasLimit: 500000 //callbackGasLimit\n            })\n        );\n\n        IERC20(gmToken).approve(getGmxV2Router(), gmAmount);\n        BasicMulticall(getGmxV2ExchangeRouter()).multicall{value: msg.value}(data);\n\n        address longToken = marketToToken(gmToken);\n        address shortToken = marketToToken(gmToken);\n\n        // Simulate solvency check\n        if (msg.sender == DiamondStorageLib.contractOwner()) {\n            // Only owner can call this method or else it's liquidator when the account is already insolvent\n            uint256[] memory tokenPrices;\n\n            {\n                bytes32[] memory tokenSymbols = new bytes32[](2);\n                tokenSymbols[0] = tokenManager.tokenAddressToSymbol(shortToken); // Short token and long token is the same, hence we can reuse the price\n                tokenSymbols[1] = tokenManager.tokenAddressToSymbol(gmToken);\n                tokenPrices = getPrices(tokenSymbols);\n            }\n            require(\n                isWithinBounds(\n                    (tokenPrices[1] * gmAmount) /\n                        10 ** IERC20Metadata(gmToken).decimals(), // Deposit Amount In USD\n                    (tokenPrices[0] * minLongTokenAmount) /\n                        10 ** IERC20Metadata(longToken).decimals() +\n                        (tokenPrices[0] * minShortTokenAmount) /\n                        10 ** IERC20Metadata(shortToken).decimals()\n                ), // Output Amount In USD\n                \"Invalid min output value\"\n            );\n\n            uint256 receivedTokensWeightedUsdValue = (((tokenPrices[0] *\n                minLongTokenAmount *\n                tokenManager.debtCoverage(longToken)) /\n                10 ** IERC20Metadata(longToken).decimals()) +\n                ((tokenPrices[0] *\n                    minShortTokenAmount *\n                    tokenManager.debtCoverage(shortToken)) /\n                    10 ** IERC20Metadata(shortToken).decimals())) / 1e8;\n            require(\n                (_getThresholdWeightedValuePayable() + receivedTokensWeightedUsdValue) >\n                    _getDebtPayable(),\n                \"The action may cause the account to become insolvent\"\n            );\n        }\n\n        // Freeze account\n        DiamondStorageLib.freezeAccount(gmToken);\n\n        tokenManager.increasePendingExposure(\n            tokenManager.tokenAddressToSymbol(longToken),\n            address(this),\n            (minLongTokenAmount * 1e18) / 10 ** IERC20Metadata(longToken).decimals()\n        );\n        tokenManager.increasePendingExposure(\n            tokenManager.tokenAddressToSymbol(shortToken),\n            address(this),\n            (minShortTokenAmount * 1e18) / 10 ** IERC20Metadata(shortToken).decimals()\n        );\n\n        // Update exposures\n        tokenManager.decreaseProtocolExposure(\n            tokenManager.tokenAddressToSymbol(gmToken),\n            (gmAmount * 1e18) / 10 ** IERC20Metadata(gmToken).decimals()\n        );\n\n        // Remove GM token from owned assets if whole balance was used\n        if (IERC20Metadata(gmToken).balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(\n                tokenManager.tokenAddressToSymbol(gmToken)\n            );\n        }\n    }\n}\n"
    },
    "contracts/facets/HealthMeterFacetProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 6994573d571acec43c908afa321729e454450d71;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@redstone-finance/evm-connector/contracts/data-services/ArbitrumProdDataServiceConsumerBase.sol\";\nimport \"../interfaces/ITokenManager.sol\";\nimport \"../interfaces/facets/avalanche/ITraderJoeV2Facet.sol\";\nimport \"../interfaces/IStakingPositions.sol\";\nimport {Uint256x256Math} from \"../lib/joe-v2/math/Uint256x256Math.sol\";\nimport {PriceHelper} from \"../lib/joe-v2/PriceHelper.sol\";\nimport \"../Pool.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract HealthMeterFacetProd is ArbitrumProdDataServiceConsumerBase {\n    using PriceHelper for uint256;\n    using Uint256x256Math for uint256;\n\n    struct AssetPrice {\n        bytes32 asset;\n        uint256 price;\n    }\n\n    struct PriceInfo {\n        address tokenX;\n        address tokenY;\n        uint256 priceX;\n        uint256 priceY;\n    }\n\n    function _getTotalTraderJoeV2Weighted() internal view returns (uint256) {\n        uint256 total;\n\n        ITraderJoeV2Facet.TraderJoeV2Bin[] memory ownedTraderJoeV2Bins = DiamondStorageLib.getTjV2OwnedBinsView();\n\n        PriceInfo memory priceInfo;\n\n        if (ownedTraderJoeV2Bins.length > 0) {\n            for (uint256 i; i < ownedTraderJoeV2Bins.length; i++) {\n                ITraderJoeV2Facet.TraderJoeV2Bin memory binInfo = ownedTraderJoeV2Bins[i];\n\n                uint256 price;\n                uint256 liquidity;\n\n                {\n                    address tokenXAddress = address(binInfo.pair.getTokenX());\n                    address tokenYAddress = address(binInfo.pair.getTokenY());\n\n                    if (priceInfo.tokenX != tokenXAddress || priceInfo.tokenY != tokenYAddress) {\n                        bytes32[] memory symbols = new bytes32[](2);\n\n\n                        symbols[0] = DeploymentConstants.getTokenManager().tokenAddressToSymbol(tokenXAddress);\n                        symbols[1] = DeploymentConstants.getTokenManager().tokenAddressToSymbol(tokenYAddress);\n\n                        uint256[] memory prices = getOracleNumericValuesFromTxMsg(symbols);\n                        priceInfo = PriceInfo(tokenXAddress, tokenYAddress, prices[0], prices[1]);\n                    }\n                }\n\n                {\n                    (uint128 binReserveX, uint128 binReserveY) = binInfo.pair.getBin(binInfo.id);\n\n                    price = PriceHelper.convert128x128PriceToDecimal(binInfo.pair.getPriceFromId(binInfo.id)); // how is it denominated (what precision)?\n\n                    liquidity = price * binReserveX / 10 ** 18 + binReserveY;\n                }\n\n\n                {\n                    uint256 debtCoverageX = DeploymentConstants.getTokenManager().debtCoverage(address(binInfo.pair.getTokenX()));\n                    uint256 debtCoverageY = DeploymentConstants.getTokenManager().debtCoverage(address(binInfo.pair.getTokenY()));\n\n                    total = total +\n                                                        Math.min(\n                                            price > 10 ** 24 ?\n                                                debtCoverageX * liquidity / (price / 10 ** 18) / 10 ** IERC20Metadata(address(binInfo.pair.getTokenX())).decimals() * priceInfo.priceX / 10 ** 8\n                                                :\n                                                debtCoverageX * liquidity / price * 10 ** 18 / 10 ** IERC20Metadata(address(binInfo.pair.getTokenX())).decimals() * priceInfo.priceX / 10 ** 8,\n                                            debtCoverageY * liquidity / 10 ** (IERC20Metadata(address(binInfo.pair.getTokenY())).decimals()) * priceInfo.priceY / 10 ** 8\n                                        )\n                                        .mulDivRoundDown(binInfo.pair.balanceOf(address(this), binInfo.id), 1e18)\n                                .mulDivRoundDown(1e18, binInfo.pair.totalSupply(binInfo.id));\n                }\n            }\n\n            return total;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n      * Returns an array of bytes32[] symbols of debt (borrowable) assets.\n    **/\n    function _getDebtAssets() internal view returns (bytes32[] memory result) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        result = tokenManager.getAllPoolAssets();\n    }\n\n    /**\n      * Returns an array of Asset/Price structs of enriched (always containing AVAX at index 0) owned assets.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function _getOwnedAssetsWithNativePrices() internal view returns (AssetPrice[] memory result) {\n        bytes32[] memory assetsEnriched = _getOwnedAssetsWithNative();\n        uint256[] memory prices = getOracleNumericValuesFromTxMsg(assetsEnriched);\n\n        result = new AssetPrice[](assetsEnriched.length);\n\n        for (uint i; i < assetsEnriched.length; i++) {\n            result[i] = AssetPrice({\n                asset: assetsEnriched[i],\n                price: prices[i]\n            });\n        }\n    }\n\n    /**\n      * Returns list of owned assets that always included NativeToken at index 0\n    **/\n    function _getOwnedAssetsWithNative() internal view returns (bytes32[] memory){\n        bytes32[] memory ownedAssets = DeploymentConstants.getAllOwnedAssets();\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\n\n        // If account already owns the native token the use ownedAssets.length; Otherwise add one element to account for additional native token.\n        uint256 numberOfAssets = DiamondStorageLib.hasAsset(nativeTokenSymbol) ? ownedAssets.length : ownedAssets.length + 1;\n        bytes32[] memory assetsWithNative = new bytes32[](numberOfAssets);\n\n        uint256 lastUsedIndex;\n        assetsWithNative[0] = nativeTokenSymbol; // First asset = NativeToken\n\n        for (uint i = 0; i < ownedAssets.length; i++) {\n            if (ownedAssets[i] != nativeTokenSymbol) {\n                assetsWithNative[++lastUsedIndex] = ownedAssets[i];\n            }\n        }\n        return assetsWithNative;\n    }\n\n    /**\n      * Returns an array of Asset/Price structs of all assets.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function _getAllAssetsWithNativePrices() internal view returns (AssetPrice[] memory result) {\n        bytes32[] memory assets = _getAllAssetsWithNative();\n        uint256[] memory prices = getOracleNumericValuesFromTxMsg(assets);\n\n        result = new AssetPrice[](assets.length);\n\n        for (uint i; i < assets.length; i++) {\n            result[i] = AssetPrice({\n                asset: assets[i],\n                price: prices[i]\n            });\n        }\n    }\n\n    /**\n      * Returns list of owned assets that always included NativeToken at index 0\n    **/\n    function _getAllAssetsWithNative() internal view returns (bytes32[] memory){\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        bytes32[] memory assets = tokenManager.getAllTokenAssets();\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\n\n        uint256 numberOfAssets = assets.length;\n        bytes32[] memory assetsWithNative = new bytes32[](numberOfAssets);\n\n        uint256 lastUsedIndex;\n        assetsWithNative[0] = nativeTokenSymbol; // First asset = NativeToken\n\n        for (uint i = 0; i < assets.length; i++) {\n            if (assets[i] != nativeTokenSymbol) {\n                assetsWithNative[++lastUsedIndex] = assets[i];\n            }\n        }\n        return assetsWithNative;\n    }\n\n    function getStakedPositionsPrices() public view returns(AssetPrice[] memory result) {\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n\n        bytes32[] memory symbols = new bytes32[](positions.length);\n        for(uint256 i=0; i<positions.length; i++) {\n            symbols[i] = positions[i].symbol;\n        }\n\n        uint256[] memory stakedPositionsPrices = getOracleNumericValuesWithDuplicatesFromTxMsg(symbols);\n        result = new AssetPrice[](stakedPositionsPrices.length);\n\n        for(uint i; i<stakedPositionsPrices.length; i++){\n            result[i] = AssetPrice({\n                asset: symbols[i],\n                price: stakedPositionsPrices[i]\n            });\n        }\n    }\n\n    function _getTWVStakedPositions() internal view returns (uint256) {\n        AssetPrice[] memory stakedPositionsPrices = getStakedPositionsPrices();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n\n        uint256 weightedValueOfStaked;\n\n        for (uint256 i; i < positions.length; i++) {\n            if(stakedPositionsPrices[i].asset != positions[i].symbol){\n                revert PriceSymbolPositionMismatch();\n            }\n\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\n\n            if (success) {\n                uint256 balance = abi.decode(result, (uint256));\n\n                IERC20Metadata token = IERC20Metadata(DeploymentConstants.getTokenManager().getAssetAddress(stakedPositionsPrices[i].asset, true));\n\n                weightedValueOfStaked += stakedPositionsPrices[i].price * balance * tokenManager.debtCoverageStaked(positions[i].identifier) / (10 ** token.decimals() * 10**8);\n            }\n\n\n        }\n        return weightedValueOfStaked;\n    }\n\n    /**\n     * Returns current health meter (0% - 100%) associated with the loan\n     * @dev This function uses the redstone-evm-connector\n     */\n    function getHealthMeter() public view returns (uint256) {\n        AssetPrice[] memory assetsPrices = _getAllAssetsWithNativePrices();\n\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        uint256 weightedCollateralPlus = assetsPrices[0].price * address(this).balance * tokenManager.debtCoverage(tokenManager.getAssetAddress(nativeTokenSymbol, true)) / (10 ** 26);\n        uint256 weightedCollateralMinus = 0;\n        uint256 weightedBorrowed = 0;\n        uint256 borrowed = 0;\n\n        weightedCollateralPlus += _getTotalTraderJoeV2Weighted();\n        weightedCollateralPlus += _getTWVStakedPositions();\n\n        for (uint256 i = 0; i < assetsPrices.length; i++) {\n            uint256 _balance;\n            uint8 decimals;\n            uint256 debtCoverage;\n            {\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(assetsPrices[i].asset, true));\n                _balance = token.balanceOf(address(this));\n                decimals = token.decimals();\n                debtCoverage = tokenManager.debtCoverage(address(token));\n            }\n\n            Pool pool;\n            try tokenManager.getPoolAddress(assetsPrices[i].asset) returns (address poolAddress) {\n                pool = Pool(poolAddress);\n            } catch {\n                weightedCollateralPlus = weightedCollateralPlus + (assetsPrices[i].price * _balance * debtCoverage / (10 ** decimals * 1e8));\n                continue;\n            }\n            uint256 _borrowed = pool.getBorrowed(address(this));\n\n            if (_balance == 0 && _borrowed == 0) {\n                continue;\n            }\n\n            if (_balance > _borrowed) {\n                weightedCollateralPlus = weightedCollateralPlus + (assetsPrices[i].price * (_balance - _borrowed) * debtCoverage / (10 ** decimals * 1e8));\n            } else if (_balance < _borrowed) {\n                weightedCollateralMinus = weightedCollateralMinus + (assetsPrices[i].price * (_borrowed - _balance) * debtCoverage / (10 ** decimals * 1e8));\n            }\n            weightedBorrowed = weightedBorrowed + (assetsPrices[i].price * _borrowed * debtCoverage / (10 ** decimals * 1e8));\n            borrowed = borrowed + (assetsPrices[i].price * _borrowed * 1e10 / (10 ** decimals));\n        }\n\n        uint256 weightedCollateral;\n        if (weightedCollateralPlus > weightedCollateralMinus) {\n            weightedCollateral = weightedCollateralPlus - weightedCollateralMinus;\n        }\n\n        uint256 multiplier = 100 * 1e18; // 18 decimal points\n\n        if (borrowed == 0) return multiplier;\n\n        if (weightedCollateral > 0 && weightedCollateral + weightedBorrowed > borrowed) {\n            return (weightedCollateral + weightedBorrowed - borrowed) * multiplier / weightedCollateral;\n        }\n\n        return 0;\n    }\n\n    // ERRORS\n    error PriceSymbolPositionMismatch();\n}\n"
    },
    "contracts/facets/mock/AssetsOperationsMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../AssetsOperationsFacet.sol\";\n\ncontract AssetsOperationsMock is AssetsOperationsFacet {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    /**\n    * Withdraws an amount of a defined asset from the loan\n    * This method does not perform any solvency check hence allows the user to withdraw whatever is available in the loan\n    * @dev This function uses the redstone-evm-connector\n    * @param _withdrawnAsset asset to be withdrawn\n    * @param _amount to be withdrawn\n    **/\n    function withdraw(bytes32 _withdrawnAsset, uint256 _amount) public virtual override onlyOwner nonReentrant{\n        IERC20Metadata token = getERC20TokenInstance(_withdrawnAsset, true);\n        require(getBalance(_withdrawnAsset) >= _amount, \"There is not enough funds to withdraw\");\n\n        address(token).safeTransfer(msg.sender, _amount);\n        if (token.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(_withdrawnAsset);\n        }\n\n        emit Withdrawn(msg.sender, _withdrawnAsset, _amount, block.timestamp);\n    }\n}\n"
    },
    "contracts/facets/mock/CaiFacetMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport \"../avalanche/CaiFacet.sol\";\n\ncontract CaiFacetMock is CaiFacet, AuthorisedMockSignersBase {\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    error TimestampIsNotValid();\n\n    function getAuthorisedSignerIndex(\n        address signerAddress\n    ) public view virtual override returns (uint8) {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(\n        uint256 receivedTimestampMilliseconds\n    ) public view virtual override {\n        if (receivedTimestampMilliseconds < MIN_TIMESTAMP_MILLISECONDS) {\n            revert TimestampIsNotValid();\n        }\n    }\n}\n"
    },
    "contracts/facets/mock/HealthMeterFacetMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport \"../HealthMeterFacetProd.sol\";\n\ncontract HealthMeterFacetMock is HealthMeterFacetProd, AuthorisedMockSignersBase {\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    error TimestampIsNotValid();\n\n    function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n        if (receivedTimestampMilliseconds < MIN_TIMESTAMP_MILLISECONDS) {\n            revert TimestampIsNotValid();\n        }\n    }\n}\n"
    },
    "contracts/facets/mock/LTIPFacetMock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport {LTIPFacet} from \"../arbitrum/LTIPFacet.sol\";\n\ncontract LTIPFacetMock is LTIPFacet, AuthorisedMockSignersBase{\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes;\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n        // Always pass\n    }\n\n}\n"
    },
    "contracts/facets/mock/MockSolvencyFacetAlwaysSolvent.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ncontract MockSolvencyFacetAlwaysSolvent {\n    /**\n    * Always returns true - used in test suits\n    **/\n    function isSolvent() public pure returns (bool) {\n        return true;\n    }\n\n    function canRepayDebtFully() external view returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/facets/mock/SolvencyFacetMockArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport \"../arbitrum/SolvencyFacetProdArbitrum.sol\";\n\ncontract SolvencyFacetMockArbitrum is SolvencyFacetProdArbitrum, AuthorisedMockSignersBase {\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n        // Always pass\n    }\n}\n"
    },
    "contracts/facets/mock/SolvencyFacetMockAvalanche.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport \"../avalanche/SolvencyFacetProdAvalanche.sol\";\n\ncontract SolvencyFacetMockAvalanche is SolvencyFacetProdAvalanche, AuthorisedMockSignersBase {\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    error TimestampIsNotValid();\n\n    function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n        // Always pass\n    }\n}\n"
    },
    "contracts/facets/mock/UniswapV3FacetMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\nimport \"../avalanche/UniswapV3Facet.sol\";\n\ncontract UniswapV3FacetMock is UniswapV3Facet, AuthorisedMockSignersBase {\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    error TimestampIsNotValid();\n\n    function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n        if (receivedTimestampMilliseconds < MIN_TIMESTAMP_MILLISECONDS) {\n            revert TimestampIsNotValid();\n        }\n    }\n}\n"
    },
    "contracts/facets/mock/VectorFinanceFacetMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: bdee015765a0dd3731205df659aae576d57dd473;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../ReentrancyGuardKeccak.sol\";\nimport \"../../interfaces/IVectorFinanceStaking.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\nimport \"../../interfaces/IStakingPositions.sol\";\nimport \"../../OnlyOwnerOrInsolvent.sol\";\nimport \"../../interfaces/IVectorFinanceMainStaking.sol\";\n//This path is updated during deployment\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract VectorFinanceFacetMock is ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address;\n\n    // CONSTANTS\n\n    address private constant VectorMainStaking = 0x8B3d9F0017FA369cD8C164D0Cc078bf4cA588aE5;\n\n    // PUBLIC FUNCTIONS\n\n    function vectorStakeUSDC1(uint256 amount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0x06f01502327De1c37076Bea4689a7e44279155e9,\n            symbol: \"USDC\",\n            identifier: \"VF_USDC_MAIN\",\n            balanceSelector: this.vectorUSDC1Balance.selector,\n            unstakeSelector: this.vectorUnstakeUSDC1.selector\n        });\n        stakeToken(amount, position);\n    }\n\n    function vectorUnstakeUSDC1(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0x06f01502327De1c37076Bea4689a7e44279155e9,\n            symbol: \"USDC\",\n            identifier: \"VF_USDC_MAIN\",\n            balanceSelector: this.vectorUSDC1Balance.selector,\n            unstakeSelector: this.vectorUnstakeUSDC1.selector\n        });\n        unstakeToken(amount, minAmount, position);\n    }\n\n    function vectorUSDC1Balance() public view returns(uint256 _stakedBalance) {\n        IVectorFinanceStaking stakingContract = IVectorFinanceStaking(getAssetPoolHelper(0x06f01502327De1c37076Bea4689a7e44279155e9));\n        _stakedBalance = stakingContract.balance(address(this));\n    }\n\n    function vectorStakeWAVAX1(uint256 amount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            symbol: \"AVAX\",\n            identifier: \"VF_AVAX_SAVAX\",\n            balanceSelector: this.vectorWAVAX1Balance.selector,\n            unstakeSelector: this.vectorUnstakeWAVAX1.selector\n        });\n        stakeToken(amount, position);\n    }\n\n    function vectorUnstakeWAVAX1(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7,\n            symbol: \"AVAX\",\n            identifier: \"VF_AVAX_SAVAX\",\n            balanceSelector: this.vectorWAVAX1Balance.selector,\n            unstakeSelector: this.vectorUnstakeWAVAX1.selector\n        });\n        unstakeToken(amount, minAmount, position);\n    }\n\n    function vectorWAVAX1Balance() public view returns(uint256 _stakedBalance) {\n        IVectorFinanceStaking stakingContract = IVectorFinanceStaking(getAssetPoolHelper(0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7));\n        _stakedBalance = stakingContract.balance(address(this));\n    }\n\n    function vectorStakeSAVAX1(uint256 amount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\n            symbol: \"sAVAX\",\n            identifier: \"VF_SAVAX_MAIN\",\n            balanceSelector: this.vectorSAVAX1Balance.selector,\n            unstakeSelector: this.vectorUnstakeSAVAX1.selector\n        });\n        stakeToken(amount, position);\n    }\n\n    function vectorUnstakeSAVAX1(uint256 amount, uint256 minAmount) public {\n        IStakingPositions.StakedPosition memory position = IStakingPositions.StakedPosition({\n            asset: 0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE,\n            symbol: \"sAVAX\",\n            identifier: \"VF_SAVAX_MAIN\",\n            balanceSelector: this.vectorSAVAX1Balance.selector,\n            unstakeSelector: this.vectorUnstakeSAVAX1.selector\n        });\n        unstakeToken(amount, minAmount, position);\n    }\n\n    function vectorSAVAX1Balance() public view returns(uint256 _stakedBalance) {\n        IVectorFinanceStaking stakingContract = IVectorFinanceStaking(getAssetPoolHelper(0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE));\n        _stakedBalance = stakingContract.balance(address(this));\n    }\n\n    // INTERNAL FUNCTIONS\n    /**\n    * @dev This function uses the redstone-evm-connector\n    **/\n    function stakeToken(uint256 amount, IStakingPositions.StakedPosition memory position) internal\n    onlyOwner nonReentrant  recalculateAssetsExposure remainsSolvent {\n        IVectorFinanceStaking poolHelper = getAssetPoolHelper(position.asset);\n        IERC20Metadata stakedToken = getERC20TokenInstance(position.symbol, false);\n        uint256 initialReceiptTokenBalance = poolHelper.balance(address(this));\n\n        amount = Math.min(stakedToken.balanceOf(address(this)), amount);\n        require(amount > 0, \"Cannot stake 0 tokens\");\n\n        address(stakedToken).safeApprove(VectorMainStaking, 0);\n        address(stakedToken).safeApprove(VectorMainStaking, amount);\n\n        poolHelper.deposit(amount);\n\n        DiamondStorageLib.addStakedPosition(position);\n\n        if (stakedToken.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(position.symbol);\n        }\n\n        emit Staked(\n            msg.sender,\n            position.symbol,\n            address(poolHelper),\n            amount,\n            poolHelper.balance(address(this)) - initialReceiptTokenBalance,\n            block.timestamp\n        );\n    }\n\n    /**\n    * Unstakes token from Vector Finance\n    * IMPORTANT: This method can be used by anyone when a loan is insolvent. This operation can be costly, that is why\n    * if needed it has to be performed in a separate transaction to liquidation\n    * @dev This function uses the redstone-evm-connector\n    **/\n    function unstakeToken(uint256 amount, uint256 minAmount, IStakingPositions.StakedPosition memory position) internal\n    onlyOwnerOrInsolvent recalculateAssetsExposure nonReentrant returns (uint256 unstaked) {\n        IVectorFinanceStaking poolHelper = getAssetPoolHelper(position.asset);\n        IERC20Metadata unstakedToken = getERC20TokenInstance(position.symbol, false);\n\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        amount = Math.min(poolHelper.balance(address(this)), amount);\n\n        uint256 balance = unstakedToken.balanceOf(address(this));\n\n        poolHelper.withdraw(amount, minAmount);\n\n        uint256 newBalance = unstakedToken.balanceOf(address(this));\n\n        if (poolHelper.balance(address(this)) == 0) {\n            DiamondStorageLib.removeStakedPosition(position.identifier);\n        }\n        DiamondStorageLib.addOwnedAsset(position.symbol, address(unstakedToken));\n\n        emit Unstaked(\n            msg.sender,\n            position.symbol,\n            address(poolHelper),\n            newBalance - balance,\n            amount,\n            block.timestamp\n        );\n\n        _handleRewards(poolHelper);\n\n        return newBalance - balance;\n    }\n\n    function _handleRewards(IVectorFinanceStaking stakingContract) internal {\n        IVectorRewarder rewarder = stakingContract.rewarder();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        uint256 index;\n\n        // We do not want to revert in case of unsupported rewardTokens in order not to block the unstaking/liquidation process\n        while(true) {\n            // No access to the length of rewardTokens[]. Need to iterate until indexOutOfRange\n            (bool success, bytes memory result) = address(rewarder).call(abi.encodeWithSignature(\"rewardTokens(uint256)\", index));\n            if(!success) {\n                break;\n            }\n            address rewardToken = abi.decode(result, (address));\n            bytes32 rewardTokenSymbol = tokenManager.tokenAddressToSymbol(rewardToken);\n            if(rewardTokenSymbol == \"\") {\n                emit UnsupportedRewardToken(msg.sender, rewardToken, block.timestamp);\n                index += 1;\n                continue;\n            }\n            if(IERC20(rewardToken).balanceOf(address(this)) > 0) {\n                DiamondStorageLib.addOwnedAsset(rewardTokenSymbol, rewardToken);\n            }\n            index += 1;\n        }\n    }\n\n    function getAssetPoolHelper(address asset) internal view returns(IVectorFinanceStaking){\n        IVectorFinanceMainStaking mainStaking = IVectorFinanceMainStaking(VectorMainStaking);\n        return IVectorFinanceStaking(mainStaking.getPoolInfo(asset).helper);\n    }\n\n    // MODIFIERS\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    // EVENTS\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much of deposit token was staked\n        * @param receiptTokenAmount how much of receipt token was received\n        * @param timestamp of staking\n    **/\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user unstakes an asset\n        * @param user the address executing unstaking\n        * @param asset the asset that was unstaked\n        * @param vault address of receipt token\n        * @param depositTokenAmount how much deposit token was received\n        * @param receiptTokenAmount how much receipt token was unstaked\n        * @param timestamp of unstaking\n    **/\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    /**\n        * @dev emitted when user collects rewards in tokens that are not supported\n        * @param user the address collecting rewards\n        * @param asset reward token that was collected\n        * @param timestamp of collecting rewards\n    **/\n    event UnsupportedRewardToken(address indexed user, address indexed asset, uint256 timestamp);\n}"
    },
    "contracts/facets/OwnershipFacet.sol": {
      "content": "\n// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport { DiamondStorageLib } from \"../lib/DiamondStorageLib.sol\";\nimport \"../SmartLoansFactory.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract OwnershipFacet {\n    function proposeOwnershipTransfer(address _newOwner) external {\n        DiamondStorageLib.enforceIsContractOwner();\n        require(_newOwner != msg.sender, \"Can't propose oneself as a contract owner\");\n        require(SmartLoansFactory(DeploymentConstants.getSmartLoansFactoryAddress()).getLoanForOwner(_newOwner) == address(0),\n            \"Can't propose an address that already has a loan\");\n        DiamondStorageLib.setProposedOwner(_newOwner);\n\n        emit OwnershipProposalCreated(msg.sender, _newOwner);\n    }\n\n    function acceptOwnership() external {\n        require(DiamondStorageLib.proposedOwner() == msg.sender, \"Only a proposed user can accept ownership\");\n        DiamondStorageLib.setContractOwner(msg.sender);\n        DiamondStorageLib.setProposedOwner(address(0));\n        SmartLoansFactory(DeploymentConstants.getSmartLoansFactoryAddress()).changeOwnership(msg.sender);\n\n        emit OwnershipProposalAccepted(msg.sender);\n    }\n\n    function owner() external view returns (address owner_) {\n        owner_ = DiamondStorageLib.contractOwner();\n    }\n\n    function proposedOwner() external view returns (address proposedOwner_) {\n        proposedOwner_ = DiamondStorageLib.proposedOwner();\n    }\n\n    function pauseAdmin() external view returns (address pauseAdmin) {\n        pauseAdmin = DiamondStorageLib.pauseAdmin();\n    }\n\n    function proposedPauseAdmin() external view returns (address proposedPauseAdmin) {\n        proposedPauseAdmin = DiamondStorageLib.proposedPauseAdmin();\n    }\n\n    /**\n     * @dev emitted after creating a ownership transfer proposal by the owner\n     * @param owner address of the current owner\n     * @param proposed address of the proposed owner\n     **/\n    event OwnershipProposalCreated(address indexed owner, address indexed proposed);\n\n    /**\n     * @dev emitted after accepting a ownership transfer proposal by the new owner\n     * @param newOwner address of the new owner\n     **/\n    event OwnershipProposalAccepted(address indexed newOwner);\n}"
    },
    "contracts/facets/ParaSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 19d9982858f4feeff1ca98cbf31b07304a79ac7f;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport \"../lib/SolvencyMethods.sol\";\nimport \"./SmartLoanLiquidationFacet.sol\";\nimport \"../interfaces/ITokenManager.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract ParaSwapFacet is ReentrancyGuardKeccak, SolvencyMethods {\n    using TransferHelper for address;\n\n    address private constant PARA_TRANSFER_PROXY =\n        0x216B4B4Ba9F3e719726886d34a177484278Bfcae;\n    address private constant PARA_ROUTER =\n        0xDEF171Fe48CF0115B1d80b88dc8eAB59176FEe57;\n\n    struct SwapTokensDetails {\n        bytes32 tokenSoldSymbol;\n        bytes32 tokenBoughtSymbol;\n        IERC20Metadata soldToken;\n        IERC20Metadata boughtToken;\n        uint256 initialSoldTokenBalance;\n        uint256 initialBoughtTokenBalance;\n    }\n\n    function getInitialTokensDetails(\n        address _soldTokenAddress,\n        address _boughtTokenAddress\n    ) internal view returns (SwapTokensDetails memory) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        if (_boughtTokenAddress == 0xaE64d55a6f09E4263421737397D1fdFA71896a69) {\n            _boughtTokenAddress = 0x9e295B5B976a184B14aD8cd72413aD846C299660;\n        }\n\n        if (_soldTokenAddress == 0xaE64d55a6f09E4263421737397D1fdFA71896a69) {\n            _soldTokenAddress = 0x9e295B5B976a184B14aD8cd72413aD846C299660;\n        }\n\n        bytes32 _tokenSoldSymbol = tokenManager.tokenAddressToSymbol(\n            _soldTokenAddress\n        );\n        bytes32 _tokenBoughtSymbol = tokenManager.tokenAddressToSymbol(\n            _boughtTokenAddress\n        );\n\n        require(\n            tokenManager.isTokenAssetActive(_boughtTokenAddress),\n            \"Asset not supported.\"\n        );\n\n        IERC20Metadata _soldToken = IERC20Metadata(_soldTokenAddress);\n        IERC20Metadata _boughtToken = IERC20Metadata(_boughtTokenAddress);\n\n        return\n            SwapTokensDetails({\n                tokenSoldSymbol: _tokenSoldSymbol,\n                tokenBoughtSymbol: _tokenBoughtSymbol,\n                soldToken: _soldToken,\n                boughtToken: _boughtToken,\n                initialSoldTokenBalance: _soldToken.balanceOf(address(this)),\n                initialBoughtTokenBalance: _boughtToken.balanceOf(address(this))\n            });\n    }\n\n    function paraSwapBeforeLiquidation(\n        bytes4 selector,\n        bytes memory data,\n        address fromToken,\n        uint256 fromAmount,\n        address toToken,\n        uint256 minOut\n    )\n    external\n    nonReentrant\n    onlyWhitelistedLiquidators\n    noBorrowInTheSameBlock\n    {\n        require(!_isSolvent(), \"Cannot perform on a solvent account\");\n\n        SwapTokensDetails memory swapTokensDetails = getInitialTokensDetails(\n            fromToken,\n            toToken\n        );\n        require(swapTokensDetails.initialSoldTokenBalance >= fromAmount, \"Insufficient balance\");\n        require(minOut > 0, \"minOut needs to be > 0\");\n        require(fromAmount > 0, \"Amount of tokens to sell has to be greater than 0\");\n\n        address(swapTokensDetails.soldToken).safeApprove(PARA_TRANSFER_PROXY, 0);\n        address(swapTokensDetails.soldToken).safeApprove(\n            PARA_TRANSFER_PROXY,\n            fromAmount\n        );\n\n        (bool success, ) = PARA_ROUTER.call((abi.encodePacked(selector, data)));\n        require(success, \"Swap failed\");\n\n        uint256 boughtTokenFinalAmount = swapTokensDetails.boughtToken.balanceOf(\n            address(this)\n        ) - swapTokensDetails.initialBoughtTokenBalance;\n        require(boughtTokenFinalAmount >= minOut, \"Too little received\");\n\n        uint256 soldTokenFinalAmount = swapTokensDetails.initialSoldTokenBalance - swapTokensDetails.soldToken.balanceOf(\n            address(this)\n        );\n        require(soldTokenFinalAmount == fromAmount, \"Too much sold\");\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, fromToken, soldTokenFinalAmount);\n        _increaseExposure(tokenManager, toToken, boughtTokenFinalAmount);\n\n        bytes32[] memory symbols = new bytes32[](2);\n        symbols[0] = swapTokensDetails.tokenSoldSymbol;\n        symbols[1] = swapTokensDetails.tokenBoughtSymbol;\n        uint256[] memory prices = getPrices(symbols);\n\n        uint256 soldTokenDollarValue = prices[0] * soldTokenFinalAmount * 10**10 / 10 ** swapTokensDetails.soldToken.decimals();\n        uint256 boughtTokenDollarValue = prices[1] * boughtTokenFinalAmount * 10**10 / 10 ** swapTokensDetails.boughtToken.decimals();\n        if(soldTokenDollarValue > boughtTokenDollarValue) {\n            // If the sold token is more valuable than the bought token, we need to check the slippage\n            // If the slippage is too high, we revert the transaction\n            // Slippage = (soldTokenDollarValue - boughtTokenDollarValue) * 100 / soldTokenDollarValue\n            uint256 slippage = (soldTokenDollarValue - boughtTokenDollarValue) * 100 / soldTokenDollarValue;\n            require(slippage < 2, \"Slippage too high\"); // MAX 2% slippage\n        }\n    }\n\n    function paraSwapV2(\n        bytes4 selector,\n        bytes memory data,\n        address fromToken,\n        uint256 fromAmount,\n        address toToken,\n        uint256 minOut\n    )\n        external\n        nonReentrant\n        onlyOwner\n        noBorrowInTheSameBlock\n        remainsSolvent\n    {\n        SwapTokensDetails memory swapTokensDetails = getInitialTokensDetails(\n            fromToken,\n            toToken\n        );\n\n        require(swapTokensDetails.soldToken.balanceOf(address(this)) >= fromAmount, \"Insufficient balance\");\n        require(minOut > 0, \"minOut needs to be > 0\");\n        require(fromAmount > 0, \"Amount of tokens to sell has to be greater than 0\");\n\n        address(swapTokensDetails.soldToken).safeApprove(PARA_TRANSFER_PROXY, 0);\n        address(swapTokensDetails.soldToken).safeApprove(\n            PARA_TRANSFER_PROXY,\n            fromAmount\n        );\n\n        (bool success, ) = PARA_ROUTER.call((abi.encodePacked(selector, data)));\n        require(success, \"Swap failed\");\n\n        uint256 boughtTokenFinalAmount = swapTokensDetails.boughtToken.balanceOf(\n            address(this)\n        ) - swapTokensDetails.initialBoughtTokenBalance;\n        require(boughtTokenFinalAmount >= minOut, \"Too little received\");\n\n        uint256 soldTokenFinalAmount = swapTokensDetails.initialSoldTokenBalance -\n                swapTokensDetails.soldToken.balanceOf(address(this));\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, address(swapTokensDetails.soldToken), soldTokenFinalAmount);\n        _increaseExposure(tokenManager, address(swapTokensDetails.boughtToken), boughtTokenFinalAmount);\n\n        emit Swap(\n            msg.sender,\n            swapTokensDetails.tokenSoldSymbol,\n            swapTokensDetails.tokenBoughtSymbol,\n            soldTokenFinalAmount,\n            boughtTokenFinalAmount,\n            block.timestamp\n        );\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    modifier onlyWhitelistedLiquidators() {\n        // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\n        require(SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\n        _;\n    }\n\n    /**\n     * @dev emitted after a swap of assets\n     * @param user the address of user making the purchase\n     * @param soldAsset sold by the user\n     * @param boughtAsset bought by the user\n     * @param amountSold amount of tokens sold\n     * @param amountBought amount of tokens bought\n     * @param timestamp time of the swap\n     **/\n    event Swap(\n        address indexed user,\n        bytes32 indexed soldAsset,\n        bytes32 indexed boughtAsset,\n        uint256 amountSold,\n        uint256 amountBought,\n        uint256 timestamp\n    );\n}\n"
    },
    "contracts/facets/RecoveryFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 4da64a8a04844045e51b88c6202064e16ea118aa;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport \"../lib/SolvencyMethods.sol\";\nimport \"../interfaces/ITokenManager.sol\";\nimport \"../interfaces/IAddressProvider.sol\";\nimport \"../interfaces/IVectorFinanceStaking.sol\";\nimport \"../interfaces/IVectorFinanceMainStaking.sol\";\n\n//this path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract RecoveryFacet is ReentrancyGuardKeccak, SolvencyMethods {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    // CONSTANTS\n\n    address private constant VectorMainStaking =\n        0x8B3d9F0017FA369cD8C164D0Cc078bf4cA588aE5;\n\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * Get refunds from the recovery contract\n     * @param _token token to be refunded\n     * @param _amount amount refunded\n     **/\n    function notifyRefund(address _token, uint256 _amount) external onlyRC {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        bytes32 asset = tokenManager.tokenAddressToSymbol(_token);\n        require(asset != bytes32(0), \"Asset not supported.\");\n\n        IERC20Metadata token = IERC20Metadata(_token);\n        _token.safeTransferFrom(msg.sender, address(this), _amount);\n\n        DiamondStorageLib.addOwnedAsset(asset, _token);\n\n        tokenManager.increaseProtocolExposure(\n            asset,\n            (_amount * 1e18) / 10 ** token.decimals()\n        );\n\n        emit RefundReceived(_token, _amount);\n    }\n\n    /**\n     * Emergency withdraws given assets from the loan\n     * @dev This function uses the redstone-evm-connector\n     * @param _asset asset to be withdrawn\n     * @return _amount amount withdrawn\n     **/\n    function emergencyWithdraw(\n        bytes32 _asset\n    ) external onlyRC returns (uint256 _amount) {\n        if (_asset == \"GLP\") {\n            _amount = _withdrawGLP();\n        } else {\n            _amount = _withdraw(_asset);\n        }\n    }\n\n    function _withdraw(bytes32 _asset) internal returns (uint256 _amount) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        if (\n            _asset == \"VF_USDC_MAIN_AUTO\" ||\n            _asset == \"VF_USDT_MAIN_AUTO\" ||\n            _asset == \"VF_AVAX_SAVAX_AUTO\" ||\n            _asset == \"VF_SAVAX_MAIN_AUTO\"\n        ) {\n            IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib\n                .stakedPositions();\n            uint256 positionsLength = positions.length;\n            for (uint256 i; i != positionsLength; ++i) {\n                IStakingPositions.StakedPosition memory position = positions[i];\n                if (position.identifier != _asset) continue;\n\n                positions[i] = positions[positionsLength - 1];\n                positions.pop();\n\n                IVectorFinanceCompounder compounder = _getAssetPoolHelper(\n                    position.asset\n                ).compounder();\n                uint256 shares = compounder.balanceOf(address(this));\n                uint256 stakedBalance = compounder.getDepositTokensForShares(shares);\n\n                _amount = compounder.depositTracking(address(this));\n                address(compounder).safeTransfer(msg.sender, _amount);\n\n                uint256 decimals = IERC20Metadata(tokenManager.getAssetAddress(positions[i].symbol, true)).decimals();\n                tokenManager.decreaseProtocolExposure(positions[i].identifier, stakedBalance * 1e18 / 10**decimals);\n\n                break;\n            }\n        } else {\n            IERC20Metadata token = getERC20TokenInstance(_asset, true);\n            _amount = token.balanceOf(address(this));\n\n            address(token).safeTransfer(msg.sender, _amount);\n            DiamondStorageLib.removeOwnedAsset(_asset);\n            tokenManager.decreaseProtocolExposure(\n                _asset,\n                (_amount * 1e18) / 10 ** token.decimals()\n            );\n        }\n\n        emit EmergencyWithdrawn(_asset, _amount, block.timestamp);\n    }\n\n    function _withdrawGLP() internal returns (uint256 _amount) {\n        IERC20Metadata token = getERC20TokenInstance(\"GLP\", true);\n        IERC20Metadata stakedGlpToken = IERC20Metadata(\n            0xaE64d55a6f09E4263421737397D1fdFA71896a69\n        );\n        _amount = token.balanceOf(address(this));\n\n        address(stakedGlpToken).safeTransfer(msg.sender, _amount);\n        if (token.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(\"GLP\");\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        tokenManager.decreaseProtocolExposure(\"GLP\", _amount);\n\n        emit EmergencyWithdrawn(\"GLP\", _amount, block.timestamp);\n    }\n\n    function _getAssetPoolHelper(\n        address asset\n    ) internal view returns (IVectorFinanceStaking) {\n        IVectorFinanceMainStaking mainStaking = IVectorFinanceMainStaking(\n            VectorMainStaking\n        );\n        return IVectorFinanceStaking(mainStaking.getPoolInfo(asset).helper);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyRC() {\n        IAddressProvider addressProvider = IAddressProvider(\n            DeploymentConstants.getAddressProvider()\n        );\n        require(\n            msg.sender == addressProvider.getRecoveryContract(),\n            \"msg.sender != RC\"\n        );\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after the funds are withdrawn from the loan\n     * @param asset withdrawn by a user\n     * @param amount of funds withdrawn\n     * @param timestamp of the withdrawal\n     **/\n    event EmergencyWithdrawn(\n        bytes32 indexed asset,\n        uint256 amount,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted after refund is received\n     * @param token that is refunded\n     * @param amount of the refund\n     */\n    event RefundReceived(address token, uint256 amount);\n}\n"
    },
    "contracts/facets/SmartLoanLiquidationFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67a8b3b5cf08577b7da8bd66bde607f0208725fd;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../lib/SolvencyMethods.sol\";\nimport \"../Pool.sol\";\nimport \"../interfaces/ITokenManager.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\nimport \"./avalanche/SolvencyFacetProdAvalanche.sol\";\nimport \"../SmartLoanDiamondBeacon.sol\";\n\ncontract SmartLoanLiquidationFacet is ReentrancyGuardKeccak, SolvencyMethods {\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\n    uint256 private constant _MAX_HEALTH_AFTER_LIQUIDATION = 1.042e18;\n\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\n    uint256 private constant _MAX_LIQUIDATION_BONUS = 200;\n\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    /** @param assetsToRepay names of tokens to be repaid to pools\n    /** @param amountsToRepay amounts of tokens to be repaid to pools\n      * @param liquidationBonus per mille bonus for liquidator. Must be smaller or equal to getMaxLiquidationBonus(). Defined for\n      * liquidating loans where debt ~ total value\n      * @param allowUnprofitableLiquidation allows performing liquidation of bankrupt loans (total value smaller than debt)\n    **/\n\n    struct LiquidationConfig {\n        bytes32[] assetsToRepay;\n        uint256[] amountsToRepay;\n        uint256 liquidationBonusPercent;\n        bool allowUnprofitableLiquidation;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n      * Returns maximum acceptable health ratio after liquidation\n      **/\n    function getMaxHealthAfterLiquidation() public pure returns (uint256) {\n        return _MAX_HEALTH_AFTER_LIQUIDATION;\n    }\n\n    /**\n      * Returns maximum acceptable liquidation bonus (bonus is provided by a liquidator)\n      **/\n    function getMaxLiquidationBonus() public pure returns (uint256) {\n        return _MAX_LIQUIDATION_BONUS;\n    }\n\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\n\n    function whitelistLiquidators(address[] memory _liquidators) external onlyOwner {\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\n\n        for(uint i; i<_liquidators.length; i++){\n            ls.canLiquidate[_liquidators[i]] = true;\n            emit LiquidatorWhitelisted(_liquidators[i], msg.sender, block.timestamp);\n        }\n    }\n\n    function delistLiquidators(address[] memory _liquidators) external onlyOwner {\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\n        for(uint i; i<_liquidators.length; i++){\n            ls.canLiquidate[_liquidators[i]] = false;\n            emit LiquidatorDelisted(_liquidators[i], msg.sender, block.timestamp);\n        }\n    }\n\n    function isLiquidatorWhitelisted(address _liquidator) public view returns(bool){\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\n        return ls.canLiquidate[_liquidator];\n    }\n\n    /**\n    * This function can be accessed by any user when Prime Account is insolvent or bankrupt and repay part of the loan\n    * with his approved tokens.\n    * BE CAREFUL: in contrast to liquidateLoan() method, this one doesn't necessarily return tokens to liquidator, nor give him\n    * a bonus. It's purpose is to bring the loan to a solvent position even if it's unprofitable for liquidator.\n    * @dev This function uses the redstone-evm-connector\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to getMaxliquidationBonus()\n    **/\n    function unsafeLiquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators accountNotFrozen nonReentrant {\n        liquidate(\n            LiquidationConfig({\n                assetsToRepay : assetsToRepay,\n                amountsToRepay : amountsToRepay,\n                liquidationBonusPercent : _liquidationBonusPercent,\n                allowUnprofitableLiquidation : true\n            })\n        );\n    }\n\n    /**\n    * This function can be accessed by any user when Prime Account is insolvent and liquidate part of the loan\n    * with his approved tokens.\n    * A liquidator has to approve adequate amount of tokens to repay debts to liquidity pools if\n    * there is not enough of them in a SmartLoan. For that he will receive the corresponding amount from SmartLoan\n    * with the same USD value + bonus.\n    * @dev This function uses the redstone-evm-connector\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to  getMaxLiquidationBonus()\n    **/\n    function liquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators accountNotFrozen nonReentrant {\n        liquidate(\n            LiquidationConfig({\n                assetsToRepay : assetsToRepay,\n                amountsToRepay : amountsToRepay,\n                liquidationBonusPercent : _liquidationBonusPercent,\n                allowUnprofitableLiquidation : false\n            })\n        );\n    }\n\n    /**\n    * This function can be accessed when Prime Account is insolvent and perform a partial liquidation of the loan\n    * (selling assets, closing positions and repaying debts) to bring the account back to a solvent state. At the end\n    * of liquidation resulting solvency of account is checked to make sure that the account is between maximum and minimum\n    * solvency.\n    * To diminish the potential effect of manipulation of liquidity pools by a liquidator, there are no swaps performed\n    * during liquidation.\n    * @dev This function uses the redstone-evm-connector\n    * @param config configuration for liquidation\n    **/\n    function liquidate(LiquidationConfig memory config) internal {\n        require(config.assetsToRepay.length == config.amountsToRepay.length, \"Array length mismatch\");\n        SolvencyFacetProdAvalanche.CachedPrices memory cachedPrices = _getAllPricesForLiquidation(config.assetsToRepay);\n\n        uint256 initialTotal = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices); \n        uint256 initialDebt = _getDebtWithPrices(cachedPrices.debtAssetsPrices); \n\n        require(config.liquidationBonusPercent <= getMaxLiquidationBonus(), \"Defined liquidation bonus higher than max. value\");\n\n        require(!_isSolventWithPrices(cachedPrices), \"Cannot sellout a solvent account\");\n\n        //healing means bringing a bankrupt loan to a state when debt is smaller than total value again\n        bool healingLoan = initialDebt > initialTotal;\n        require(!healingLoan || config.allowUnprofitableLiquidation, \"Trying to liquidate bankrupt loan\");\n\n        uint256 suppliedInUSD;\n        uint256 repaidInUSD;\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        for (uint256 i = 0; i < config.assetsToRepay.length; i++) {\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(config.assetsToRepay[i], true));\n\n            uint256 balance = token.balanceOf(address(this));\n            uint256 supplyAmount;\n\n            if (balance < config.amountsToRepay[i]) {\n                supplyAmount = config.amountsToRepay[i] - balance;\n            }\n\n            if (supplyAmount > 0) {\n                address(token).safeTransferFrom(msg.sender, address(this), supplyAmount);\n                // supplyAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\n                suppliedInUSD += supplyAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\n            }\n\n            Pool pool = Pool(tokenManager.getPoolAddress(config.assetsToRepay[i]));\n\n            uint256 repayAmount = Math.min(pool.getBorrowed(address(this)), config.amountsToRepay[i]);\n\n            address(token).safeApprove(address(pool), 0);\n            address(token).safeApprove(address(pool), repayAmount);\n\n            // repayAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\n            repaidInUSD += repayAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\n\n            pool.repay(repayAmount);\n            if (repayAmount > supplyAmount) {\n                _decreaseExposure(tokenManager, address(token), repayAmount - supplyAmount);\n            } else {\n                _increaseExposure(tokenManager, address(token), supplyAmount - repayAmount);\n            }\n\n            emit LiquidationRepay(msg.sender, config.assetsToRepay[i], repayAmount, block.timestamp);\n        }\n\n        bytes32[] memory assetsOwned = DeploymentConstants.getAllOwnedAssets();\n        uint256 bonusInUSD;\n\n        //after healing bankrupt loan (debt > total value), no tokens are returned to liquidator\n\n        bonusInUSD = repaidInUSD * config.liquidationBonusPercent / DeploymentConstants.getPercentagePrecision();\n\n        //meaning returning all tokens\n        uint256 partToReturnBonus = 10 ** 18; // 1\n        uint256 assetsValue = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\n\n        if (!healingLoan && assetsValue >= suppliedInUSD + bonusInUSD) {\n            //in that scenario we calculate how big part of token to return\n            partToReturnBonus = (suppliedInUSD + bonusInUSD) * 10 ** 18 / assetsValue;\n        }\n\n        if(partToReturnBonus > 0){\n            // Native token transfer\n            if (address(this).balance > 0) {\n                uint256 transferAmount = address(this).balance * partToReturnBonus / 3 / 10 ** 18;\n                payable(DeploymentConstants.getStabilityPoolAddress()).safeTransferETH(transferAmount);\n                emit LiquidationTransfer(DeploymentConstants.getStabilityPoolAddress(), DeploymentConstants.getNativeTokenSymbol(), transferAmount, block.timestamp);\n\n                payable(DeploymentConstants.getTreasuryAddress()).safeTransferETH(transferAmount);\n                emit LiquidationFeesTransfer(DeploymentConstants.getTreasuryAddress(), DeploymentConstants.getNativeTokenSymbol(), transferAmount, block.timestamp);\n\n                payable(DeploymentConstants.getFeesRedistributionAddress()).safeTransferETH(transferAmount);\n                emit LiquidationFeesRedistributionTransfer(DeploymentConstants.getFeesRedistributionAddress(), DeploymentConstants.getNativeTokenSymbol(), transferAmount, block.timestamp);\n            }\n\n            for (uint256 i; i < assetsOwned.length; i++) {\n                IERC20Metadata token = getERC20TokenInstance(assetsOwned[i], true);\n                if(address(token) == 0x9e295B5B976a184B14aD8cd72413aD846C299660){\n                    token = IERC20Metadata(0xaE64d55a6f09E4263421737397D1fdFA71896a69);\n                }\n                uint256 balance = token.balanceOf(address(this));\n\n                if(balance > 0){\n                    uint256 transferAmount = balance * partToReturnBonus / 3 / 10 ** 18;\n                    address(token).safeTransfer(DeploymentConstants.getStabilityPoolAddress(), transferAmount);\n                    emit LiquidationTransfer(DeploymentConstants.getStabilityPoolAddress(), assetsOwned[i], transferAmount, block.timestamp);\n\n                    address(token).safeTransfer(DeploymentConstants.getTreasuryAddress(), transferAmount);\n                    emit LiquidationFeesTransfer(DeploymentConstants.getTreasuryAddress(), assetsOwned[i], transferAmount, block.timestamp);\n\n                    address(token).safeTransfer(DeploymentConstants.getFeesRedistributionAddress(), transferAmount);\n                    emit LiquidationFeesRedistributionTransfer(DeploymentConstants.getFeesRedistributionAddress(), assetsOwned[i], transferAmount, block.timestamp);\n\n                    _decreaseExposure(tokenManager, address(token), transferAmount*3);\n\n                }\n\n            }\n        }\n\n        uint256 health = _getHealthRatioWithPrices(cachedPrices);\n\n        if (healingLoan) {\n            require(_getDebtWithPrices(cachedPrices.debtAssetsPrices) == 0, \"Healing a loan must end up with 0 debt\");\n            require(_getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices) == 0, \"Healing a loan must end up with 0 total value\");\n        } else {\n            require(health <= getMaxHealthAfterLiquidation(), \"This operation would result in a loan with health ratio higher than Maxium Health Ratio which would put loan's owner in a risk of an unnecessarily high loss\");\n        }\n\n        require(health >= 1e18, \"This operation would not result in bringing the loan back to a solvent state\");\n\n        //TODO: include final debt and tv\n        emit Liquidated(msg.sender, healingLoan, initialTotal, initialDebt, repaidInUSD, bonusInUSD, health, block.timestamp);\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    modifier accountNotFrozen(){\n        require(!DiamondStorageLib.isAccountFrozen(), \"Account is frozen\");\n        _;\n    }\n\n    modifier onlyWhitelistedLiquidators() {\n        // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\n        require(SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\n        _;\n    }\n\n    /**\n     * @dev emitted after a successful liquidation operation\n     * @param liquidator the address that initiated the liquidation operation\n     * @param healing was the liquidation covering the bad debt (unprofitable liquidation)\n     * @param initialTotal total value of assets before the liquidation\n     * @param initialDebt sum of all debts before the liquidation\n     * @param repayAmount requested amount (USD) of liquidation\n     * @param bonusInUSD an amount of bonus (USD) received by the liquidator\n     * @param health a new health ratio after the liquidation operation\n     * @param timestamp a time of the liquidation\n     **/\n    event Liquidated(address indexed liquidator, bool indexed healing, uint256 initialTotal, uint256 initialDebt, uint256 repayAmount, uint256 bonusInUSD, uint256 health, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are repaid to the pool during a liquidation\n     * @param liquidator the address initiating repayment\n     * @param asset asset repaid by a liquidator\n     * @param amount of repaid funds\n     * @param timestamp of the repayment\n     **/\n    event LiquidationRepay(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are sent to liquidator during liquidation\n     * @param treasury the address of stability pool\n     * @param asset token sent to a liquidator\n     * @param amount of sent funds\n     * @param timestamp of the transfer\n     **/\n    event LiquidationTransfer(address indexed treasury, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are sent to fees treasury during liquidation\n     * @param treasury the address of fees treasury\n     * @param asset token sent to a treasury\n     * @param amount of sent funds\n     * @param timestamp of the transfer\n     **/\n    event LiquidationFeesTransfer(address indexed treasury, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are sent to fees redistribution treasury during liquidation\n     * @param treasury the address of fees treasury\n     * @param asset token sent to a treasury\n     * @param amount of sent funds\n     * @param timestamp of the transfer\n     **/\n    event LiquidationFeesRedistributionTransfer(address indexed treasury, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when a new liquidator gets whitelisted\n     * @param liquidator the address being whitelisted\n     * @param performer the address initiating whitelisting\n     * @param timestamp of the whitelisting\n     **/\n    event LiquidatorWhitelisted(address indexed liquidator, address performer, uint256 timestamp);\n\n    /**\n     * @dev emitted when a liquidator gets delisted\n     * @param liquidator the address being delisted\n     * @param performer the address initiating delisting\n     * @param timestamp of the delisting\n     **/\n    event LiquidatorDelisted(address indexed liquidator, address performer, uint256 timestamp);\n}\n\n"
    },
    "contracts/facets/SmartLoanLiquidationFacetDebug.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../lib/SolvencyMethods.sol\";\nimport \"../Pool.sol\";\nimport \"../interfaces/ITokenManager.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../interfaces/facets/ISmartLoanLiquidationFacet.sol\";\n\nimport \"./avalanche/SolvencyFacetProdAvalanche.sol\";\nimport \"../SmartLoanDiamondBeacon.sol\";\nimport \"hardhat/console.sol\";\n\ncontract SmartLoanLiquidationFacetDebug is ReentrancyGuardKeccak, SolvencyMethods {\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\n    uint256 private constant _MAX_HEALTH_AFTER_LIQUIDATION = 1.042e18;\n\n    //IMPORTANT: KEEP IT IDENTICAL ACROSS FACETS TO BE PROPERLY UPDATED BY DEPLOYMENT SCRIPTS\n    uint256 private constant _MAX_LIQUIDATION_BONUS = 200;\n\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    /** @param assetsToRepay names of tokens to be repaid to pools\n    /** @param amountsToRepay amounts of tokens to be repaid to pools\n      * @param liquidationBonus per mille bonus for liquidator. Must be smaller or equal to getMaxLiquidationBonus(). Defined for\n      * liquidating loans where debt ~ total value\n      * @param allowUnprofitableLiquidation allows performing liquidation of bankrupt loans (total value smaller than debt)\n    **/\n\n    struct LiquidationConfig {\n        bytes32[] assetsToRepay;\n        uint256[] amountsToRepay;\n        uint256 liquidationBonusPercent;\n        bool allowUnprofitableLiquidation;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n      * Returns maximum acceptable health ratio after liquidation\n      **/\n    function getMaxHealthAfterLiquidation() public pure returns (uint256) {\n        return _MAX_HEALTH_AFTER_LIQUIDATION;\n    }\n\n    /**\n      * Returns maximum acceptable liquidation bonus (bonus is provided by a liquidator)\n      **/\n    function getMaxLiquidationBonus() public pure returns (uint256) {\n        return _MAX_LIQUIDATION_BONUS;\n    }\n\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\n\n    function whitelistLiquidators(address[] memory _liquidators) external onlyOwner {\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\n\n        for(uint i; i<_liquidators.length; i++){\n            ls.canLiquidate[_liquidators[i]] = true;\n            emit LiquidatorWhitelisted(_liquidators[i], msg.sender, block.timestamp);\n        }\n    }\n\n    function delistLiquidators(address[] memory _liquidators) external onlyOwner {\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\n        for(uint i; i<_liquidators.length; i++){\n            ls.canLiquidate[_liquidators[i]] = false;\n            emit LiquidatorDelisted(_liquidators[i], msg.sender, block.timestamp);\n        }\n    }\n\n    function isLiquidatorWhitelisted(address _liquidator) public view returns(bool){\n        DiamondStorageLib.LiquidationStorage storage ls = DiamondStorageLib.liquidationStorage();\n        return ls.canLiquidate[_liquidator];\n    }\n\n    /**\n    * This function can be accessed by any user when Prime Account is insolvent or bankrupt and repay part of the loan\n    * with his approved tokens.\n    * BE CAREFUL: in contrast to liquidateLoan() method, this one doesn't necessarily return tokens to liquidator, nor give him\n    * a bonus. It's purpose is to bring the loan to a solvent position even if it's unprofitable for liquidator.\n    * @dev This function uses the redstone-evm-connector\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to getMaxliquidationBonus()\n    **/\n    function unsafeLiquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators nonReentrant {\n        liquidate(\n            LiquidationConfig({\n                assetsToRepay : assetsToRepay,\n                amountsToRepay : amountsToRepay,\n                liquidationBonusPercent : _liquidationBonusPercent,\n                allowUnprofitableLiquidation : true\n            })\n        );\n    }\n\n    /**\n    * This function can be accessed by any user when Prime Account is insolvent and liquidate part of the loan\n    * with his approved tokens.\n    * A liquidator has to approve adequate amount of tokens to repay debts to liquidity pools if\n    * there is not enough of them in a SmartLoan. For that he will receive the corresponding amount from SmartLoan\n    * with the same USD value + bonus.\n    * @dev This function uses the redstone-evm-connector\n    * @param assetsToRepay bytes32[] names of tokens provided by liquidator for repayment\n    * @param amountsToRepay utin256[] amounts of tokens provided by liquidator for repayment\n    * @param _liquidationBonusPercent per mille bonus for liquidator. Must be lower than or equal to  getMaxLiquidationBonus()\n    **/\n    function liquidateLoan(bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonusPercent) external payable onlyWhitelistedLiquidators nonReentrant {\n        liquidate(\n            LiquidationConfig({\n                assetsToRepay : assetsToRepay,\n                amountsToRepay : amountsToRepay,\n                liquidationBonusPercent : _liquidationBonusPercent,\n                allowUnprofitableLiquidation : false\n            })\n        );\n    }\n\n    /**\n    * This function can be accessed when Prime Account is insolvent and perform a partial liquidation of the loan\n    * (selling assets, closing positions and repaying debts) to bring the account back to a solvent state. At the end\n    * of liquidation resulting solvency of account is checked to make sure that the account is between maximum and minimum\n    * solvency.\n    * To diminish the potential effect of manipulation of liquidity pools by a liquidator, there are no swaps performed\n    * during liquidation.\n    * @dev This function uses the redstone-evm-connector\n    * @param config configuration for liquidation\n    **/\n    function liquidate(LiquidationConfig memory config) internal {\n        console.log('Welcome to the liquidation sir');\n        SolvencyFacetProdAvalanche.CachedPrices memory cachedPrices = _getAllPricesForLiquidation(config.assetsToRepay);\n        \n        uint256 initialTotal = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices); \n        uint256 initialDebt = _getDebtWithPrices(cachedPrices.debtAssetsPrices); \n\n        require(config.liquidationBonusPercent <= getMaxLiquidationBonus(), \"Defined liquidation bonus higher than max. value\");\n        require(!_isSolventWithPrices(cachedPrices), \"Cannot sellout a solvent account\");\n\n        //healing means bringing a bankrupt loan to a state when debt is smaller than total value again\n        bool healingLoan = initialDebt > initialTotal;\n        if(healingLoan){\n            console.log('HEALING LOAN');\n        } else{\n            console.log('NOT A HEALING LOAN');\n        }\n        console.log(initialTotal);\n        console.log(initialDebt);\n        require(!healingLoan || config.allowUnprofitableLiquidation, \"Trying to liquidate bankrupt loan\");\n\n\n        uint256 suppliedInUSD;\n        uint256 repaidInUSD;\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        console.log('1');\n\n        for (uint256 i = 0; i < config.assetsToRepay.length; i++) {\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(config.assetsToRepay[i], true));\n\n            uint256 balance = token.balanceOf(address(this));\n            uint256 supplyAmount;\n\n            if (balance < config.amountsToRepay[i]) {\n                supplyAmount = config.amountsToRepay[i] - balance;\n            }\n\n            if (supplyAmount > 0) {\n                address(token).safeTransferFrom(msg.sender, address(this), supplyAmount);\n                // supplyAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\n                suppliedInUSD += supplyAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\n            }\n\n            Pool pool = Pool(tokenManager.getPoolAddress(config.assetsToRepay[i]));\n\n            uint256 repayAmount = Math.min(pool.getBorrowed(address(this)), config.amountsToRepay[i]);\n\n            address(token).safeApprove(address(pool), 0);\n            address(token).safeApprove(address(pool), repayAmount);\n\n            // repayAmount is denominated in token.decimals(). Price is denominated in 1e8. To achieve 1e18 decimals we need to multiply by 1e10.\n            repaidInUSD += repayAmount * cachedPrices.assetsToRepayPrices[i].price * 10 ** 10 / 10 ** token.decimals();\n\n            pool.repay(repayAmount);\n\n            if (token.balanceOf(address(this)) == 0) {\n                DiamondStorageLib.removeOwnedAsset(config.assetsToRepay[i]);\n            }\n\n            emit LiquidationRepay(msg.sender, config.assetsToRepay[i], repayAmount, block.timestamp);\n        }\n\n        console.log('2');\n\n        bytes32[] memory assetsOwned = DeploymentConstants.getAllOwnedAssets();\n        uint256 bonusInUSD;\n\n        //after healing bankrupt loan (debt > total value), no tokens are returned to liquidator\n\n        bonusInUSD = repaidInUSD * config.liquidationBonusPercent / DeploymentConstants.getPercentagePrecision();\n\n        //meaning returning all tokens\n        uint256 partToReturn = 10 ** 18; // 1\n        uint256 assetsValue = _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\n\n        if (!healingLoan && assetsValue >= suppliedInUSD + bonusInUSD) {\n            //in that scenario we calculate how big part of token to return\n            partToReturn = (suppliedInUSD + bonusInUSD) * 10 ** 18 / assetsValue;\n        }\n\n        // Native token transfer\n        if (address(this).balance > 0) {\n            payable(msg.sender).safeTransferETH(address(this).balance * partToReturn / 10 ** 18);\n        }\n\n        console.log('3');\n\n        for (uint256 i; i < assetsOwned.length; i++) {\n            IERC20Metadata token = getERC20TokenInstance(assetsOwned[i], true);\n            uint256 balance = token.balanceOf(address(this));\n\n            address(token).safeTransfer(msg.sender, balance * partToReturn / 10 ** 18);\n            emit LiquidationTransfer(msg.sender, assetsOwned[i], balance * partToReturn / 10 ** 18, block.timestamp);\n        }\n\n        console.log('4');\n\n        uint256 health = _getHealthRatioWithPrices(cachedPrices);\n\n        console.log('5');\n\n        if (healingLoan) {\n            require(_getDebtWithPrices(cachedPrices.debtAssetsPrices) == 0, \"Healing a loan must end up with 0 debt\");\n            require(_getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices) == 0, \"Healing a loan must end up with 0 total value\");\n        } else {\n            console.log('Health: %s', health);\n            console.log('Total value: %s', _getTotalValue());\n            console.log('Debt: %s', _getDebt());\n            require(health <= getMaxHealthAfterLiquidation(), \"This operation would result in a loan with health ratio higher than Maxium Health Ratio which would put loan's owner in a risk of an unnecessarily high loss\");\n        }\n\n        console.log('6');\n\n        console.log('TV: %s', _getTotalValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices));\n        console.log('Debt: %s', _getDebtWithPrices(cachedPrices.debtAssetsPrices));\n\n        console.log('Health: %s', health);\n\n        require(health >= 1e18, \"This operation would not result in bringing the loan back to a solvent state\");\n\n        console.log('FINISHED');\n\n        //TODO: include final debt and tv\n        emit Liquidated(msg.sender, healingLoan, initialTotal, initialDebt, repaidInUSD, bonusInUSD, health, block.timestamp);\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    modifier onlyWhitelistedLiquidators() {\n        // External call in order to execute this method in the SmartLoanDiamondBeacon contract storage\n        require(ISmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender), \"Only whitelisted liquidators can execute this method\");\n        _;\n    }\n\n    /**\n     * @dev emitted after a successful liquidation operation\n     * @param liquidator the address that initiated the liquidation operation\n     * @param healing was the liquidation covering the bad debt (unprofitable liquidation)\n     * @param initialTotal total value of assets before the liquidation\n     * @param initialDebt sum of all debts before the liquidation\n     * @param repayAmount requested amount (USD) of liquidation\n     * @param bonusInUSD an amount of bonus (USD) received by the liquidator\n     * @param health a new health ratio after the liquidation operation\n     * @param timestamp a time of the liquidation\n     **/\n    event Liquidated(address indexed liquidator, bool indexed healing, uint256 initialTotal, uint256 initialDebt, uint256 repayAmount, uint256 bonusInUSD, uint256 health, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are repaid to the pool during a liquidation\n     * @param liquidator the address initiating repayment\n     * @param asset asset repaid by a liquidator\n     * @param amount of repaid funds\n     * @param timestamp of the repayment\n     **/\n    event LiquidationRepay(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when funds are sent to liquidator during liquidation\n     * @param liquidator the address initiating repayment\n     * @param asset token sent to a liquidator\n     * @param amount of sent funds\n     * @param timestamp of the transfer\n     **/\n    event LiquidationTransfer(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    /**\n     * @dev emitted when a new liquidator gets whitelisted\n     * @param liquidator the address being whitelisted\n     * @param performer the address initiating whitelisting\n     * @param timestamp of the whitelisting\n     **/\n    event LiquidatorWhitelisted(address indexed liquidator, address performer, uint256 timestamp);\n\n    /**\n     * @dev emitted when a liquidator gets delisted\n     * @param liquidator the address being delisted\n     * @param performer the address initiating delisting\n     * @param timestamp of the delisting\n     **/\n    event LiquidatorDelisted(address indexed liquidator, address performer, uint256 timestamp);\n}\n\n"
    },
    "contracts/facets/SmartLoanViewFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 58540cc393d0ec84985be9436eb892d71bb3b0c6;\npragma solidity 0.8.27;\n\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../lib/SolvencyMethods.sol\";\nimport \"../Pool.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract SmartLoanViewFacet is ReentrancyGuardKeccak, SolvencyMethods {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    struct AssetNameBalance {\n        bytes32 name;\n        uint256 balance;\n    }\n\n    struct AssetNameBalanceDebtCoverage {\n        bytes32 name;\n        uint256 balance;\n        uint256 debtCoverage;\n    }\n\n    struct AssetNameDebt {\n        bytes32 name;\n        uint256 debt;\n    }\n\n    struct AssetNamePrice {\n        bytes32 name;\n        uint256 price;\n    }\n\n    /* ========== PUBLIC AND EXTERNAL MUTATIVE FUNCTIONS ========== */\n\n    function initialize(address owner) external {\n        require(owner != address(0), \"Initialize: Cannot set the owner to a zero address\");\n\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\n        require(!sls._initialized, \"DiamondInit: contract is already initialized\");\n        DiamondStorageLib.setContractOwner(owner);\n        sls._initialized = true;\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    function getPercentagePrecision() public view virtual returns (uint256) {\n        return DeploymentConstants.getPercentagePrecision();\n    }\n\n    function getAccountFrozenSince() public view returns (uint256){\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\n        return sls.frozenSince;\n    }\n\n\n    /**\n    * Returns a current balance of the asset held by the smart loan\n    * @param _asset the code of an asset\n    **/\n    function getBalance(bytes32 _asset) public view returns (uint256) {\n        IERC20 token = IERC20(DeploymentConstants.getTokenManager().getAssetAddress(_asset, true));\n        return token.balanceOf(address(this));\n    }\n\n    function getAllOwnedAssets() external view returns (bytes32[] memory result) {\n        return DeploymentConstants.getAllOwnedAssets();\n    }\n\n    function getSupportedTokensAddresses() external view returns (address[] memory) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        return tokenManager.getSupportedTokensAddresses();\n    }\n\n    function getAllAssetsBalancesDebtCoverages() public view returns (AssetNameBalanceDebtCoverage[] memory) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        bytes32[] memory assets = tokenManager.getAllTokenAssets();\n        AssetNameBalanceDebtCoverage[] memory result = new AssetNameBalanceDebtCoverage[](assets.length);\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            address assetAddress = tokenManager.getAssetAddress(assets[i], true);\n            result[i] = AssetNameBalanceDebtCoverage({\n                name : assets[i],\n                balance : IERC20(assetAddress).balanceOf(address(this)),\n                debtCoverage : tokenManager.debtCoverage(assetAddress)\n            });\n        }\n\n        return result;\n    }\n\n    function getAllAssetsBalances() public view returns (AssetNameBalance[] memory) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        bytes32[] memory assets = tokenManager.getAllTokenAssets();\n        AssetNameBalance[] memory result = new AssetNameBalance[](assets.length);\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            result[i] = AssetNameBalance({\n            name : assets[i],\n            balance : IERC20(tokenManager.getAssetAddress(assets[i], true)).balanceOf(address(this))\n            });\n        }\n\n        return result;\n    }\n\n    function getDebts() public view returns (AssetNameDebt[] memory) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        bytes32[] memory assets = tokenManager.getAllPoolAssets();\n        AssetNameDebt[] memory result = new AssetNameDebt[](assets.length);\n\n        for (uint256 i = 0; i < assets.length; i++) {\n            Pool pool = Pool(tokenManager.getPoolAddress(assets[i]));\n\n            result[i] = AssetNameDebt({\n            name : assets[i],\n            debt : pool.getBorrowed(address(this))\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns the prices of all assets supported by the TokenManager\n     * It could be used as a helper method for UI\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function getAllAssetsPrices() public returns (AssetNamePrice[] memory) {\n        bytes32[] memory assets = DeploymentConstants.getTokenManager().getAllTokenAssets();\n        uint256[] memory prices = SolvencyMethods.getPrices(assets);\n        AssetNamePrice[] memory result = new AssetNamePrice[](assets.length);\n        for (uint i = 0; i < assets.length; i++) {\n            result[i] = AssetNamePrice({\n                name : assets[i],\n                price : prices[i]\n            });\n        }\n        return result;\n    }\n\n    function getContractOwner() external view returns (address _owner) {\n        _owner = DiamondStorageLib.contractOwner();\n    }\n\n    function getProposedOwner() external view returns (address _proposed) {\n        _proposed = DiamondStorageLib.proposedOwner();\n    }\n\n    function getStakedPositions() external view returns (IStakingPositions.StakedPosition[] memory  _positions) {\n        _positions = DiamondStorageLib.stakedPositions();\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n}"
    },
    "contracts/facets/SmartLoanWrappedNativeTokenFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: e431e50ac1cb32ed6fa23d9302056e3e06924d8b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../interfaces/IWrappedNativeToken.sol\";\nimport \"../OnlyOwnerOrInsolvent.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\ncontract SmartLoanWrappedNativeTokenFacet is OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n\n    function wrapNativeToken(uint256 amount) onlyOwnerOrInsolvent public {\n        require(amount <= address(this).balance, \"Not enough native token to wrap\");\n        require(amount > 0, \"Cannot wrap 0 tokens\");\n        IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\n        wrapped.deposit{value : amount}();\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(wrapped), amount);\n\n        emit WrapNative(msg.sender, amount, block.timestamp);\n    }\n\n    function depositNativeToken() public payable virtual {\n        IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\n        wrapped.deposit{value : msg.value}();\n\n        if (wrapped.balanceOf(address(this)) != 0) {\n            DiamondStorageLib.addOwnedAsset(DeploymentConstants.getNativeTokenSymbol(), address(wrapped));\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _increaseExposure(tokenManager, address(wrapped), msg.value);\n\n        emit DepositNative(msg.sender, msg.value, block.timestamp);\n    }\n\n    function unwrapAndWithdraw(uint256 _amount) onlyOwner remainsSolvent canRepayDebtFully public payable virtual {\n        IWrappedNativeToken wrapped = IWrappedNativeToken(DeploymentConstants.getNativeToken());\n        _amount = Math.min(wrapped.balanceOf(address(this)), _amount);\n        require(wrapped.balanceOf(address(this)) >= _amount, \"Not enough native token to unwrap and withdraw\");\n\n        wrapped.withdraw(_amount);\n\n        if (wrapped.balanceOf(address(this)) == 0) {\n            DiamondStorageLib.removeOwnedAsset(DeploymentConstants.getNativeTokenSymbol());\n        }\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, address(wrapped), _amount);\n\n        payable(msg.sender).safeTransferETH(_amount);\n\n        emit UnwrapAndWithdraw(msg.sender, _amount, block.timestamp);\n    }\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /* ========== EVENTS ========== */\n\n    /**\n    * @dev emitted when native tokens are wrapped in the SmartLoan\n    * @param user the address initiating wrap\n    * @param amount of wrapped funds\n    * @param timestamp of wrap\n    **/\n    event WrapNative(address indexed user, uint256 amount, uint256 timestamp);\n\n    /**\n    * @dev emitted when native tokens are deposited to the SmartLoan\n    * @param user the address initiating deposit of native token\n    * @param amount of deposited funds\n    * @param timestamp of deposit\n    **/\n    event DepositNative(address indexed user, uint256 amount, uint256 timestamp);\n\n    /**\n    * @dev emitted when native tokens are unwrapped and withdrawn from the SmartLoan\n    * @param user the address initiating unwrap and withdraw of native token\n    * @param amount of unwrapped and withdrawn funds\n    * @param timestamp of unwrap and withdraw\n    **/\n    event UnwrapAndWithdraw(address indexed user, uint256 amount, uint256 timestamp);\n\n}"
    },
    "contracts/facets/SolvencyFacetProd.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ecd675d46c3f696de7562f6be071a442d97f37d9;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../interfaces/ITokenManager.sol\";\nimport \"../Pool.sol\";\nimport \"../DiamondHelper.sol\";\nimport \"../interfaces/IStakingPositions.sol\";\nimport \"../interfaces/facets/avalanche/ITraderJoeV2Facet.sol\";\nimport \"../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol\";\nimport \"../lib/uniswap-v3/UniswapV3IntegrationHelper.sol\";\nimport \"../lib/uniswap-v3/LiquidityAmounts.sol\";\nimport {PriceHelper} from \"../lib/joe-v2/PriceHelper.sol\";\nimport {Uint256x256Math} from \"../lib/joe-v2/math/Uint256x256Math.sol\";\nimport {TickMath} from \"../lib/uniswap-v3/TickMath.sol\";\nimport {FullMath} from \"../lib/uniswap-v3/FullMath.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../interfaces/facets/avalanche/IUniswapV3Facet.sol\";\n\nabstract contract SolvencyFacetProd is RedstoneConsumerNumericBase, DiamondHelper {\n    using PriceHelper for uint256;\n    using Uint256x256Math for uint256;\n\n    struct AssetPrice {\n        bytes32 asset;\n        uint256 price;\n    }\n\n    // Struct used in the liquidation process to obtain necessary prices only once\n    struct CachedPrices {\n        AssetPrice[] ownedAssetsPrices;\n        AssetPrice[] debtAssetsPrices;\n        AssetPrice[] stakedPositionsPrices;\n        AssetPrice[] assetsToRepayPrices;\n    }\n\n    struct PriceInfo {\n        address tokenX;\n        address tokenY;\n        uint256 priceX;\n        uint256 priceY;\n    }\n\n    /**\n      * Checks if the loan is solvent.\n      * It means that the Health Ratio is greater than 1e18.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function isSolvent() public view returns (bool) {\n        if(DiamondStorageLib.isAccountFrozen()){\n            revert AccountFrozen();\n        }\n        return getHealthRatio() >= 1e18;\n    }\n\n    function isSolventPayable() external payable returns (bool) {\n        return isSolvent();\n    }\n\n    /**\n      * Checks if the loan is solvent.\n      * It means that the Health Ratio is greater than 1e18.\n      * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\n      * @param cachedPrices Struct containing arrays of Asset/Price structs used to calculate value of owned assets, debt and staked positions\n    **/\n    function isSolventWithPrices(CachedPrices memory cachedPrices) public view returns (bool) {\n        return getHealthRatioWithPrices(cachedPrices) >= 1e18;\n    }\n\n    /**\n      * Returns an array of Asset/Price structs of staked positions.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function getStakedPositionsPrices() public view returns(AssetPrice[] memory result) {\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n\n        bytes32[] memory symbols = new bytes32[](positions.length);\n        for(uint256 i=0; i<positions.length; i++) {\n            symbols[i] = positions[i].symbol;\n        }\n\n        uint256[] memory stakedPositionsPrices = getOracleNumericValuesWithDuplicatesFromTxMsg(symbols);\n        result = new AssetPrice[](stakedPositionsPrices.length);\n\n        for(uint i; i<stakedPositionsPrices.length; i++){\n            result[i] = AssetPrice({\n                asset: symbols[i],\n                price: stakedPositionsPrices[i]\n            });\n        }\n    }\n\n    /**\n      * Returns an array of bytes32[] symbols of debt (borrowable) assets.\n    **/\n    function getDebtAssets() public view returns(bytes32[] memory result) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        result = tokenManager.getAllPoolAssets();\n    }\n\n    /**\n      * Returns an array of Asset/Price structs of debt (borrowable) assets.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function getDebtAssetsPrices() public view returns(AssetPrice[] memory result) {\n        bytes32[] memory debtAssets = getDebtAssets();\n\n        uint256[] memory debtAssetsPrices = getOracleNumericValuesFromTxMsg(debtAssets);\n        result = new AssetPrice[](debtAssetsPrices.length);\n\n        for(uint i; i<debtAssetsPrices.length; i++){\n            result[i] = AssetPrice({\n                asset: debtAssets[i],\n                price: debtAssetsPrices[i]\n            });\n        }\n    }\n\n    /**\n      * Returns an array of Asset/Price structs of enriched (always containing AVAX at index 0) owned assets.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function getOwnedAssetsWithNativePrices() public view returns(AssetPrice[] memory result) {\n        bytes32[] memory assetsEnriched = getOwnedAssetsWithNative();\n        uint256[] memory prices = getOracleNumericValuesFromTxMsg(assetsEnriched);\n\n        result = new AssetPrice[](assetsEnriched.length);\n\n        for(uint i; i<assetsEnriched.length; i++){\n            result[i] = AssetPrice({\n                asset: assetsEnriched[i],\n                price: prices[i]\n            });\n        }\n    }\n\n    /**\n      * Returns an array of bytes32[] symbols of staked positions.\n    **/\n    function getStakedAssets() internal view returns (bytes32[] memory result) {\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n        result = new bytes32[](positions.length);\n        for(uint i; i<positions.length; i++) {\n            result[i] = positions[i].symbol;\n        }\n    }\n\n    function copyToArray(bytes32[] memory target, bytes32[] memory source, uint256 offset, uint256 numberOfItems) pure internal {\n        if(numberOfItems > source.length){\n            revert ArrayLengthMismatch();\n        }\n        if(offset + numberOfItems > target.length){\n            revert ArrayLengthMismatch();\n        }\n\n        for(uint i; i<numberOfItems; i++){\n            target[i + offset] = source[i];\n        }\n    }\n\n    function copyToAssetPriceArray(AssetPrice[] memory target, bytes32[] memory sourceAssets, uint256[] memory sourcePrices, uint256 offset, uint256 numberOfItems) pure internal {\n        if(numberOfItems > sourceAssets.length){\n            revert ArrayLengthMismatch();\n        }\n        if(numberOfItems > sourcePrices.length){\n            revert ArrayLengthMismatch();\n        }\n        if(offset + numberOfItems > sourceAssets.length){\n            revert ArrayLengthMismatch();\n        }\n        if(offset + numberOfItems > sourcePrices.length){\n            revert ArrayLengthMismatch();\n        }\n\n        for(uint i; i<numberOfItems; i++){\n            target[i] = AssetPrice({\n                asset: sourceAssets[i+offset],\n                price: sourcePrices[i+offset]\n            });\n        }\n    }\n\n    /**\n      * Returns CachedPrices struct consisting of Asset/Price arrays for ownedAssets, debtAssets, stakedPositions and assetsToRepay.\n      * Used during the liquidation process in order to obtain all necessary prices from calldata only once.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function getAllPricesForLiquidation(bytes32[] memory assetsToRepay) public view returns (CachedPrices memory result) {\n        bytes32[] memory ownedAssetsEnriched = getOwnedAssetsWithNative();\n        bytes32[] memory debtAssets = getDebtAssets();\n        bytes32[] memory stakedAssets = getStakedAssets();\n\n        bytes32[] memory allAssetsSymbols = new bytes32[](ownedAssetsEnriched.length + debtAssets.length + stakedAssets.length + assetsToRepay.length);\n        uint256 offset;\n\n        // Populate allAssetsSymbols with owned assets symbols\n        copyToArray(allAssetsSymbols, ownedAssetsEnriched, offset, ownedAssetsEnriched.length);\n        offset += ownedAssetsEnriched.length;\n\n        // Populate allAssetsSymbols with debt assets symbols\n        copyToArray(allAssetsSymbols, debtAssets, offset, debtAssets.length);\n        offset += debtAssets.length;\n\n        // Populate allAssetsSymbols with staked assets symbols\n        copyToArray(allAssetsSymbols, stakedAssets, offset, stakedAssets.length);\n        offset += stakedAssets.length;\n\n        // Populate allAssetsSymbols with assets to repay symbols\n        copyToArray(allAssetsSymbols, assetsToRepay, offset, assetsToRepay.length);\n\n        uint256[] memory allAssetsPrices = getOracleNumericValuesWithDuplicatesFromTxMsg(allAssetsSymbols);\n\n        offset = 0;\n\n        // Populate ownedAssetsPrices struct\n        AssetPrice[] memory ownedAssetsPrices = new AssetPrice[](ownedAssetsEnriched.length);\n        copyToAssetPriceArray(ownedAssetsPrices, allAssetsSymbols, allAssetsPrices, offset, ownedAssetsEnriched.length);\n        offset += ownedAssetsEnriched.length;\n\n        // Populate debtAssetsPrices struct\n        AssetPrice[] memory debtAssetsPrices = new AssetPrice[](debtAssets.length);\n        copyToAssetPriceArray(debtAssetsPrices, allAssetsSymbols, allAssetsPrices, offset, debtAssets.length);\n        offset += debtAssetsPrices.length;\n\n        // Populate stakedPositionsPrices struct\n        AssetPrice[] memory stakedPositionsPrices = new AssetPrice[](stakedAssets.length);\n        copyToAssetPriceArray(stakedPositionsPrices, allAssetsSymbols, allAssetsPrices, offset, stakedAssets.length);\n        offset += stakedAssets.length;\n\n        // Populate assetsToRepayPrices struct\n        // Stack too deep :F\n        AssetPrice[] memory assetsToRepayPrices = new AssetPrice[](assetsToRepay.length);\n        for(uint i=0; i<assetsToRepay.length; i++){\n            assetsToRepayPrices[i] = AssetPrice({\n                asset: allAssetsSymbols[i+offset],\n                price: allAssetsPrices[i+offset]\n            });\n        }\n\n        result = CachedPrices({\n            ownedAssetsPrices: ownedAssetsPrices,\n            debtAssetsPrices: debtAssetsPrices,\n            stakedPositionsPrices: stakedPositionsPrices,\n            assetsToRepayPrices: assetsToRepayPrices\n        });\n    }\n\n    // Check whether there is enough debt-denominated tokens to fully repaid what was previously borrowed\n    function canRepayDebtFully() external view returns(bool) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        bytes32[] memory poolAssets = tokenManager.getAllPoolAssets();\n\n        for(uint i; i< poolAssets.length; i++) {\n            Pool pool = Pool(DeploymentConstants.getTokenManager().getPoolAddress(poolAssets[i]));\n            IERC20 token = IERC20(pool.tokenAddress());\n            if(token.balanceOf(address(this)) < pool.getBorrowed(address(this))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n      * Helper method exposing the redstone-evm-connector getOracleNumericValuesFromTxMsg() method.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function getPrices(bytes32[] memory symbols) external view returns (uint256[] memory) {\n        return getOracleNumericValuesFromTxMsg(symbols);\n    }\n\n    /**\n      * Helper method exposing the redstone-evm-connector getOracleNumericValueFromTxMsg() method.\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function getPrice(bytes32 symbol) external view returns (uint256) {\n        return getOracleNumericValueFromTxMsg(symbol);\n    }\n\n    /**\n      * Returns TotalWeightedValue of OwnedAssets in USD based on the supplied array of Asset/Price struct, tokenBalance and debtCoverage\n    **/\n    function _getTWVOwnedAssets(AssetPrice[] memory ownedAssetsPrices) internal virtual view returns (uint256) {\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        uint256 weightedValueOfTokens = ownedAssetsPrices[0].price * address(this).balance * tokenManager.debtCoverage(tokenManager.getAssetAddress(nativeTokenSymbol, true)) / (10 ** 26);\n\n        if (ownedAssetsPrices.length > 0) {\n\n            for (uint256 i = 0; i < ownedAssetsPrices.length; i++) {\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssetsPrices[i].asset, true));\n                weightedValueOfTokens = weightedValueOfTokens + (ownedAssetsPrices[i].price * token.balanceOf(address(this)) * tokenManager.debtCoverage(address(token)) / (10 ** token.decimals() * 1e8));\n            }\n        }\n        return weightedValueOfTokens;\n    }\n\n    /**\n      * Returns TotalWeightedValue of StakedPositions in USD based on the supplied array of Asset/Price struct, positionBalance and debtCoverage\n    **/\n    function _getTWVStakedPositions(AssetPrice[] memory stakedPositionsPrices) internal view returns (uint256) {\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n\n        uint256 weightedValueOfStaked;\n\n        for (uint256 i; i < positions.length; i++) {\n            if(stakedPositionsPrices[i].asset != positions[i].symbol){\n                revert PriceSymbolPositionMismatch();\n            }\n\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\n\n            if (success) {\n                uint256 balance = abi.decode(result, (uint256));\n\n                IERC20Metadata token = IERC20Metadata(DeploymentConstants.getTokenManager().getAssetAddress(stakedPositionsPrices[i].asset, true));\n\n                weightedValueOfStaked += stakedPositionsPrices[i].price * balance * tokenManager.debtCoverageStaked(positions[i].identifier) / (10 ** token.decimals() * 10**8);\n            }\n\n\n        }\n        return weightedValueOfStaked;\n    }\n\n    function _getThresholdWeightedValueBase(AssetPrice[] memory ownedAssetsPrices, AssetPrice[] memory stakedPositionsPrices) internal view virtual returns (uint256) {\n        return _getTWVOwnedAssets(ownedAssetsPrices) + _getTWVStakedPositions(stakedPositionsPrices) + _getTotalTraderJoeV2(true) + _getTotalUniswapV3(true);\n    }\n\n    /**\n      * Returns the threshold weighted value of assets in USD including all tokens as well as staking and LP positions\n      * @dev This function uses the redstone-evm-connector\n    **/\n    function getThresholdWeightedValue() public view virtual returns (uint256) {\n        AssetPrice[] memory ownedAssetsPrices = getOwnedAssetsWithNativePrices();\n        AssetPrice[] memory stakedPositionsPrices = getStakedPositionsPrices();\n        return _getThresholdWeightedValueBase(ownedAssetsPrices, stakedPositionsPrices);\n    }\n\n    function getThresholdWeightedValuePayable() external payable virtual returns (uint256) {\n        return getThresholdWeightedValue();\n    }\n\n    /**\n      * Returns the threshold weighted value of assets in USD including all tokens as well as staking and LP positions\n      * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\n    **/\n    function getThresholdWeightedValueWithPrices(AssetPrice[] memory ownedAssetsPrices, AssetPrice[] memory stakedPositionsPrices) public view virtual returns (uint256) {\n        return _getThresholdWeightedValueBase(ownedAssetsPrices, stakedPositionsPrices);\n    }\n\n\n    /**\n     * Returns the current debt denominated in USD\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function getDebtBase(AssetPrice[] memory debtAssetsPrices) internal view returns (uint256){\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        uint256 debt;\n\n        for (uint256 i; i < debtAssetsPrices.length; i++) {\n            IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(debtAssetsPrices[i].asset, true));\n\n            Pool pool = Pool(tokenManager.getPoolAddress(debtAssetsPrices[i].asset));\n            //10**18 (wei in eth) / 10**8 (precision of oracle feed) = 10**10\n            debt = debt + pool.getBorrowed(address(this)) * debtAssetsPrices[i].price * 10 ** 10\n            / 10 ** token.decimals();\n        }\n\n        return debt;\n    }\n\n    /**\n     * Returns the current debt denominated in USD\n     * @dev This function uses the redstone-evm-connector\n    **/\n    function getDebt() public view virtual returns (uint256) {\n        AssetPrice[] memory debtAssetsPrices = getDebtAssetsPrices();\n        return getDebtBase(debtAssetsPrices);\n    }\n\n    function getDebtPayable() external payable returns (uint256){\n        return getDebt();\n    }\n\n    /**\n     * Returns the current debt denominated in USD\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function getDebtWithPrices(AssetPrice[] memory debtAssetsPrices) public view virtual returns (uint256) {\n        return getDebtBase(debtAssetsPrices);\n    }\n\n\n    /**\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function _getTotalAssetsValueBase(AssetPrice[] memory ownedAssetsPrices) public virtual view returns (uint256) {\n        if (ownedAssetsPrices.length > 0) {\n            ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n            uint256 total = address(this).balance * ownedAssetsPrices[0].price / 10 ** 8;\n\n            for (uint256 i = 0; i < ownedAssetsPrices.length; i++) {\n                IERC20Metadata token = IERC20Metadata(tokenManager.getAssetAddress(ownedAssetsPrices[i].asset, true));\n                uint256 assetBalance = token.balanceOf(address(this));\n\n                total = total + (ownedAssetsPrices[i].price * 10 ** 10 * assetBalance / (10 ** token.decimals()));\n            }\n            return total;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function getTotalAssetsValue() public view virtual returns (uint256) {\n        AssetPrice[] memory ownedAssetsPrices = getOwnedAssetsWithNativePrices();\n        return _getTotalAssetsValueBase(ownedAssetsPrices);\n    }\n\n    /**\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function getTotalAssetsValueWithPrices(AssetPrice[] memory ownedAssetsPrices) public view virtual returns (uint256) {\n        return _getTotalAssetsValueBase(ownedAssetsPrices);\n    }\n\n    /**\n      * Returns list of owned assets that always included NativeToken at index 0\n    **/\n    function getOwnedAssetsWithNative() public view returns(bytes32[] memory){\n        bytes32[] memory ownedAssets = DeploymentConstants.getAllOwnedAssets();\n        bytes32 nativeTokenSymbol = DeploymentConstants.getNativeTokenSymbol();\n\n        // If account already owns the native token the use ownedAssets.length; Otherwise add one element to account for additional native token.\n        uint256 numberOfAssets = DiamondStorageLib.hasAsset(nativeTokenSymbol) ? ownedAssets.length : ownedAssets.length + 1;\n        bytes32[] memory assetsWithNative = new bytes32[](numberOfAssets);\n\n        uint256 lastUsedIndex;\n        assetsWithNative[0] = nativeTokenSymbol; // First asset = NativeToken\n\n        for(uint i=0; i< ownedAssets.length; i++){\n            if(ownedAssets[i] != nativeTokenSymbol){\n                lastUsedIndex += 1;\n                assetsWithNative[lastUsedIndex] = ownedAssets[i];\n            }\n        }\n        return assetsWithNative;\n    }\n\n    /**\n     * Returns the current value of staked positions in USD.\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function _getStakedValueBase(AssetPrice[] memory stakedPositionsPrices) internal view returns (uint256) {\n        IStakingPositions.StakedPosition[] storage positions = DiamondStorageLib.stakedPositions();\n\n        uint256 usdValue;\n\n        for (uint256 i; i < positions.length; i++) {\n            if(stakedPositionsPrices[i].asset != positions[i].symbol){\n                revert PriceSymbolPositionMismatch();\n            }\n\n            (bool success, bytes memory result) = address(this).staticcall(abi.encodeWithSelector(positions[i].balanceSelector));\n\n            if (success) {\n                uint256 balance = abi.decode(result, (uint256));\n                IERC20Metadata token = IERC20Metadata(DeploymentConstants.getTokenManager().getAssetAddress(stakedPositionsPrices[i].asset, true));\n                usdValue += stakedPositionsPrices[i].price * 10 ** 10 * balance / (10 ** token.decimals());\n            }\n        }\n\n        return usdValue;\n    }\n\n    /**\n     **/\n    function getTotalTraderJoeV2() public view virtual returns (uint256) {\n        return getTotalTraderJoeV2WithPrices();\n    }\n\n    /**\n    **/\n    function _getTotalTraderJoeV2(bool weighted) internal view returns (uint256) {\n        uint256 total;\n\n        ITraderJoeV2Facet.TraderJoeV2Bin[] memory ownedTraderJoeV2Bins = DiamondStorageLib.getTjV2OwnedBinsView();\n\n        PriceInfo memory priceInfo;\n\n        if (ownedTraderJoeV2Bins.length > 0) {\n            for (uint256 i; i < ownedTraderJoeV2Bins.length; i++) {\n                ITraderJoeV2Facet.TraderJoeV2Bin memory binInfo = ownedTraderJoeV2Bins[i];\n\n                uint256 price;\n                uint256 liquidity;\n\n                {\n                    address tokenXAddress = address(binInfo.pair.getTokenX());\n                    address tokenYAddress = address(binInfo.pair.getTokenY());\n\n                    if (priceInfo.tokenX != tokenXAddress || priceInfo.tokenY != tokenYAddress) {\n                        bytes32[] memory symbols = new bytes32[](2);\n\n\n                        symbols[0] = DeploymentConstants.getTokenManager().tokenAddressToSymbol(tokenXAddress);\n                        symbols[1] = DeploymentConstants.getTokenManager().tokenAddressToSymbol(tokenYAddress);\n\n                        uint256[] memory prices = getOracleNumericValuesFromTxMsg(symbols);\n                        priceInfo = PriceInfo(tokenXAddress, tokenYAddress, prices[0], prices[1]);\n                    }\n                }\n\n                {\n                    (uint128 binReserveX, uint128 binReserveY) = binInfo.pair.getBin(binInfo.id);\n\n                    price = PriceHelper.convert128x128PriceToDecimal(binInfo.pair.getPriceFromId(binInfo.id)); // how is it denominated (what precision)?\n\n                    liquidity = price * binReserveX / 10 ** 18 + binReserveY;\n                }\n\n\n                {\n                    uint256 debtCoverageX = weighted ? DeploymentConstants.getTokenManager().debtCoverage(address(binInfo.pair.getTokenX())) : 1e18;\n                    uint256 debtCoverageY = weighted ? DeploymentConstants.getTokenManager().debtCoverage(address(binInfo.pair.getTokenY())) : 1e18;\n\n                    total = total +\n                    Math.min(\n                        price > 10**24 ?\n                            debtCoverageX * liquidity / (price / 10 ** 18) / 10 ** IERC20Metadata(address(binInfo.pair.getTokenX())).decimals() * priceInfo.priceX / 10 ** 8\n                            :\n                            debtCoverageX * liquidity / price * 10**18 / 10 ** IERC20Metadata(address(binInfo.pair.getTokenX())).decimals() * priceInfo.priceX / 10 ** 8,\n                        debtCoverageY * liquidity / 10**(IERC20Metadata(address(binInfo.pair.getTokenY())).decimals()) * priceInfo.priceY / 10 ** 8\n                    )\n                    .mulDivRoundDown(binInfo.pair.balanceOf(address(this), binInfo.id), 1e18)\n                    .mulDivRoundDown(1e18, binInfo.pair.totalSupply(binInfo.id));\n                }\n            }\n\n            return total;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n    **/\n    function getTotalUniswapV3() public view virtual returns (uint256) {\n        return getTotalUniswapV3WithPrices();\n    }\n\n    /**\n    **/\n    function _getTotalUniswapV3(bool weighted) internal view returns (uint256) {\n        uint256 total;\n\n        uint256[] memory ownedUniswapV3TokenIds = DiamondStorageLib.getUV3OwnedTokenIdsView();\n        uint256 PRECISION = 20;\n\n        if (ownedUniswapV3TokenIds.length > 0) {\n\n            for (uint256 i; i < ownedUniswapV3TokenIds.length; i++) {\n\n                IUniswapV3Facet.UniswapV3Position memory position = getUniswapV3Position(INonfungiblePositionManager(0x655C406EBFa14EE2006250925e54ec43AD184f8B), ownedUniswapV3TokenIds[i]);\n\n                uint256[] memory prices = new uint256[](2);\n\n                {\n                    bytes32[] memory symbols = new bytes32[](2);\n\n                    symbols[0] = DeploymentConstants.getTokenManager().tokenAddressToSymbol(position.token0);\n                    symbols[1] = DeploymentConstants.getTokenManager().tokenAddressToSymbol(position.token1);\n\n                    prices = getOracleNumericValuesFromTxMsg(symbols);\n                }\n\n                {\n                    uint256 debtCoverage0 = weighted ? DeploymentConstants.getTokenManager().debtCoverage(position.token0) : 1e18;\n                    uint256 debtCoverage1 = weighted ? DeploymentConstants.getTokenManager().debtCoverage(position.token1) : 1e18;\n\n                    uint160 sqrtPriceX96_a = TickMath.getSqrtRatioAtTick(position.tickLower);\n                    uint160 sqrtPriceX96_b = TickMath.getSqrtRatioAtTick(position.tickUpper);\n\n                    uint256 price = 10**(PRECISION) * prices[0] * 10 ** IERC20Metadata(position.token1).decimals() / prices[1] / 10 ** IERC20Metadata(position.token0).decimals();\n                    uint160 sqrtMarketPriceX96 = uint160(UniswapV3IntegrationHelper.sqrt(price) * 2**96 / 10**(PRECISION/2));\n\n                    (uint256 token0Amount, uint256 token1amount) = LiquidityAmounts.getAmountsForLiquidity(\n                        sqrtMarketPriceX96,\n                        sqrtPriceX96_a,\n                        sqrtPriceX96_b,\n                        position.liquidity\n                    );\n\n                    uint256 positionWorth = debtCoverage0 * token0Amount / 10 ** IERC20Metadata(position.token0).decimals() * prices[0] / 10 ** 8\n                        + debtCoverage1 * token1amount / 10 ** IERC20Metadata(position.token1).decimals() * prices[1] / 10 ** 8;\n\n                    total = total + positionWorth;\n                }\n            }\n\n            return total;\n        } else {\n            return 0;\n        }\n    }\n\n\n    function getUniswapV3Position(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId) internal view returns (IUniswapV3Facet.UniswapV3Position memory position) {\n        (, , address token0, address token1, , int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = positionManager.positions(tokenId);\n\n        position = IUniswapV3Facet.UniswapV3Position(token0, token1, tickLower, tickUpper, liquidity);\n    }\n\n    /**\n     * Returns the current value of staked positions in USD.\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function getStakedValueWithPrices(AssetPrice[] memory stakedPositionsPrices) public view returns (uint256) {\n        return _getStakedValueBase(stakedPositionsPrices);\n    }\n\n    /**\n     * Returns the current value of Liquidity Book positions in USD.\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function getTotalTraderJoeV2WithPrices() public view returns (uint256) {\n        return _getTotalTraderJoeV2(false);\n    }\n\n    /**\n     * Returns the current value of Uniswap V3 positions in USD.\n     * Uses provided AssetPrice struct array instead of extracting the pricing data from the calldata again.\n    **/\n    function getTotalUniswapV3WithPrices() public view returns (uint256) {\n        return _getTotalUniswapV3(false);\n    }\n\n    /**\n     * Returns the current value of staked positions in USD.\n     * @dev This function uses the redstone-evm-connector\n    **/\n    function getStakedValue() public view virtual returns (uint256) {\n        AssetPrice[] memory stakedPositionsPrices = getStakedPositionsPrices();\n        return _getStakedValueBase(stakedPositionsPrices);\n    }\n\n    /**\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\n     * @dev This function uses the redstone-evm-connector\n    **/\n    function getTotalValue() public view virtual returns (uint256) {\n        return getTotalAssetsValue() + getStakedValue() + getTotalTraderJoeV2() + getTotalUniswapV3();\n    }\n\n    /**\n     * Returns the current value of Prime Account in USD including all tokens as well as staking and LP positions\n     * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\n    **/\n    function getTotalValueWithPrices(AssetPrice[] memory ownedAssetsPrices, AssetPrice[] memory stakedPositionsPrices) public view virtual returns (uint256) {\n        return getTotalAssetsValueWithPrices(ownedAssetsPrices) + getStakedValueWithPrices(stakedPositionsPrices) + getTotalTraderJoeV2WithPrices() + getTotalUniswapV3WithPrices();\n    }\n\n    function getFullLoanStatus() public view returns (uint256[5] memory) {\n        return [getTotalValue(), getDebt(), getThresholdWeightedValue(), getHealthRatio(), isSolvent() ? uint256(1) : uint256(0)];\n    }\n\n    /**\n     * Returns current health ratio (solvency) associated with the loan, defined as threshold weighted value of divided\n     * by current debt\n     * @dev This function uses the redstone-evm-connector\n     **/\n    function getHealthRatio() public view virtual returns (uint256) {\n        CachedPrices memory cachedPrices = getAllPricesForLiquidation(new bytes32[](0));\n        uint256 debt = getDebtWithPrices(cachedPrices.debtAssetsPrices);\n\n        if (debt == 0) {\n            return type(uint256).max;\n        } else {\n            uint256 thresholdWeightedValue = getThresholdWeightedValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\n            return thresholdWeightedValue * 1e18 / debt;\n        }\n    }\n\n    /**\n     * Returns current health ratio (solvency) associated with the loan, defined as threshold weighted value of divided\n     * by current debt\n     * Uses provided AssetPrice struct arrays instead of extracting the pricing data from the calldata again.\n     **/\n    function getHealthRatioWithPrices(CachedPrices memory cachedPrices) public view virtual returns (uint256) {\n        uint256 debt = getDebtWithPrices(cachedPrices.debtAssetsPrices);\n\n        if (debt == 0) {\n            return type(uint256).max;\n        } else {\n            uint256 thresholdWeightedValue = getThresholdWeightedValueWithPrices(cachedPrices.ownedAssetsPrices, cachedPrices.stakedPositionsPrices);\n            return thresholdWeightedValue * 1e18 / debt;\n        }\n    }\n\n    // ERRORS\n    error PriceSymbolPositionMismatch();\n\n    error AccountFrozen();\n\n    error ArrayLengthMismatch();\n}\n"
    },
    "contracts/facets/TraderJoeV2Facet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"../OnlyOwnerOrInsolvent.sol\";\nimport \"../interfaces/joe-v2/ILBRouter.sol\";\nimport \"../interfaces/joe-v2/ILBFactory.sol\";\nimport \"../interfaces/joe-v2/ILBHookLens.sol\";\nimport \"../interfaces/joe-v2/IRewarder.sol\";\nimport \"../interfaces/joe-v2/ILBHooksBaseRewarder.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\n\nabstract contract TraderJoeV2Facet is ITraderJoeV2Facet, ReentrancyGuardKeccak, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    address private constant REWARDER = 0x624C5b9BEB13af6893e715932c26e2b7A59c410a;\n\n    function maxBinsPerPrimeAccount() public view virtual returns (uint256);\n\n    function getJoeV2RouterAddress() public view virtual returns (address){\n        return 0xb4315e873dBcf96Ffd0acd8EA43f689D8c20fB30;\n    }\n\n    function getJoeV2LBHookLens() public view virtual returns (address){\n        return 0x6124086B90AB910038E607aa1BDD67b284C31c98;\n    }\n\n    function getOwnedTraderJoeV2Bins() public view returns (TraderJoeV2Bin[] memory result){\n        return DiamondStorageLib.getTjV2OwnedBinsView();\n    }\n\n    function getOwnedTraderJoeV2BinsStorage() internal returns (TraderJoeV2Bin[] storage result){\n        return DiamondStorageLib.getTjV2OwnedBins();\n    }\n\n    function getWhitelistedTraderJoeV2Pairs() internal view virtual returns (ILBPair[] memory pools);\n\n    function isPairWhitelisted(address pair) internal view virtual returns (bool) {\n        ILBPair[] memory pairs = getWhitelistedTraderJoeV2Pairs();\n\n        for (uint i; i < pairs.length; ++i) {\n            if (pair == address(pairs[i])) return true;\n        }\n        return false;\n    }\n\n    function isRouterWhitelisted(address router) internal view virtual returns (bool) {\n        address[] memory routers = new address[](2);\n        // Trader Joe V2.1\n        routers[0] = 0xb4315e873dBcf96Ffd0acd8EA43f689D8c20fB30;\n        // Trader Joe V2.2\n        routers[1] = 0x18556DA13313f3532c54711497A8FedAC273220E;\n\n        for (uint i; i < routers.length; ++i) {\n            if (router == routers[i]) return true;\n        }\n        return false;\n    }\n\n    function _removeLiquidity(ILBRouter traderJoeV2Router, RemoveLiquidityParameters memory parameters) internal returns (uint256, uint256){\n        (uint amountX, uint256 amountY) = traderJoeV2Router.removeLiquidity(\n            parameters.tokenX, parameters.tokenY, parameters.binStep, parameters.amountXMin, parameters.amountYMin, parameters.ids, parameters.amounts, address(this), parameters.deadline\n        );\n        return (amountX, amountY);\n    }\n\n    function claimReward(IRewarder.MerkleEntry[] calldata merkleEntries) external nonReentrant onlyOwner {\n        uint256 length = merkleEntries.length;\n        IERC20[] memory tokens = new IERC20[](length);\n        uint256[] memory beforeBalances = new uint256[](length);\n        for (uint256 i; i != length; ++i) {\n            tokens[i] = merkleEntries[i].token;\n            beforeBalances[i] = tokens[i].balanceOf(address(this));\n        }\n\n        IRewarder rewarder = IRewarder(REWARDER);\n        rewarder.batchClaim(merkleEntries);\n\n        for (uint256 i; i != length; ++i) {\n            uint256 newBalance = tokens[i].balanceOf(address(this));\n            if (newBalance > beforeBalances[i]) {\n                address(tokens[i]).safeTransfer(msg.sender, newBalance - beforeBalances[i]);\n            }\n        }\n    }\n\n    function claimReward(ILBPair pair, uint256[] calldata ids) external nonReentrant onlyOwner {\n        ILBHookLens lbHookLens = ILBHookLens(getJoeV2LBHookLens());\n        ILBHookLens.Parameters memory hookLens = lbHookLens.getHooks(address(pair));\n        address baseRewarder = hookLens.hooks;\n\n        if(baseRewarder == address(0)) revert TraderJoeV2NoRewardHook();\n\n        address rewardToken = address(ILBHooksBaseRewarder(baseRewarder).getRewardToken());\n        bool isNative = (rewardToken == address(0));\n        uint256 beforeBalance = isNative ? address(this).balance : IERC20(rewardToken).balanceOf(address(this));\n        ILBHooksBaseRewarder(baseRewarder).claim(address(this), ids);\n        uint256 reward = isNative ? address(this).balance - beforeBalance : IERC20(rewardToken).balanceOf(address(this)) - beforeBalance;\n        if(reward > 0) {\n            if(isNative) {\n                payable(msg.sender).safeTransferETH(reward);\n            } else {\n                rewardToken.safeTransfer(msg.sender, reward);\n            }\n        }\n    }\n\n    function fundLiquidityTraderJoeV2(ILBPair pair, uint256[] memory ids, uint256[] memory amounts) external nonReentrant {\n        if (!isPairWhitelisted(address(pair))) revert TraderJoeV2PoolNotWhitelisted();\n\n        pair.batchTransferFrom(msg.sender, address(this), ids, amounts);\n\n        TraderJoeV2Bin[] memory ownedBins = getOwnedTraderJoeV2Bins();\n\n        for (uint256 i; i < ids.length; ++i) {\n            bool userHadBin;\n\n            for (int256 j; uint(j) < ownedBins.length; ++j) {\n                if (address(ownedBins[uint(j)].pair) == address(pair)\n                    && ownedBins[uint(j)].id == ids[i]\n                ) {\n                    userHadBin = true;\n                    break;\n                }\n            }\n\n            if (!userHadBin) {\n                getOwnedTraderJoeV2BinsStorage().push(TraderJoeV2Bin(pair, uint24(ids[i])));\n            }\n        }\n\n        if (maxBinsPerPrimeAccount() > 0 && getOwnedTraderJoeV2BinsStorage().length > maxBinsPerPrimeAccount()) revert TooManyBins();\n\n        emit FundedLiquidityTraderJoeV2(msg.sender, address(pair), ids, amounts, block.timestamp);\n    }\n\n    function withdrawLiquidityTraderJoeV2(ILBPair pair, uint256[] memory ids, uint256[] memory amounts) external nonReentrant onlyOwner canRepayDebtFully noBorrowInTheSameBlock remainsSolvent {\n        if (!isPairWhitelisted(address(pair))) revert TraderJoeV2PoolNotWhitelisted();\n\n        pair.batchTransferFrom(address(this), msg.sender, ids, amounts);\n\n        TraderJoeV2Bin[] storage binsStorage = getOwnedTraderJoeV2BinsStorage();\n        TraderJoeV2Bin storage bin;\n\n        for (int256 i; uint(i) < binsStorage.length; i++) {\n            if (address(binsStorage[uint(i)].pair) == address(pair)) {\n                bin = binsStorage[uint(i)];\n\n                if (bin.pair.balanceOf(address(this), bin.id) == 0) {\n                    binsStorage[uint(i)] = binsStorage[binsStorage.length - 1];\n                    i--;\n                    binsStorage.pop();\n                }\n            }\n        }\n\n        emit WithdrawnLiquidityTraderJoeV2(msg.sender, address(pair), ids, amounts, block.timestamp);\n    }\n\n\n    function addLiquidityTraderJoeV2(ILBRouter traderJoeV2Router, ILBRouter.LiquidityParameters memory liquidityParameters) external nonReentrant onlyOwner noBorrowInTheSameBlock remainsSolvent {\n        if (!isRouterWhitelisted(address(traderJoeV2Router))) revert TraderJoeV2RouterNotWhitelisted();\n        TraderJoeV2Bin[] memory ownedBins = getOwnedTraderJoeV2Bins();\n        ILBFactory lbFactory = traderJoeV2Router.getFactory();\n        ILBFactory.LBPairInformation memory pairInfo = lbFactory.getLBPairInformation(liquidityParameters.tokenX, liquidityParameters.tokenY, liquidityParameters.binStep);\n\n        if (!isPairWhitelisted(address(pairInfo.LBPair))) revert TraderJoeV2PoolNotWhitelisted();\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n\n        bytes32 tokenX = tokenManager.tokenAddressToSymbol(address(liquidityParameters.tokenX));\n        bytes32 tokenY = tokenManager.tokenAddressToSymbol(address(liquidityParameters.tokenY));\n\n        liquidityParameters.to = address(this);\n        liquidityParameters.refundTo = address(this);\n\n        address(liquidityParameters.tokenX).safeApprove(address(traderJoeV2Router), 0);\n        address(liquidityParameters.tokenY).safeApprove(address(traderJoeV2Router), 0);\n\n        address(liquidityParameters.tokenX).safeApprove(address(traderJoeV2Router), liquidityParameters.amountX);\n        address(liquidityParameters.tokenY).safeApprove(address(traderJoeV2Router), liquidityParameters.amountY);\n\n        (uint256 amountXAdded,uint256 amountYAdded,,,uint256[] memory depositIds, uint256[] memory liquidityMinted) = traderJoeV2Router.addLiquidity(liquidityParameters);\n\n        for (uint256 i; i < depositIds.length; ++i) {\n            bool userHadBin;\n\n            for (int256 j; uint(j) < ownedBins.length; ++j) {\n                if (address(ownedBins[uint(j)].pair) == address(pairInfo.LBPair)\n                && ownedBins[uint(j)].id == depositIds[i]\n                ) {\n                    userHadBin = true;\n                    break;\n                }\n            }\n\n            if (!userHadBin) {\n                getOwnedTraderJoeV2BinsStorage().push(TraderJoeV2Bin(pairInfo.LBPair, uint24(depositIds[i])));\n            }\n        }\n\n        _decreaseExposure(tokenManager, address(liquidityParameters.tokenX), amountXAdded);\n        _decreaseExposure(tokenManager, address(liquidityParameters.tokenY), amountYAdded);\n\n        if (maxBinsPerPrimeAccount() > 0 && getOwnedTraderJoeV2BinsStorage().length > maxBinsPerPrimeAccount()) revert TooManyBins();\n\n        emit AddLiquidityTraderJoeV2(msg.sender, address(pairInfo.LBPair), depositIds, liquidityMinted, tokenX, tokenY, amountXAdded, amountYAdded, block.timestamp);\n    }\n    \n    function removeLiquidityTraderJoeV2(ILBRouter traderJoeV2Router, RemoveLiquidityParameters memory parameters) external nonReentrant onlyOwnerOrInsolvent noBorrowInTheSameBlock {\n        if (!isRouterWhitelisted(address(traderJoeV2Router))) revert TraderJoeV2RouterNotWhitelisted();\n        ILBPair lbPair = ILBPair(traderJoeV2Router.getFactory().getLBPairInformation(parameters.tokenX, parameters.tokenY, parameters.binStep).LBPair);\n        lbPair.approveForAll(address(traderJoeV2Router), true);\n\n        (uint256 amountXReceived, uint256 amountYReceived) = _removeLiquidity(traderJoeV2Router, parameters);\n\n        TraderJoeV2Bin[] storage binsStorage = getOwnedTraderJoeV2BinsStorage();\n\n        for (int256 i; uint(i) < binsStorage.length; i++) {\n            if (address(binsStorage[uint(i)].pair) == address(lbPair)) {\n                TraderJoeV2Bin storage bin = binsStorage[uint(i)];\n                if (bin.pair.balanceOf(address(this), bin.id) == 0) {\n                    binsStorage[uint(i)] = binsStorage[binsStorage.length - 1];\n                    i--;\n                    binsStorage.pop();\n                }\n            }\n        }\n\n         ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        bytes32 tokenX = tokenManager.tokenAddressToSymbol(address(parameters.tokenX));\n        bytes32 tokenY = tokenManager.tokenAddressToSymbol(address(parameters.tokenY));\n\n        _increaseExposure(tokenManager, address(parameters.tokenX), amountXReceived);\n        _increaseExposure(tokenManager, address(parameters.tokenY), amountYReceived);\n\n        emit RemoveLiquidityTraderJoeV2(msg.sender, address(lbPair), parameters.ids, parameters.amounts, tokenX, tokenY, block.timestamp);\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /**\n     * @dev emitted after adding liquidity to TraderJoe V2\n     * @param user the address of user providing liquidity\n     * @param pair TraderJoe V2 pair\n     * @param binIds the ids of bin\n     * @param liquidityMinted amount of liquidity minted per bin\n     * @param firstAsset first asset provided for liquidity\n     * @param secondAsset second asset provided for liquidity\n     * @param firstAmount amount of the first asset used\n     * @param secondAmount amount of the second asset used\n     * @param timestamp time of the transaction\n     **/\n    event AddLiquidityTraderJoeV2(address indexed user, address indexed pair, uint256[] binIds, uint[] liquidityMinted, bytes32 firstAsset, bytes32 secondAsset, uint firstAmount, uint secondAmount, uint256 timestamp);\n\n    /**\n     * @dev emitted after removing liquidity from TraderJoe V2\n     * @param user the address of user removing liquidity\n     * @param pair TraderJoe V2 pair\n     * @param binIds the ids of bin\n     * @param amounts The list of amounts to burn of each id in binIds\n     * @param firstAsset first asset provided for liquidity\n     * @param secondAsset second asset provided for liquidity\n     * @param timestamp time of the transaction\n     **/\n    event RemoveLiquidityTraderJoeV2(address indexed user, address indexed pair, uint256[] binIds, uint[] amounts, bytes32 firstAsset, bytes32 secondAsset, uint256 timestamp);\n\n    /**\n     * @dev emitted after funding account with TraderJoe V2 LB tokens\n     * @param user the address of user removing liquidity\n     * @param pair TraderJoe V2 pair\n     * @param binIds the ids of bin\n     * @param amounts The list of amounts to burn of each id in binIds\n     * @param timestamp time of the transaction\n     **/\n    event FundedLiquidityTraderJoeV2(address indexed user, address indexed pair, uint256[] binIds, uint[] amounts, uint256 timestamp);\n\n    /**\n     * @dev emitted after withdrawing TraderJoe V2 LB tokens\n     * @param user the address of user removing liquidity\n     * @param pair TraderJoe V2 pair\n     * @param binIds the ids of bin\n     * @param amounts The list of amounts to burn of each id in binIds\n     * @param timestamp time of the transaction\n     **/\n    event WithdrawnLiquidityTraderJoeV2(address indexed user, address indexed pair, uint256[] binIds, uint[] amounts, uint256 timestamp);\n\n    error TraderJoeV2PoolNotWhitelisted();\n\n    error TraderJoeV2RouterNotWhitelisted();\n\n    error TooManyBins();\n\n    error TraderJoeV2NoRewardHook();\n}\n"
    },
    "contracts/facets/UniswapV2DEXFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../lib/SolvencyMethods.sol\";\nimport {DiamondStorageLib} from \"../lib/DiamondStorageLib.sol\";\nimport \"../OnlyOwnerOrInsolvent.sol\";\n\n//This path is updated during deployment\nimport \"../lib/arbitrum/DeploymentConstants.sol\";\nimport \"../interfaces/IAssetsExchange.sol\";\n\ncontract UniswapV2DEXFacet is ReentrancyGuardKeccak, SolvencyMethods, OnlyOwnerOrInsolvent {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    function getProtocolID() pure internal virtual returns (bytes32) {\n        return \"\";\n    }\n\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n\n    function bytes32ToString(bytes32 _bytes32) public pure returns (string memory) {\n        uint8 i = 0;\n        while(i < 32 && _bytes32[i] != 0) {\n            i++;\n        }\n        bytes memory bytesArray = new bytes(i);\n        for (i = 0; i < 32 && _bytes32[i] != 0; i++) {\n            bytesArray[i] = _bytes32[i];\n        }\n        return string(bytesArray);\n    }\n\n    /**\n    * Swaps one asset with another\n    * @param _soldAsset asset to be sold\n    * @param _boughtAsset asset to be bought\n    * @param _exactSold exact amount of asset to be sold\n    * @param _minimumBought minimum amount of asset to be bought\n    **/\n    function swapAssets(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) internal remainsSolvent returns (uint256[] memory) {\n        IERC20Metadata soldToken = getERC20TokenInstance(_soldAsset, true);\n        IERC20Metadata boughtToken = getERC20TokenInstance(_boughtAsset, false);\n\n        uint256 initialSellTokenBalance = soldToken.balanceOf(address(this));\n        uint256 initialBuyTokenBalance = boughtToken.balanceOf(address(this));\n\n        require(soldToken.balanceOf(address(this)) >= _exactSold, \"Not enough token to sell\");\n        address(soldToken).safeTransfer(getExchangeIntermediaryContract(), _exactSold);\n\n        IAssetsExchange exchange = IAssetsExchange(getExchangeIntermediaryContract());\n\n        uint256[] memory amounts = exchange.swap(address(soldToken), address(boughtToken), _exactSold, _minimumBought);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        \n        _decreaseExposure(tokenManager, address(soldToken), initialSellTokenBalance - soldToken.balanceOf(address(this)));\n        _increaseExposure(tokenManager, address(boughtToken), boughtToken.balanceOf(address(this)) - initialBuyTokenBalance);\n\n        emit Swap(msg.sender, _soldAsset, _boughtAsset, amounts[0], amounts[amounts.length - 1], block.timestamp);\n\n        return amounts;\n    }\n\n    /**\n    * Adds liquidity\n    **/\n    function addLiquidity(bytes32 _assetA, bytes32 _assetB, uint amountA, uint amountB, uint amountAMin, uint amountBMin) internal remainsSolvent {\n        IERC20Metadata tokenA = getERC20TokenInstance(_assetA, false);\n        IERC20Metadata tokenB = getERC20TokenInstance(_assetB, false);\n\n        require(tokenA.balanceOf(address(this)) >= amountA, \"Not enough tokenA to provide\");\n        require(tokenB.balanceOf(address(this)) >= amountB, \"Not enough tokenB to provide\");\n\n        address(tokenA).safeTransfer(getExchangeIntermediaryContract(), amountA);\n        address(tokenB).safeTransfer(getExchangeIntermediaryContract(), amountB);\n\n        IAssetsExchange exchange = IAssetsExchange(getExchangeIntermediaryContract());\n\n        address lpTokenAddress;\n        uint liquidity;\n\n        (lpTokenAddress, amountA, amountB, liquidity)\n          = exchange.addLiquidity(address(tokenA), address(tokenB), amountA, amountB, amountAMin, amountBMin);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        \n        _decreaseExposure(tokenManager, address(tokenA), amountA);\n        _decreaseExposure(tokenManager, address(tokenB), amountB);\n        _increaseExposure(tokenManager, lpTokenAddress, liquidity);\n\n        emit AddLiquidity(msg.sender, lpTokenAddress, _assetA, _assetB, liquidity, amountA, amountB, block.timestamp);\n    }\n\n    /**\n    * Removes liquidity\n    **/\n    function removeLiquidity(bytes32 _assetA, bytes32 _assetB, uint liquidity, uint amountAMin, uint amountBMin) internal onlyOwnerOrInsolvent{\n        IERC20Metadata tokenA = getERC20TokenInstance(_assetA, true);\n        IERC20Metadata tokenB = getERC20TokenInstance(_assetB, true);\n\n        IAssetsExchange exchange = IAssetsExchange(getExchangeIntermediaryContract());\n\n        address lpTokenAddress = exchange.getPair(address(tokenA), address(tokenB));\n        liquidity = Math.min(liquidity, IERC20(lpTokenAddress).balanceOf(address(this)));\n\n        lpTokenAddress.safeTransfer(getExchangeIntermediaryContract(), liquidity);\n\n        (uint amountA, uint amountB) = exchange.removeLiquidity(address(tokenA), address(tokenB), liquidity, amountAMin, amountBMin);\n\n        ITokenManager tokenManager = DeploymentConstants.getTokenManager();\n        _decreaseExposure(tokenManager, lpTokenAddress, liquidity);\n        _increaseExposure(tokenManager, address(tokenA), amountA);\n        _increaseExposure(tokenManager, address(tokenB), amountB);\n\n        emit RemoveLiquidity(msg.sender, lpTokenAddress, _assetA, _assetB, liquidity, amountA, amountB, block.timestamp);\n    }\n\n    function calculateLpTokenSymbol(bytes32 _assetA, bytes32 _assetB) internal pure returns (bytes32 name) {\n        (bytes32 token0, bytes32 token1) = _assetA < _assetB ? (_assetA, _assetB) : (_assetB, _assetA);\n        name = stringToBytes32(string.concat(\n                bytes32ToString(getProtocolID()),\n                '_',\n                bytes32ToString(token0),\n                '_',\n                bytes32ToString(token1),\n                '_LP'\n            )\n        );\n    }\n\n    /**\n     * Returns address of DeltaPrime intermediary contract of UniswapV2-like exchange\n     **/\n    //TO BE OVERRIDDEN\n    function getExchangeIntermediaryContract() public virtual returns (address) {\n        return address(0);\n    }\n\n    modifier onlyOwner() {\n        DiamondStorageLib.enforceIsContractOwner();\n        _;\n    }\n\n    /**\n     * @dev emitted after a swap of assets\n     * @param user the address of user making the purchase\n     * @param soldAsset sold by the user\n     * @param boughtAsset bought by the user\n     * @param maximumSold maximum to be sold\n     * @param minimumBought minimum to be bought\n     * @param timestamp time of the swap\n     **/\n    event Swap(address indexed user, bytes32 indexed soldAsset, bytes32 indexed boughtAsset, uint256 maximumSold, uint256 minimumBought, uint256 timestamp);\n\n    /**\n     * @dev emitted after providing liquidity\n     * @param user the address of user providing liquidity\n     * @param lpToken the address LP token\n     * @param firstAsset first asset provided for liquidity\n     * @param secondAsset second asset provided for liquidity\n     * @param liquidity amount of liquidity (LP token) added\n     * @param firstAmount amount of the first asset used\n     * @param secondAmount amount of the second asset used\n     * @param timestamp time of the transaction\n     **/\n    event AddLiquidity(address indexed user, address indexed lpToken, bytes32 firstAsset, bytes32 secondAsset, uint liquidity, uint firstAmount, uint secondAmount, uint256 timestamp);\n\n    /**\n     * @dev emitted after removing liquidity\n     * @param user the address of user providing liquidity\n     * @param lpToken the address LP token\n     * @param firstAsset first asset from LP position\n     * @param secondAsset second asset from LP position\n     * @param liquidity amount of liquidity (LP token) removed\n     * @param firstAmount amount of the first asset obtained\n     * @param secondAmount amount of the second asset obtained\n     * @param timestamp time of the transaction\n     **/\n    event RemoveLiquidity(address indexed user, address indexed lpToken, bytes32 firstAsset, bytes32 secondAsset, uint liquidity, uint firstAmount, uint secondAmount, uint256 timestamp);\n}"
    },
    "contracts/helpers/avalanche/PangolinHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../interfaces/IAssetsExchange.sol\";\n\ncontract PangolinHelper {\n    using SafeERC20 for IERC20;\n\n    // PUBLIC FUNCTIONS\n\n    function removeLiquidityPangolin(\n        address token0,\n        address token1,\n        uint256 amount,\n        uint256 minAmount0,\n        uint256 minAmount1\n    ) external {\n        IERC20Metadata tokenA = IERC20Metadata(token0);\n        IERC20Metadata tokenB = IERC20Metadata(token1);\n\n        IAssetsExchange exchange = IAssetsExchange(\n            getExchangeIntermediaryContract()\n        );\n\n        IERC20 lpTokenAddress = IERC20(exchange.getPair(token0, token1));\n        amount = Math.min(amount, lpTokenAddress.balanceOf(address(this)));\n\n        lpTokenAddress.safeTransfer(address(exchange), amount);\n\n        exchange.removeLiquidity(\n            address(tokenA),\n            address(tokenB),\n            amount,\n            minAmount0,\n            minAmount1\n        );\n    }\n\n    /**\n     * Returns address of UniswapV2-like exchange\n     **/\n    function getExchangeIntermediaryContract() public pure returns (address) {\n        return 0xdB5D94B8Ed491B058F3e74D029775A14477cF7fA;\n    }\n}\n"
    },
    "contracts/helpers/avalanche/TraderJoeHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../interfaces/IAssetsExchange.sol\";\n\ncontract TraderJoeHelper {\n    using SafeERC20 for IERC20;\n\n    // PUBLIC FUNCTIONS\n\n    function removeLiquidityTraderJoe(\n        address token0,\n        address token1,\n        uint256 amount,\n        uint256 minAmount0,\n        uint256 minAmount1\n    ) external {\n        IERC20Metadata tokenA = IERC20Metadata(token0);\n        IERC20Metadata tokenB = IERC20Metadata(token1);\n\n        IAssetsExchange exchange = IAssetsExchange(\n            getExchangeIntermediaryContract()\n        );\n\n        IERC20 lpTokenAddress = IERC20(exchange.getPair(token0, token1));\n        amount = Math.min(amount, lpTokenAddress.balanceOf(address(this)));\n\n        lpTokenAddress.safeTransfer(address(exchange), amount);\n\n        exchange.removeLiquidity(\n            address(tokenA),\n            address(tokenB),\n            amount,\n            minAmount0,\n            minAmount1\n        );\n    }\n\n    /**\n     * Returns address of UniswapV2-like exchange\n     **/\n    function getExchangeIntermediaryContract() public pure returns (address) {\n        return 0x4eEcb72b47a32786e08581D6226e95d9AE3bB1Af;\n    }\n}\n"
    },
    "contracts/helpers/avalanche/VectorFinanceHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../interfaces/IVectorFinanceCompounder.sol\";\nimport \"../../interfaces/IVectorFinanceMainStaking.sol\";\nimport \"../../interfaces/IVectorFinanceStaking.sol\";\n\ncontract VectorFinanceHelper {\n    // CONSTANTS\n\n    address private constant VectorMainStaking =\n        0x8B3d9F0017FA369cD8C164D0Cc078bf4cA588aE5;\n\n    // PUBLIC FUNCTIONS\n\n    function vectorUnstakeUSDC(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) public {\n        _unstakeToken(\n            amount,\n            minAmount,\n            0x06f01502327De1c37076Bea4689a7e44279155e9\n        );\n    }\n\n    function vectorUnstakeUSDT(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) public {\n        _unstakeToken(\n            amount,\n            minAmount,\n            0x836648A8cE166Ba7CaFb27F0E6AD21d5C91b7774\n        );\n    }\n\n    function vectorUnstakeWAVAX(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) public {\n        _unstakeToken(\n            amount,\n            minAmount,\n            0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7\n        );\n    }\n\n    function vectorUnstakeSAVAX(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) public {\n        _unstakeToken(\n            amount,\n            minAmount,\n            0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE\n        );\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function _unstakeToken(\n        uint256 amount,\n        uint256 minAmount,\n        address asset\n    ) internal {\n        IVectorFinanceCompounder compounder = _getAssetPoolHelper(asset)\n            .compounder();\n        require(amount > 0, \"Cannot unstake 0 tokens\");\n\n        amount = Math.min(compounder.depositTracking(address(this)), amount);\n\n        compounder.withdraw(amount, minAmount);\n    }\n\n    function _getAssetPoolHelper(\n        address asset\n    ) internal view returns (IVectorFinanceStaking) {\n        IVectorFinanceMainStaking mainStaking = IVectorFinanceMainStaking(\n            VectorMainStaking\n        );\n        return IVectorFinanceStaking(mainStaking.getPoolInfo(asset).helper);\n    }\n}\n"
    },
    "contracts/helpers/avalanche/YieldYakHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\n\nimport \"../../interfaces/facets/avalanche/IYieldYak.sol\";\nimport \"../../interfaces/IWrappedNativeToken.sol\";\n\ncontract YieldYakHelper {\n    // Staking Vaults tokens\n    address private constant YY_AAVE_AVAX =\n        0xaAc0F2d0630d1D09ab2B5A400412a4840B866d95;\n    address private constant YY_PTP_sAVAX =\n        0xb8f531c0d3c53B1760bcb7F57d87762Fd25c4977;\n    address private constant YY_GLP = 0x9f637540149f922145c06e1aa3f38dcDc32Aff5C;\n\n    // Staking Vaults LPs\n    address private constant YY_PNG_AVAX_USDC_LP =\n        0xC0cd58661b68e10b49D3Bec4bC5E44e7A7c20656;\n    address private constant YY_PNG_AVAX_ETH_LP =\n        0xFCD2050E213cC54db2c9c99632AC870574FbC261;\n    address private constant YY_TJ_AVAX_USDC_LP =\n        0xDEf94a13fF31FB6363f1e03bF18fe0F59Db83BBC;\n    address private constant YY_TJ_AVAX_ETH_LP =\n        0x5219558ee591b030E075892acc41334A1694fd8A;\n    address private constant YY_TJ_AVAX_sAVAX_LP =\n        0x22EDe03f1115666CF05a4bAfafaEe8F43D42cD56;\n\n    // Tokens\n    address private constant SAVAX_TOKEN =\n        0x2b2C81e08f1Af8835a78Bb2A90AE924ACE0eA4bE;\n    address private constant AVAX_TOKEN =\n        0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n    address private constant GLP_TOKEN =\n        0x9e295B5B976a184B14aD8cd72413aD846C299660;\n    // LPs\n    address private constant PNG_AVAX_USDC_LP =\n        0x0e0100Ab771E9288e0Aa97e11557E6654C3a9665;\n    address private constant PNG_AVAX_ETH_LP =\n        0x7c05d54fc5CB6e4Ad87c6f5db3b807C94bB89c52;\n\n    address private constant TJ_AVAX_USDC_LP =\n        0xf4003F4efBE8691B60249E6afbD307aBE7758adb;\n    address private constant TJ_AVAX_ETH_LP =\n        0xFE15c2695F1F920da45C30AAE47d11dE51007AF9;\n    address private constant TJ_AVAX_sAVAX_LP =\n        0x4b946c91C2B1a7d7C40FB3C130CdfBaf8389094d;\n\n    // PUBLIC FUNCTIONS\n\n    function unstakeAVAXYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        IYieldYak yakStakingContract = IYieldYak(YY_AAVE_AVAX);\n\n        amount = Math.min(yakStakingContract.balanceOf(address(this)), amount);\n\n        yakStakingContract.withdraw(amount);\n\n        require(address(this).balance >= minAmount, \"too little received\");\n\n        IWrappedNativeToken(AVAX_TOKEN).deposit{value: address(this).balance}();\n    }\n\n    function unstakeSAVAXYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        _unstakeTokenYY(SAVAX_TOKEN, YY_PTP_sAVAX, amount, minAmount);\n    }\n\n    function unstakeGLPYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        _unstakeTokenYY(GLP_TOKEN, YY_GLP, amount, minAmount);\n    }\n\n    function unstakePNGAVAXUSDCYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        _unstakeTokenYY(PNG_AVAX_USDC_LP, YY_PNG_AVAX_USDC_LP, amount, minAmount);\n    }\n\n    function unstakePNGAVAXETHYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        _unstakeTokenYY(PNG_AVAX_ETH_LP, YY_PNG_AVAX_ETH_LP, amount, minAmount);\n    }\n\n    function unstakeTJAVAXUSDCYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        _unstakeTokenYY(TJ_AVAX_USDC_LP, YY_TJ_AVAX_USDC_LP, amount, minAmount);\n    }\n\n    function unstakeTJAVAXETHYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        _unstakeTokenYY(TJ_AVAX_ETH_LP, YY_TJ_AVAX_ETH_LP, amount, minAmount);\n    }\n\n    function unstakeTJAVAXSAVAXYak(\n        address,\n        address,\n        uint256 amount,\n        uint256 minAmount,\n        uint256\n    ) external {\n        _unstakeTokenYY(TJ_AVAX_sAVAX_LP, YY_TJ_AVAX_sAVAX_LP, amount, minAmount);\n    }\n\n    // INTERNAL FUNCTIONS\n\n    function _unstakeTokenYY(\n        address tokenAddress,\n        address vaultAddress,\n        uint256 amount,\n        uint256 minAmount\n    ) private {\n        IYieldYak vaultContract = IYieldYak(vaultAddress);\n        IERC20Metadata depositToken = IERC20Metadata(tokenAddress);\n        uint256 initialDepositTokenBalance = depositToken.balanceOf(address(this));\n        amount = Math.min(vaultContract.balanceOf(address(this)), amount);\n\n        vaultContract.withdraw(amount);\n\n        uint256 unstaked = depositToken.balanceOf(address(this)) -\n            initialDepositTokenBalance;\n        require(unstaked >= minAmount, \"too little received\");\n    }\n}\n"
    },
    "contracts/integrations/arbitrum/SushiSwapIntermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 48601850463d2b56407c5b1e6a596b5a87c4e428;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2Intermediary.sol\";\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\n/**\n * @title SushiSwapIntermediary\n * @dev Contract allows user to swap ERC20 tokens on DEX\n * This implementation uses the SushiSwap DEX\n */\ncontract SushiSwapIntermediary is UniswapV2Intermediary {\n    function getNativeTokenAddress() override internal pure returns (address) {\n        return DeploymentConstants.getNativeToken();\n    }\n}\n"
    },
    "contracts/integrations/avalanche/PangolinIntermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2Intermediary.sol\";\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\n/**\n * @title PangolinIntermediary\n * @dev Contract allows user to swap ERC20 tokens on DEX\n * This implementation uses the Pangolin DEX\n */\ncontract PangolinIntermediary is UniswapV2Intermediary {\n\n    function getNativeTokenAddress() override internal pure returns (address) {\n        return DeploymentConstants.getNativeToken();\n    }\n}"
    },
    "contracts/integrations/avalanche/TraderJoeIntermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2Intermediary.sol\";\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\n/**\n * @title TraderJoeIntermediary\n * @dev Contract allows user to swap ERC20 tokens on DEX\n * This implementation uses the TraderJoe DEX\n */\ncontract TraderJoeIntermediary is UniswapV2Intermediary {\n\n    function getNativeTokenAddress() override internal pure returns (address) {\n        return DeploymentConstants.getNativeToken();\n    }\n}"
    },
    "contracts/integrations/celo/UbeswapIntermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"../UniswapV2Intermediary.sol\";\nimport \"../../lib/arbitrum/DeploymentConstants.sol\";\n\n/**\n * @title UbeswapIntermediary\n * @dev Contract allows user to swap ERC20 tokens on DEX\n * This implementation uses the Ubeswap DEX\n */\ncontract UbeswapIntermediary is UniswapV2Intermediary {\n\n  /**\n   * Returns a path containing tokens' addresses\n   * @dev _token ERC20 token's address\n   **/\n  function getPath(address _token1, address _token2) internal override pure returns (address[] memory) {\n    address[] memory path;\n    path = new address[](2);\n    path[0] = _token1;\n    path[1] = _token2;\n\n    return path;\n  }\n\n  function getNativeTokenAddress() override internal pure returns (address) {\n    return DeploymentConstants.getNativeToken();\n  }\n}"
    },
    "contracts/integrations/UniswapV2Intermediary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol\";\nimport \"@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"../ReentrancyGuardKeccak.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/IAssetsExchange.sol\";\nimport \"../TokenList.sol\";\nimport \"../interfaces/ITokenManager.sol\";\n\n/**\n * @title UniswapV2Intermediary\n * @dev Contract allows user to swap ERC20 tokens on DEX\n * This implementation supports UniswapV2-like DEXs\n */\ncontract UniswapV2Intermediary is TokenListOwnableUpgreadable, IAssetsExchange, ReentrancyGuardKeccak {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    /* ========= STATE VARIABLES ========= */\n    IUniswapV2Router01 router;\n    IUniswapV2Factory factory;\n    ITokenManager tokenManager;\n\n    function initialize(address _router, address _tokenManager, address[] memory _whitelistedTokens) external initializer {\n        tokenManager = ITokenManager(_tokenManager);\n        router = IUniswapV2Router01(_router);\n        factory = IUniswapV2Factory(router.factory());\n\n        __TokenList_init(_whitelistedTokens);\n    }\n\n    /*\n     * Swaps selected ERC20 token with other ERC20 token\n     * @param soldToken_ sold ERC20 token's address\n     * @param boughtToken_ bought ERC20 token's address\n     * @param _exactSold exact amount of ERC20 token to be sold\n     * @param _minimumBought minimum amount of ERC20 token to be bought\n     **/\n    function swap(address _soldToken, address _boughtToken, uint256 _exactSold, uint256 _minimumBought) external override nonReentrant returns (uint256[] memory amounts) {\n        require(_exactSold > 0, \"Amount of tokens to sell has to be greater than 0\");\n\n        _soldToken.safeApprove(address(router), 0);\n        _soldToken.safeApprove(address(router), _exactSold);\n\n        require(isTokenWhitelisted[_boughtToken], 'Trying to buy unsupported token');\n\n        if (_minimumBought > 0) {\n            require(_exactSold >= getMinimumTokensNeeded(_minimumBought, _soldToken, _boughtToken), \"Not enough funds were provided\");\n        }\n\n        amounts = router.swapExactTokensForTokens(_exactSold, _minimumBought, getPath(_soldToken, _boughtToken), msg.sender, block.timestamp);\n\n        uint256 residualBalance = IERC20Metadata(_soldToken).balanceOf(address(this));\n\n        if (residualBalance > 0) {\n            _soldToken.safeTransfer(msg.sender, residualBalance);\n        }\n\n        return amounts;\n    }\n\n\n    /*\n     * addLiquidity selected ERC20 tokens\n     **/\n    function addLiquidity(address tokenA, address tokenB, uint amountA, uint amountB, uint amountAMin, uint amountBMin) external override nonReentrant returns (address, uint, uint, uint) {\n        require(amountA > 0, \"amountADesired has to be greater than 0\");\n        require(amountB > 0, \"amountBDesired to sell has to be greater than 0\");\n        require(amountAMin > 0, \"amountAMin has to be greater than 0\");\n        require(amountBMin > 0, \"amountBMin has to be greater than 0\");\n\n        tokenA.safeApprove(address(router), amountA);\n        tokenB.safeApprove(address(router), amountB);\n\n        address lpTokenAddress = getPair(tokenA, tokenB);\n\n        require(isTokenWhitelisted[tokenA], 'Trying to LP unsupported token');\n        require(isTokenWhitelisted[tokenB], 'Trying to LP unsupported token');\n        require(tokenManager.isTokenAssetActive(lpTokenAddress), 'Trying to add unsupported LP token');\n\n        uint liquidity;\n        (amountA, amountB, liquidity) =\n           router.addLiquidity(tokenA, tokenB, amountA, amountB, amountAMin, amountBMin, address(this), block.timestamp);\n\n        lpTokenAddress.safeTransfer(msg.sender, IERC20Metadata(lpTokenAddress).balanceOf(address(this)));\n        if (IERC20Metadata(tokenA).balanceOf(address(this)) > 0) {\n            tokenA.safeTransfer(msg.sender, IERC20Metadata(tokenA).balanceOf(address(this)));\n        }\n        if ( IERC20Metadata(tokenB).balanceOf(address(this)) > 0) {\n            tokenB.safeTransfer(msg.sender, IERC20Metadata(tokenB).balanceOf(address(this)));\n        }\n        tokenA.safeApprove(address(router), 0);\n        tokenB.safeApprove(address(router), 0);\n\n        return (lpTokenAddress, amountA, amountB, liquidity);\n    }\n\n\n    /*\n     *  removeLiquidity selected ERC20 tokens\n     **/\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountA, uint amountB) external override nonReentrant returns (uint, uint) {\n        require(amountA > 0, \"amountA has to be greater than 0\");\n        require(amountB > 0, \"amountB has to be greater than 0\");\n\n        address lpTokenAddress = getPair(tokenA, tokenB);\n\n        lpTokenAddress.safeApprove(address(router), liquidity);\n\n        require(isTokenWhitelisted[tokenA], 'Trying to remove LP of unsupported token');\n        require(isTokenWhitelisted[tokenB], 'Trying to remove LP of unsupported token');\n        //TODO: handle paused LP tokens\n        require(tokenManager.isTokenAssetActive(lpTokenAddress), 'Trying to remove unsupported LP token');\n\n        (amountA, amountB) =\n         router.removeLiquidity(tokenA, tokenB, liquidity, amountA, amountB, address(this), block.timestamp);\n\n        lpTokenAddress.safeTransfer(msg.sender, IERC20Metadata(lpTokenAddress).balanceOf(address(this)));\n        tokenA.safeTransfer(msg.sender, IERC20Metadata(tokenA).balanceOf(address(this)));\n        tokenB.safeTransfer(msg.sender, IERC20Metadata(tokenB).balanceOf(address(this)));\n\n        return (amountA, amountB);\n    }\n\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the minimum _soldToken amount that is required to be sold to receive _exactAmountOut of a _boughtToken.\n     * Can revert due to insufficient liquidity\n     **/\n    function getMinimumTokensNeeded(uint256 _exactAmountOut, address _soldToken, address _boughtToken) public view override returns (uint256) {\n        address[] memory path = getPath(_soldToken, _boughtToken);\n\n        (bool success, bytes memory result) = address(router).staticcall(\n            abi.encodeWithSignature(\"getAmountsIn(uint256,address[])\", _exactAmountOut, path)\n        );\n\n        require(success, \"Error when calculating amounts needed\");\n\n        uint256[] memory amounts = abi.decode(result, (uint256[]));\n\n        return amounts[0];\n    }\n\n    /**\n     * Returns the maximum _boughtToken amount that will be obtained in the event of selling _amountIn of _soldToken token.\n     **/\n    function getMaximumTokensReceived(uint256 _amountIn, address _soldToken, address _boughtToken) public view override returns (uint256) {\n        address[] memory path = getPath(_soldToken, _boughtToken);\n\n        return router.getAmountsOut(_amountIn, path)[1];\n    }\n\n    /**\n     * Returns a path containing tokens' addresses\n     * @param _token1 ERC20 token's address\n     * @param _token2 ERC20 token's address\n     **/\n    function getPath(address _token1, address _token2) internal virtual view returns (address[] memory) {\n        address[] memory path;\n\n        if (_token1 != getNativeTokenAddress() && _token2 != getNativeTokenAddress()) {\n            path = new address[](3);\n            path[0] = _token1;\n            path[1] = getNativeTokenAddress();\n            path[2] = _token2;\n        } else {\n            path = new address[](2);\n            path[0] = _token1;\n            path[1] = _token2;\n        }\n\n        return path;\n    }\n\n    /**\n     * Returns an address of LP token\n     * @param _token1 ERC20 token's address\n     * @param _token2 ERC20 token's address\n     **/\n    function getPair(address _token1, address _token2) public virtual view returns (address) {\n        return factory.getPair(_token1, _token2);\n    }\n\n    function getNativeTokenAddress() virtual internal view returns (address) {\n        //address of WETH9 on Ethereum network. Must be overriden in implementations on other chains\n        return 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    }\n}"
    },
    "contracts/interfaces/arbitrum/IConvexPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ninterface IConvexPool {\n    function deposit(uint256 _pid, uint256 _amount) external returns(bool);\n\n    struct DepositDetails {\n        uint256 crvLpTokenAmount;\n        uint256 depositPoolId;\n        address depositPoolAddress;\n        address crvLpTokenAddress;\n        bytes32 crvLpTokenIdentifier;\n        address cvxPoolLPTokenAddress;\n        bytes32 cvxPoolIdentifier;\n    }\n\n    struct WithdrawalDetails {\n        uint256 receiptTokenAmount;\n        address crvLpTokenAddress;\n        bytes32 crvLpTokenIdentifier;\n        address cvxPoolLPTokenAddress;\n        bytes32 cvxPoolIdentifier;\n    }\n}"
    },
    "contracts/interfaces/arbitrum/IConvexRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ninterface IConvexRewarder {\n    function withdraw(uint256 _amount, bool _claim) external returns(bool);\n    function balanceOf(address account) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/arbitrum/IMasterPenpie.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ninterface IMasterPenpie {\n    function allPendingTokens(\n        address _stakingToken,\n        address _user\n    )\n        external\n        view\n        returns (\n            uint256 pendingPenpie,\n            address[] memory bonusTokenAddresses,\n            string[] memory bonusTokenSymbols,\n            uint256[] memory pendingBonusRewards\n        );\n\n    function multiclaim(address[] calldata _stakingTokens) external;\n}\n"
    },
    "contracts/interfaces/arbitrum/IPendleDepositHelper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ninterface IPendleDepositHelper {\n    function depositMarket(address _market, uint256 _amount) external;\n\n    function withdrawMarketWithClaim(\n        address _market,\n        uint256 _amount,\n        bool _doClaim\n    ) external;\n}\n"
    },
    "contracts/interfaces/arbitrum/IPendleRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ninterface IPendleRouter {\n    struct ApproxParams {\n        uint256 guessMin;\n        uint256 guessMax;\n        uint256 guessOffchain; // pass 0 in to skip this variable\n        uint256 maxIteration; // every iteration, the diff between guessMin and guessMax will be divided by 2\n        uint256 eps; // the max eps between the returned result & the correct result, base 1e18. Normally this number will be set\n        // to 1e15 (1e18/1000 = 0.1%)\n    }\n\n    struct SwapData {\n        SwapType swapType;\n        address extRouter;\n        bytes extCalldata;\n        bool needScale;\n    }\n\n    enum SwapType {\n        NONE,\n        KYBERSWAP,\n        ONE_INCH,\n        // ETH_WETH not used in Aggregator\n        ETH_WETH\n    }\n\n    struct TokenInput {\n        // Token/Sy data\n        address tokenIn;\n        uint256 netTokenIn;\n        address tokenMintSy;\n        // aggregator data\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct TokenOutput {\n        // Token/Sy data\n        address tokenOut;\n        uint256 minTokenOut;\n        address tokenRedeemSy;\n        // aggregator data\n        address pendleSwap;\n        SwapData swapData;\n    }\n\n    struct LimitOrderData {\n        address limitRouter;\n        uint256 epsSkipMarket; // only used for swap operations, will be ignored otherwise\n        FillOrderParams[] normalFills;\n        FillOrderParams[] flashFills;\n        bytes optData;\n    }\n\n    struct FillOrderParams {\n        Order order;\n        bytes signature;\n        uint256 makingAmount;\n    }\n\n    struct Order {\n        uint256 salt;\n        uint256 expiry;\n        uint256 nonce;\n        OrderType orderType;\n        address token;\n        address YT;\n        address maker;\n        address receiver;\n        uint256 makingAmount;\n        uint256 lnImpliedRate;\n        uint256 failSafeRate;\n        bytes permit;\n    }\n\n    enum OrderType {\n        SY_FOR_PT,\n        PT_FOR_SY,\n        SY_FOR_YT,\n        YT_FOR_SY\n    }\n\n    function addLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 minLpOut,\n        ApproxParams calldata guessPtReceivedFromSy,\n        TokenInput calldata input,\n        LimitOrderData calldata limit\n    ) external payable returns (uint256 netLpOut, uint256 netSyFee, uint256 netSyInterm);\n\n    function removeLiquiditySingleToken(\n        address receiver,\n        address market,\n        uint256 netLpToRemove,\n        TokenOutput calldata output,\n        LimitOrderData calldata limit\n    ) external returns (uint256 netTokenOut, uint256 netSyFee, uint256 netSyInterm);\n}\n"
    },
    "contracts/interfaces/balancer-v2/IAsset.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @dev This is an empty interface used to represent either ERC20-conforming token contracts or ETH (using the zero\n * address sentinel value). We're just relying on the fact that `interface` can be used to declare new address-like\n * types.\n *\n * This concept is unrelated to a Pool's Asset Managers.\n */\ninterface IAsset {\n    // solhint-disable-previous-line no-empty-blocks\n}"
    },
    "contracts/interfaces/balancer-v2/IBalancerPseudoMinter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\ninterface IBalancerPseudoMinter {\n\n    function mint(address _gauge_addr) external;\n}\n"
    },
    "contracts/interfaces/balancer-v2/IBalancerV2Gauge.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBalancerV2Gauge is IERC20 {\n\n    function deposit(uint256 _value) external;\n\n    function withdraw(uint256 _value) external;\n\n    function claim_rewards() external;\n\n    function bal_token() external view returns (address);\n\n    function bal_pseudo_minter() external view returns (address);\n\n    function claimable_reward(address _user, address _reward_token) external view returns (uint256);\n}"
    },
    "contracts/interfaces/balancer-v2/IBalancerV2Vault.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma experimental ABIEncoderV2;\n\nimport \"./IAsset.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n//import \"../../lib/WETH9.sol\";\n\npragma solidity >=0.7.0 <0.9.0;\n\n/**\n * @dev Full external interface for the Vault core contract - no external or public methods exist in the contract that\n * don't override one of these declarations.\n */\ninterface IVault {\n\n    // Pools\n    //\n    // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n    // functionality:\n    //\n    //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n    // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n    // which increase with the number of registered tokens.\n    //\n    //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n    // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n    // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n    // independent of the number of registered tokens.\n    //\n    //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n    // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n    enum PoolSpecialization { GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN }\n\n\n    /**\n     * @dev Returns a Pool's contract address and specialization setting.\n     */\n    function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n\n\n    /**\n     * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n    function getPoolTokens(bytes32 poolId)\n    external\n    view\n    returns (\n        IERC20[] memory tokens,\n        uint256[] memory balances,\n        uint256 lastChangeBlock\n    );\n\n    /**\n     * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function joinPool(\n        bytes32 poolId,\n        address sender,\n        address recipient,\n        JoinPoolRequest memory request\n    ) external payable;\n\n    struct JoinPoolRequest {\n        IAsset[] assets;\n        uint256[] maxAmountsIn;\n        bytes userData;\n        bool fromInternalBalance;\n    }\n\n    /**\n     * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n    function exitPool(\n        bytes32 poolId,\n        address sender,\n        address payable recipient,\n        ExitPoolRequest memory request\n    ) external;\n\n    struct ExitPoolRequest {\n        IAsset[] assets;\n        uint256[] minAmountsOut;\n        bytes userData;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n    event PoolBalanceChanged(\n        bytes32 indexed poolId,\n        address indexed liquidityProvider,\n        IERC20[] tokens,\n        int256[] deltas,\n        uint256[] protocolFeeAmounts\n    );\n\n    enum PoolBalanceChangeKind { JOIN, EXIT }\n\n    // Swaps\n    //\n    // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n    // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n    // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n    //\n    // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n    // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n    // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n    // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n    // individual swaps.\n    //\n    // There are two swap kinds:\n    //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n    // `onSwap` hook) the amount of tokens out (to send to the recipient).\n    //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n    // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n    //\n    // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n    // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n    // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n    // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n    // the final intended token.\n    //\n    // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n    // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n    // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n    // much less gas than they would otherwise.\n    //\n    // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n    // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n    // updating the Pool's internal accounting).\n    //\n    // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n    // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n    // minimum amount of tokens to receive (by passing a negative value) is specified.\n    //\n    // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n    // this point in time (e.g. if the transaction failed to be included in a block promptly).\n    //\n    // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n    // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n    // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n    // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n    //\n    // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n    enum SwapKind { GIVEN_IN, GIVEN_OUT }\n\n    /**\n     * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n    function swap(\n        SingleSwap memory singleSwap,\n        FundManagement memory funds,\n        uint256 limit,\n        uint256 deadline\n    ) external payable returns (uint256);\n\n    /**\n     * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct SingleSwap {\n        bytes32 poolId;\n        SwapKind kind;\n        IAsset assetIn;\n        IAsset assetOut;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n    function batchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds,\n        int256[] memory limits,\n        uint256 deadline\n    ) external payable returns (int256[] memory);\n\n    /**\n     * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n    struct BatchSwapStep {\n        bytes32 poolId;\n        uint256 assetInIndex;\n        uint256 assetOutIndex;\n        uint256 amount;\n        bytes userData;\n    }\n\n    /**\n     * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n    event Swap(\n        bytes32 indexed poolId,\n        IERC20 indexed tokenIn,\n        IERC20 indexed tokenOut,\n        uint256 amountIn,\n        uint256 amountOut\n    );\n\n    /**\n     * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n    struct FundManagement {\n        address sender;\n        bool fromInternalBalance;\n        address payable recipient;\n        bool toInternalBalance;\n    }\n\n    /**\n     * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n    function queryBatchSwap(\n        SwapKind kind,\n        BatchSwapStep[] memory swaps,\n        IAsset[] memory assets,\n        FundManagement memory funds\n    ) external returns (int256[] memory assetDeltas);\n\n\n    /**\n     * @dev Returns the Vault's WETH instance.\n     */\n//    function WETH() external view returns (WETH9);\n    // solhint-disable-previous-line func-name-mixedcase\n}"
    },
    "contracts/interfaces/facets/arbitrum/IBeefyFinanceArbitrumFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IBeefyFinanceArbitrumFacet {\n    function stakeSushiDpxEthLpBeefy(uint256 amount) external;\n\n    function stakeGmxBeefy(uint256 amount) external;\n\n    function unstakeSushiDpxEthLpBeefy(uint256 amount) external;\n\n    function unstakeGmxBeefy(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/IGLPRewarder.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IGLPRewarder {\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns(uint256);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns(uint256);\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/ILevelFinance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./IRewarder.sol\";\n\ninterface ILevelFinance {\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    function userInfo(\n        uint256 pid,\n        address user\n    ) external view returns (UserInfo memory);\n\n    function pendingReward(\n        uint256 pid,\n        address user\n    ) external view returns (uint256 pending);\n\n    function rewarder(uint256 pid) external view returns (IRewarder);\n\n    function deposit(\n        uint256 pid,\n        uint256 amount,\n        address to\n    ) external;\n\n    function withdraw(\n        uint256 pid,\n        uint256 amount,\n        address to\n    ) external;\n\n    function addLiquidity(\n        uint256 pid,\n        address assetToken,\n        uint256 assetAmount,\n        uint256 minLpAmount,\n        address to\n    ) external;\n\n    function addLiquidityETH(\n        uint256 pid,\n        uint256 minLpAmount,\n        address to\n    ) external payable;\n\n    function removeLiquidity(\n        uint256 pid,\n        uint256 lpAmount,\n        address toToken,\n        uint256 minOut,\n        address to\n    ) external;\n\n    function removeLiquidityETH(\n        uint256 pid,\n        uint256 lpAmount,\n        uint256 minOut,\n        address to\n    ) external;\n\n    function harvest(uint256 pid, address to) external;\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/ILevelFinanceFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ILevelFinanceFacet {\n    function levelStakeEthSnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeEthMze(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeEthJnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeBtcSnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeBtcMze(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeBtcJnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeUsdtSnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeUsdtMze(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeUsdtJnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeUsdcSnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeUsdcMze(uint256 amount, uint256 minLpAmount) external;\n\n    function levelStakeUsdcJnr(uint256 amount, uint256 minLpAmount) external;\n\n    function levelUnstakeEthSnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeEthMze(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeEthJnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeBtcSnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeBtcMze(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeBtcJnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeUsdtSnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeUsdtMze(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeUsdtJnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeUsdcSnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeUsdcMze(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelUnstakeUsdcJnr(uint256 lpAmount, uint256 minAmount) external;\n\n    function levelSnrBalance() external view returns (uint256 _stakedBalance);\n\n    function levelMzeBalance() external view returns (uint256 _stakedBalance);\n\n    function levelJnrBalance() external view returns (uint256 _stakedBalance);\n\n    function depositLLPAndStake(uint256 pid, uint256 amount) external;\n\n    function unstakeAndWithdrawLLP(uint256 pid, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/ILevelOrderManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\n\ninterface ILevelOrderManager {\n    function placeAddLiquidityOrder(\n        address _tranche,\n        address _tokenIn,\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint64 _expiresAt,\n        address _to\n    ) external payable;\n\n    function placeRemoveLiquidityOrder(\n        address _tranche,\n        address _tokenOut,\n        uint256 _amountIn,\n        uint256 _minAmountOut,\n        uint64 _expiresAt,\n        address _to\n    ) external payable;\n}"
    },
    "contracts/interfaces/facets/arbitrum/ILTIPFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ILTIPFacet {\n    function getLTIPEligibleTVL() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/IMiniChef.sol": {
      "content": "pragma solidity ^0.8.27;\n\nimport \"./IRewarder.sol\";\n\ninterface IMiniChef {\n    struct UserInfo {\n        uint256 amount;\n        int256 rewardDebt;\n    }\n\n    function deposit(uint256 pid, uint256 amount, address to) external;\n\n    function withdraw(uint256 pid, uint256 amount, address to) external;\n\n    function harvest(uint256 pid, address to) external;\n\n    function withdrawAndHarvest(uint256 pid, uint256 amount, address to) external;\n\n    function pendingSushi(uint256 pid, address user) external view returns (uint256);\n\n    function userInfo(uint256 pid, address user) external view returns (UserInfo memory);\n\n    function rewarder(uint256 pid) external view returns (IRewarder);\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/IPenpieFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\nimport \"../../arbitrum/IPendleRouter.sol\";\n\ninterface IPenpieFacet {\n    function depositToPendleAndStakeInPenpie(\n        bytes32 asset,\n        uint256 amount,\n        address market,\n        uint256 minLpOut,\n        IPendleRouter.ApproxParams memory guessPtReceivedFromSy,\n        IPendleRouter.TokenInput memory input,\n        IPendleRouter.LimitOrderData memory limit\n    ) external;\n\n    function unstakeFromPenpieAndWithdrawFromPendle(\n        bytes32 asset,\n        uint256 amount,\n        address market,\n        uint256 minOut,\n        IPendleRouter.TokenOutput memory output,\n        IPendleRouter.LimitOrderData memory limit\n    ) external returns (uint256);\n\n    function depositPendleLPAndStakeInPenpie(\n        address market,\n        uint256 amount\n    ) external;\n\n    function unstakeFromPenpieAndWithdrawPendleLP(\n        address market,\n        uint256 amount\n    ) external;\n\n    function pendingRewards(\n        address market\n    ) external view returns (uint256, address[] memory, uint256[] memory);\n\n    function claimRewards(address market) external;\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/IRewarder.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IRewarder {\n    function pendingTokens(uint256 pid, address user, uint256 sushiAmount) external view returns (address[] memory, uint256[] memory);\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/IRewardRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.27;\n\ninterface IRewardRouterV2 {\n    function claimFees() external;\n    function feeGlpTracker() external view returns (address);\n}"
    },
    "contracts/interfaces/facets/arbitrum/IRewardTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.27;\n\ninterface IRewardTracker {\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\n    function stakedAmounts(address _account) external view returns (uint256);\n    function updateRewards() external;\n    function stake(address _depositToken, uint256 _amount) external;\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\n    function unstake(address _depositToken, uint256 _amount) external;\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\n    function tokensPerInterval() external view returns (uint256);\n    function claim(address _receiver) external returns (uint256);\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n    function averageStakedAmounts(address _account) external view returns (uint256);\n    function cumulativeRewards(address _account) external view returns (uint256);\n}"
    },
    "contracts/interfaces/facets/arbitrum/ISushiSwapDEXFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ISushiSwapDEXFacet {\n    function swapSushiSwap(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) external returns (uint256[] memory);\n\n    function addLiquiditySushiSwap(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) external;\n\n    function removeLiquiditySushiSwap(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) external;\n}\n"
    },
    "contracts/interfaces/facets/arbitrum/ISushiSwapFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ISushiSwapFacet {\n    function sushiStakeDpxEthLp(uint256 amount) external;\n\n    function sushiUnstakeDpxEthLp(uint256 amount, uint256 minAmount) external;\n\n    function sushiDpxEthLpBalance() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IBalancerV2Facet.sol": {
      "content": "pragma solidity ^0.8.27;\n\nimport \"../../balancer-v2/IBalancerV2Vault.sol\";\n\ninterface IBalancerV2Facet {\n    struct UnstakeRequest {\n        bytes32 poolId;\n        address unstakedToken;\n        uint256 unstakedAmount;\n        uint256 bptAmount;\n    }\n\n    struct StakeRequest {\n        bytes32 poolId;\n        address[] stakedTokens;\n        uint256[] stakedAmounts;\n        uint256 minBptAmount;\n    }\n\n    function joinPoolAndStakeBalancerV2(StakeRequest memory request) external;\n\n    function stakeBalancerV2(bytes32 poolId, uint256 amount) external;\n\n    function unstakeAndExitPoolBalancerV2(UnstakeRequest memory request) external;\n\n    function unstakeBalancerV2(bytes32 poolId, uint256 amount) external;\n\n    function claimRewardsBalancerV2(bytes32 poolId) external;\n\n    function balancerGgAvaxBalance() external view returns (uint256);\n\n    function balancerYyAvaxBalance() external view returns (uint256);\n\n    function balancerSAvaxBalance() external view returns (uint256);\n\n    event StakeBalancerV2(address indexed user, bytes32[] assets, address indexed vault, uint256[] depositTokenAmounts, uint256 receiptTokenAmount, uint256 timestamp);\n\n    event BptUnstaked(address indexed user, bytes32 asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    event UnstakeBalancerV2(address indexed user, bytes32[] assets, address indexed vault, uint256[] depositTokenAmounts, uint256 receiptTokenAmount, uint256 timestamp);\n\n    event BptStaked(address indexed user, bytes32 asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IBeefyFinanceFacet.sol": {
      "content": "interface IBeefyFinanceFacet {\n    function stakePngUsdcAvaxLpBeefy(uint256 amount) external;\n\n    function stakePngUsdceAvaxLpBeefy(uint256 amount) external;\n\n    function stakeTjUsdcAvaxLpBeefy(uint256 amount) external;\n\n    function unstakePngUsdcAvaxLpBeefy(uint256 amount) external;\n\n    function unstakePngUsdceAvaxLpBeefy(uint256 amount) external;\n\n    function unstakeTjUsdcAvaxLpBeefy(uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/ICaiFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\ninterface ICaiFacet {\n    function mintCai(\n        bytes4 selector,\n        bytes memory data,\n        address fromToken,\n        uint256 fromAmount,\n        uint256 minOut\n    ) external;\n\n    function burnCai(\n        bytes4 selector,\n        bytes memory data,\n        uint256 shares,\n        address toToken,\n        uint256 minOut\n    ) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/ICurveFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ICurveFacet {\n    function stakeCurve(uint256[5] memory amounts) external;\n\n    function unstakeCurve(uint256 amount, uint256[5] memory min_amounts) external;\n\n    function unstakeOneTokenCurve(uint256 i, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IGLPFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IGLPFacet {\n    function claimGLpFees() external;\n\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns(uint256);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut) external returns(uint256);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IGLPRewarder.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IGLPRewarder {\n    function mintAndStakeGlp(address _token, uint256 _amount, uint256 _minUsdg, uint256 _minGlp) external returns(uint256);\n\n    function unstakeAndRedeemGlp(address _tokenOut, uint256 _glpAmount, uint256 _minOut, address _receiver) external returns(uint256);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IGMDFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IGMDFacet {\n    function gmdStakeUSDC(uint256 amountStaked, uint256 minSharesOut) external;\n    function gmdStakeAVAX(uint256 amountStaked, uint256 minSharesOut) external;\n    function gmdStakeBTCb(uint256 amountStaked, uint256 minSharesOut) external;\n    function gmdStakeWETHe(uint256 amountStaked, uint256 minSharesOut) external;\n\n    function gmdUnstakeUSDC(uint256 amountUnstaked, uint256 minTokenOut) external;\n    function gmdUnstakeAVAX(uint256 amountUnstaked, uint256 minTokenOut) external;\n    function gmdUnstakeBTCb(uint256 amountUnstaked, uint256 minTokenOut) external;\n    function gmdUnstakeWETHe(uint256 amountUnstaked, uint256 minTokenOut) external;\n\n    struct StakingDetails {\n        address asset;\n        address receiptToken;\n        bytes32 symbol;\n        bytes32 identifier;\n        uint256 amountStaked;\n        uint256 minSharesOut;\n        uint256 pid;\n    }\n\n    struct UnstakingDetails {\n        address asset;\n        address receiptToken;\n        bytes32 symbol;\n        bytes32 identifier;\n        uint256 amountUnstaked;\n        uint256 minTokenOut;\n        uint256 pid;\n    }\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IGogoPoolFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IGogoPoolFacet {\n    function swapToGgAvax(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IPangolinDEXFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IPangolinDEXFacet {\n    function swapPangolin(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) external returns (uint256[] memory);\n\n    function addLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) external;\n\n    function removeLiquidityPangolin(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) external;\n\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IParaSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\ninterface IParaSwapFacet {\n    function paraSwapV2(\n        bytes4 selector,\n        bytes memory data,\n        address fromToken,\n        uint256 fromAmount,\n        address toToken,\n        uint256 minOut\n    ) external;\n\n    function paraSwapBeforeLiquidation(\n        bytes4 selector,\n        bytes memory data,\n        address fromToken,\n        uint256 fromAmount,\n        address toToken,\n        uint256 minOut\n    ) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IRecoveryFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IRecoveryFacet {\n    function emergencyWithdraw(bytes32 asset) external returns (uint256 _amount);\n\n    function notifyRefund(address token, uint256 amount) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IRewarder {\n    function rewardTokens() external view returns (address[] memory tokens);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IRewardRouterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.27;\n\ninterface IRewardRouterV2 {\n    function claimFees() external;\n    function feeGlpTracker() external view returns (address);\n}"
    },
    "contracts/interfaces/facets/avalanche/IRewardTracker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.27;\n\ninterface IRewardTracker {\n    function depositBalances(address _account, address _depositToken) external view returns (uint256);\n    function stakedAmounts(address _account) external view returns (uint256);\n    function updateRewards() external;\n    function stake(address _depositToken, uint256 _amount) external;\n    function stakeForAccount(address _fundingAccount, address _account, address _depositToken, uint256 _amount) external;\n    function unstake(address _depositToken, uint256 _amount) external;\n    function unstakeForAccount(address _account, address _depositToken, uint256 _amount, address _receiver) external;\n    function tokensPerInterval() external view returns (uint256);\n    function claim(address _receiver) external returns (uint256);\n    function claimForAccount(address _account, address _receiver) external returns (uint256);\n    function claimable(address _account) external view returns (uint256);\n    function averageStakedAmounts(address _account) external view returns (uint256);\n    function cumulativeRewards(address _account) external view returns (uint256);\n}"
    },
    "contracts/interfaces/facets/avalanche/ISteakHutFinanceFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ISteakHutFinanceFacet {\n    function stakeSteakHutAVAXUSDC(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external;\n\n    function unstakeSteakHutAVAXUSDC(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external;\n\n    function stakeSteakHutBTCAVAX(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external;\n\n    function unstakeSteakHutBTCAVAX(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external;\n\n    function stakeSteakHutUSDTeUSDT(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external;\n\n    function unstakeSteakHutUSDTeUSDT(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external;\n\n    function stakeSteakHutJOEAVAX(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external;\n\n    function unstakeSteakHutJOEAVAX(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external;\n\n    function stakeSteakHutEUROCUSDC(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external;\n\n    function unstakeSteakHutEUROCUSDC(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/ISteakHutPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface ISteakHutPool {\n    function deposit(\n        uint256 amountX,\n        uint256 amountY,\n        uint256 amountXMin,\n        uint256 amountYMin\n    )\n        external\n        returns (uint256 shares, uint256 amountXActual, uint256 amountYActual);\n\n    function withdraw(\n        uint256 _shares\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    // ---INTERFACE-----\n    struct StakingDetails {\n        bytes32 token0Symbol;\n        bytes32 token1Symbol;\n        bytes32 vaultTokenSymbol;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    struct UnstakingDetails {\n        bytes32 token0Symbol;\n        bytes32 token1Symbol;\n        bytes32 vaultTokenSymbol;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n}\n"
    },
    "contracts/interfaces/facets/avalanche/ITraderJoeDEXFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ITraderJoeDEXFacet {\n    function swapTraderJoe(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) external returns (uint256[] memory);\n\n    function addLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) external;\n\n    function removeLiquidityTraderJoe(bytes32 _firstAsset, bytes32 _secondAsset, uint liquidity, uint amountAMin, uint amountBMin) external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/ITraderJoeV2Autopool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title TraderJoe V2 autopool interface, based on IBaseVault\n * @author Trader Joe\n * @notice Interface used to interact with Liquidity Book Vaults\n */\ninterface ITraderJoeV2Autopool is IERC20 {\n\n    struct QueuedWithdrawal {\n        mapping(address => uint256) userWithdrawals;\n        uint256 totalQueuedShares;\n        uint128 totalAmountX;\n        uint128 totalAmountY;\n    }\n\n    event Deposited(address indexed user, uint256 amountX, uint256 amountY, uint256 shares);\n\n    event WithdrawalQueued(address indexed sender, address indexed user, uint256 indexed round, uint256 shares);\n\n    event WithdrawalCancelled(address indexed sender, address indexed recipient, uint256 indexed round, uint256 shares);\n\n    event WithdrawalRedeemed(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed round,\n        uint256 shares,\n        uint256 amountX,\n        uint256 amountY\n    );\n\n    event WithdrawalExecuted(uint256 indexed round, uint256 totalQueuedQhares, uint256 amountX, uint256 amountY);\n\n    event WhitelistStateChanged(bool state);\n\n    event WhitelistAdded(address[] addresses);\n\n    event WhitelistRemoved(address[] addresses);\n\n    event Recovered(address token, address recipient, uint256 amount);\n\n    event DepositsPaused();\n\n    event DepositsResumed();\n\n    event EmergencyMode();\n\n    event EmergencyWithdrawal(address indexed sender, uint256 shares, uint256 amountX, uint256 amountY);\n\n    function getTokenX() external view returns (IERC20);\n\n    function getTokenY() external view returns (IERC20);\n\n    function getAumAnnualFee() external view returns (uint256);\n\n    function getRange() external view returns (uint24 low, uint24 upper);\n\n    function getOperators() external view returns (address defaultOperator, address operator);\n\n    function getBalances() external view returns (uint256 amountX, uint256 amountY);\n\n    function previewShares(uint256 amountX, uint256 amountY)\n        external\n        view\n        returns (uint256 shares, uint256 effectiveX, uint256 effectiveY);\n\n    function previewAmounts(uint256 shares) external view returns (uint256 amountX, uint256 amountY);\n\n    function isDepositsPaused() external view returns (bool);\n\n    function isWhitelistedOnly() external view returns (bool);\n\n    function isWhitelisted(address user) external view returns (bool);\n\n    function getCurrentRound() external view returns (uint256 round);\n\n    function getQueuedWithdrawal(uint256 round, address user) external view returns (uint256 shares);\n\n    function getTotalQueuedWithdrawal(uint256 round) external view returns (uint256 totalQueuedShares);\n\n    function getCurrentTotalQueuedWithdrawal() external view returns (uint256 totalQueuedShares);\n\n    function getRedeemableAmounts(uint256 round, address user)\n        external\n        view\n        returns (uint256 amountX, uint256 amountY);\n\n    function deposit(uint256 amountX, uint256 amountY)\n        external\n        returns (uint256 shares, uint256 effectiveX, uint256 effectiveY);\n\n    function depositNative(uint256 amountX, uint256 amountY)\n        external\n        payable\n        returns (uint256 shares, uint256 effectiveX, uint256 effectiveY);\n\n    function queueWithdrawal(uint256 shares, address recipient) external returns (uint256 round);\n\n    function cancelQueuedWithdrawal(uint256 shares) external returns (uint256 round);\n\n    function redeemQueuedWithdrawal(uint256 round, address recipient)\n        external\n        returns (uint256 amountX, uint256 amountY);\n\n    function redeemQueuedWithdrawalNative(uint256 round, address recipient)\n        external\n        returns (uint256 amountX, uint256 amountY);\n\n    function emergencyWithdraw() external;\n\n    function executeQueuedWithdrawals() external;\n\n    function initialize(string memory name, string memory symbol) external;\n\n//    function setStrategy(IStrategy newStrategy) external;\n\n    function setWhitelistState(bool state) external;\n\n    function addToWhitelist(address[] calldata addresses) external;\n\n    function removeFromWhitelist(address[] calldata addresses) external;\n\n    function pauseDeposits() external;\n\n    function resumeDeposits() external;\n\n    function setEmergencyMode() external;\n\n//    function recoverERC20(IERC20Upgradeable token, address recipient, uint256 amount) external;\n\n    // ---INTERFACE----- DeltaPrime structs\n\n    struct StakingDetails {\n        bytes32 token0Symbol;\n        bytes32 token1Symbol;\n        bytes32 vaultTokenSymbol;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n\n    struct UnstakingDetails {\n        bytes32 token0Symbol;\n        bytes32 token1Symbol;\n        bytes32 vaultTokenSymbol;\n        uint256 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n    }\n}\n"
    },
    "contracts/interfaces/facets/avalanche/ITraderJoeV2AutopoolsFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ITraderJoeV2AutopoolsFacet {\n    function stakeTraderJoeV2AutopoolAVAXUSDC(uint256 amount0Desired, uint256 amount1Desired, uint256 amount0Min, uint256 amount1Min) external;\n\n    function unstakeTraderJoeV2AutopoolAVAXUSDC(uint256 liquidity, uint256 amount0Min, uint256 amount1Min) external;\n\n}\n"
    },
    "contracts/interfaces/facets/avalanche/ITraderJoeV2Facet.sol": {
      "content": "pragma solidity ^0.8.27;\n\nimport \"../../joe-v2/ILBRouter.sol\";\n\ninterface ITraderJoeV2Facet {\n\n    struct TraderJoeV2Bin {\n        ILBPair pair;\n        uint24 id;\n    }\n\n    struct RemoveLiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint16 binStep;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256[] ids;\n        uint256[] amounts;\n        uint256 deadline;\n    }\n\n    function fundLiquidityTraderJoeV2(ILBPair pair, uint256[] memory ids, uint256[] memory amounts) external;\n\n    function withdrawLiquidityTraderJoeV2(ILBPair pair, uint256[] memory ids, uint256[] memory amounts) external;\n\n    function addLiquidityTraderJoeV2(ILBRouter traderJoeV2Router, ILBRouter.LiquidityParameters memory liquidityParameters) external;\n\n    function removeLiquidityTraderJoeV2(ILBRouter traderJoeV2Router, RemoveLiquidityParameters memory parameters) external;\n\n    function getOwnedTraderJoeV2Bins() external view returns (TraderJoeV2Bin[] memory result);\n\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IUniswapV3Facet.sol": {
      "content": "pragma solidity ^0.8.27;\n\nimport \"../../joe-v2/ILBRouter.sol\";\nimport \"../../uniswap-v3/IUniswapV3Pool.sol\";\nimport \"../../uniswap-v3-periphery/INonfungiblePositionManager.sol\";\n\ninterface IUniswapV3Facet {\n\n    struct UniswapV3Position {\n        address token0;\n        address token1;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n    }\n\n\n    function mintLiquidityUniswapV3(INonfungiblePositionManager.MintParams calldata params) external;\n\n    function increaseLiquidityUniswapV3(INonfungiblePositionManager.IncreaseLiquidityParams calldata params) external;\n\n    function decreaseLiquidityUniswapV3(INonfungiblePositionManager.DecreaseLiquidityParams calldata params) external;\n\n    function burnLiquidityUniswapV3(uint256 tokenId) external;\n\n    function getOwnedUniswapV3TokenIds() external view returns (uint256[] memory result);\n\n    }\n"
    },
    "contracts/interfaces/facets/avalanche/IVectorFinanceFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IVectorFinanceFacet {\n    function vectorStakeUSDC1Auto(uint256 amount) external;\n\n    function vectorStakeUSDT1Auto(uint256 amount) external;\n\n    function vectorStakeWAVAX1Auto(uint256 amount) external;\n\n    function vectorStakeSAVAX1Auto(uint256 amount) external;\n\n    function vectorUnstakeUSDC1Auto(uint256 amount, uint256 minAmount) external;\n\n    function vectorUnstakeUSDT1Auto(uint256 amount, uint256 minAmount) external;\n\n    function vectorUnstakeWAVAX1Auto(uint256 amount, uint256 minAmount) external;\n\n    function vectorUnstakeSAVAX1Auto(uint256 amount, uint256 minAmount) external;\n\n    function vectorUSDC1BalanceAuto() external view returns(uint256);\n\n    function vectorUSDT1BalanceAuto() external view returns(uint256);\n\n    function vectorWAVAX1BalanceAuto() external view returns(uint256);\n\n    function vectorSAVAX1BalanceAuto() external view returns(uint256);\n\n    function vectorMigrateAvax() external;\n\n    function vectorMigrateSAvax() external;\n\n    /**\n        * @dev emitted when user stakes an asset\n        * @param user the address executing staking\n        * @param asset the asset that was staked\n        * @param vault address of receipt token\n        * @param migratedAmount how much of receipt token was migrated\n        * @param timestamp of staking\n    **/\n    event Migrated(address indexed user, bytes32 indexed asset, address indexed vault, uint256 migratedAmount, uint256 timestamp);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IVectorFinanceFacetOld.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IVectorFinanceFacetOld {\n    function vectorStakeUSDC1(uint256 amount) external;\n\n    function vectorStakeWAVAX1(uint256 amount) external;\n\n    function vectorStakeSAVAX1(uint256 amount) external;\n\n    function vectorUnstakeUSDC1(uint256 amount, uint256 minAmount) external;\n\n    function vectorUnstakeWAVAX1(uint256 amount, uint256 minAmount) external;\n\n    function vectorUnstakeSAVAX1(uint256 amount, uint256 minAmount) external;\n\n    function vectorUSDC1Balance() external view returns(uint256);\n\n    function vectorWAVAX1Balance() external view returns(uint256);\n\n    function vectorSAVAX1Balance() external view returns(uint256);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IWombatFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IWombatFacet {\n    function depositSavaxToAvaxSavax(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawSavaxFromAvaxSavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function sAvaxBalanceAvaxSavax()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function depositGgavaxToAvaxGgavax(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawGgavaxFromAvaxGgavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function ggAvaxBalanceAvaxGgavax()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function depositAvaxToAvaxSavax(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawAvaxFromAvaxSavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function avaxBalanceAvaxSavax()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function depositAvaxToAvaxGgavax(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawAvaxFromAvaxGgavax(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function avaxBalanceAvaxGgavax()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function withdrawSavaxFromAvaxSavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function withdrawGgavaxFromAvaxGgavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function withdrawAvaxFromAvaxSavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function withdrawAvaxFromAvaxGgavaxInOtherToken(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function depositAndStakeAvaxSavaxLpSavax(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxSavaxLpSavax(uint256 amount) external;\n\n    function depositAndStakeAvaxSavaxLpAvax(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxSavaxLpAvax(\n        uint256 amount\n    ) external returns (uint256 amountOut);\n\n    function depositAvaxGgavaxLpGgavax(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxGgavaxLpGgavax(\n        uint256 amount\n    ) external returns (uint256 amountOut);\n\n    function depositAndStakeAvaxGgavaxLpAvax(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxGgavaxLpAvax(\n        uint256 amount\n    ) external returns (uint256 amountOut);\n\n    function claimAllWombatRewards() external;\n\n    function pendingRewardsForAvaxSavaxLpSavax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        );\n\n    function pendingRewardsForAvaxSavaxLpAvax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        );\n\n    function pendingRewardsForAvaxGgavaxLpGgavax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        );\n\n    function pendingRewardsForAvaxGgavaxLpAvax()\n        external\n        view\n        returns (\n            address[] memory rewardTokenAddresses,\n            uint256[] memory pendingRewards\n        );\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IWombatMaster.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IWombatMaster {\n    struct UserInfo {\n        uint128 amount;\n        uint128 factor;\n        uint128 rewardDebt;\n        uint128 pendingWom;\n    }\n\n    function getAssetPid(address asset) external view returns (uint256);\n\n    function boostedRewarders(uint256 pid) external view returns (address);\n\n    function userInfo(\n        uint256 pid,\n        address user\n    ) external view returns (UserInfo memory);\n\n    function deposit(\n        uint256 pid,\n        uint256 amount\n    ) external returns (uint256, uint256);\n\n    function withdraw(\n        uint256 pid,\n        uint256 amount\n    ) external returns (uint256 reward, uint256[] memory additionalRewards);\n\n    function multiClaim(\n        uint256[] calldata _pids\n    )\n        external\n        returns (\n            uint256 reward,\n            uint256[] memory amounts,\n            uint256[][] memory additionalRewards\n        );\n\n    function poolInfo(\n        uint256 _pid\n    )\n        external\n        view\n        returns (\n            address lpToken,\n            uint96 allocPoint,\n            address rewarder,\n            uint256 sumOfFactors,\n            uint104 accWomPerShare,\n            uint104 accWomPerFactorShare,\n            uint40 lastRewardTimestamp\n        );\n\n    function pendingTokens(\n        uint256 _pid,\n        address _user\n    )\n        external\n        view\n        returns (\n            uint256 pendingRewards,\n            address[] memory bonusTokenAddresses,\n            string[] memory bonusTokenSymbols,\n            uint256[] memory pendingBonusRewards\n        );\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IWombatPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IWombatPool {\n    function deposit(\n        address token,\n        uint256 amount,\n        uint256 minimumLiquidity,\n        address to,\n        uint256 deadline,\n        bool shouldStake\n    ) external returns (uint256 liquidity);\n\n    function withdraw(\n        address token,\n        uint256 liquidity,\n        uint256 minimumAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amount);\n\n    function withdrawFromOtherAsset(\n        address fromToken,\n        address toToken,\n        uint256 liquidity,\n        uint256 minimumAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 toAmount);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IWombatRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IWombatRouter {\n    function addLiquidityNative(\n        address pool,\n        uint256 minimumLiquidity,\n        address to,\n        uint256 deadline,\n        bool shouldStake\n    ) external payable returns (uint256 liquidity);\n\n    function removeLiquidityNative(\n        address pool,\n        uint256 liquidity,\n        uint256 minimumAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amount);\n\n    function removeLiquidityFromOtherAssetAsNative(\n        address pool,\n        address fromToken,\n        uint256 liquidity,\n        uint256 minimumAmount,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IYakStakingVectorSAV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IYakStakingVectorSAV2 {\n    function totalDeposits() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function withdraw(uint256 amount) external;\n\n    function depositFor(address account, uint256 amount) external;\n\n    function deposit(uint256 amount) external;\n\n    function decimals() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n}"
    },
    "contracts/interfaces/facets/avalanche/IYieldYak.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IYieldYak {\n    function totalDeposits() external view returns (uint256);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function withdraw(uint256 amount) external;\n\n    function depositFor(address account) external payable;\n\n    function depositFor(address account, uint256 amount) external;\n\n    function deposit() external payable;\n\n    function depositToken() external view returns (address);\n\n    function deposit(uint256 amount) external;\n\n    function decimals() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    // ---INTERFACE-----\n    struct YYStakingDetails {\n        address tokenAddress;\n        address vaultAddress;\n        bytes32 tokenSymbol;\n        bytes32 vaultTokenSymbol;\n        uint256 amount;\n    }\n}"
    },
    "contracts/interfaces/facets/avalanche/IYieldYakFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IYieldYakFacet {\n    function stakeUSDTYak(uint256 amount) external;\n\n    function stakeUSDCeYak(uint256 amount) external;\n\n    function stakeAVAXYak(uint256 amount) external;\n\n    function stakeSAVAXYak(uint256 amount) external;\n\n    function stakeGLPYak(uint256 amount) external;\n\n    function stakePNGAVAXUSDCYak(uint256 amount) external;\n\n    function stakePNGAVAXETHYak(uint256 amount) external;\n\n    function stakeTJAVAXUSDCYak(uint256 amount) external;\n\n    function stakeTJAVAXETHYak(uint256 amount) external;\n\n    function stakeTJAVAXSAVAXYak(uint256 amount) external;\n\n    function unstakeAVAXYak(uint256 amount) external;\n\n    function unstakeUSDTYak(uint256 amount) external;\n\n    function unstakeUSDCeYak(uint256 amount) external;\n\n    function unstakeSAVAXYak(uint256 amount) external;\n\n    function unstakeGLPYak(uint256 amount) external;\n\n    function unstakePNGAVAXUSDCYak(uint256 amount) external;\n\n    function unstakePNGAVAXETHYak(uint256 amount) external;\n\n    function unstakeTJAVAXUSDCYak(uint256 amount) external;\n\n    function unstakeTJAVAXETHYak(uint256 amount) external;\n\n    function unstakeTJAVAXSAVAXYak(uint256 amount) external;\n\n    //deprecated\n//    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\n\n    //deprecated\n//    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 amount, uint256 timestamp);\n\n    event Staked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n\n    event Unstaked(address indexed user, bytes32 indexed asset, address indexed vault, uint256 depositTokenAmount, uint256 receiptTokenAmount, uint256 timestamp);\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IYieldYakSwapFacet.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.27;\n\ninterface IYieldYakSwapFacet {\n    function yakSwap(uint256 _amountIn, uint256 _amountOut, address[] calldata _path, address[] calldata _adapters) external;\n}"
    },
    "contracts/interfaces/facets/avalanche/IYieldYakWombatFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IYieldYakWombatFacet {\n    function depositSavaxToAvaxSavaxYY(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawSavaxFromAvaxSavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function sAvaxBalanceAvaxSavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function depositGgavaxToAvaxGgavaxYY(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawGgavaxFromAvaxGgavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function ggAvaxBalanceAvaxGgavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function depositAvaxToAvaxSavaxYY(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawAvaxFromAvaxSavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function avaxBalanceAvaxSavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function depositAvaxToAvaxGgavaxYY(uint256 amount, uint256 minLpOut) external;\n\n    function withdrawAvaxFromAvaxGgavaxYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function avaxBalanceAvaxGgavaxYY()\n        external\n        view\n        returns (uint256 _stakedBalance);\n\n    function withdrawSavaxFromAvaxSavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function withdrawGgavaxFromAvaxGgavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function withdrawAvaxFromAvaxSavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function withdrawAvaxFromAvaxGgavaxInOtherTokenYY(\n        uint256 amount,\n        uint256 minOut\n    ) external returns (uint256 amountOut);\n\n    function depositAndStakeAvaxSavaxLpSavaxYY(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxSavaxLpSavaxYY(uint256 amount) external;\n\n    function depositAndStakeAvaxSavaxLpAvaxYY(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxSavaxLpAvaxYY(\n        uint256 amount\n    ) external returns (uint256 amountOut);\n\n    function depositAvaxGgavaxLpGgavaxYY(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxGgavaxLpGgavaxYY(\n        uint256 amount\n    ) external returns (uint256 amountOut);\n\n    function depositAndStakeAvaxGgavaxLpAvaxYY(uint256 amount) external;\n\n    function unstakeAndWithdrawAvaxGgavaxLpAvaxYY(\n        uint256 amount\n    ) external returns (uint256 amountOut);\n\n    function migrateAvaxSavaxLpSavaxFromWombatToYY() external;\n\n    function migrateAvaxGgavaxLpGgavaxFromWombatToYY() external;\n\n    function migrateAvaxSavaxLpAvaxFromWombatToYY() external;\n\n    function migrateAvaxGgavaxLpAvaxFromWombatToYY() external;\n}\n"
    },
    "contracts/interfaces/facets/avalanche/IYYWombatPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IYYWombatPool {\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function getDepositTokensForShares(\n        uint256 shares\n    ) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/facets/celo/IUbeswapDEXFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IUbeswapDEXFacet {\n    function swapUbeswap(bytes32 _soldAsset, bytes32 _boughtAsset, uint256 _exactSold, uint256 _minimumBought) external returns (uint256[] memory);\n}\n"
    },
    "contracts/interfaces/facets/IAssetsOperationsFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IAssetsOperationsFacet {\n    function borrow(bytes32 _asset, uint256 _amount) external;\n\n    function fund(bytes32 _fundedAsset, uint256 _amount) external;\n\n    function fundGLP(uint256 _amount) external;\n\n    function repay(bytes32 _asset, uint256 _amount) payable external;\n\n    function withdraw(bytes32 _withdrawnAsset, uint256 _amount) external;\n\n    function removeUnsupportedOwnedAsset(bytes32 _asset, address _address) external;\n\n    function withdrawGLP(uint256 _amount) external;\n\n    function swapDebt(bytes32 _fromAsset, bytes32 _toAsset, uint256 _repayAmount, uint256 _borrowAmount, address[] calldata _path, address[] calldata _adapters) external;\n\n    function swapDebtParaSwap(bytes32 _fromAsset, bytes32 _toAsset, uint256 _repayAmount, uint256 _borrowAmount, bytes4 selector, bytes memory data) external;\n\n    function withdrawUnsupportedToken(address token) external;\n\n    event Funded(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    event Withdrawn(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    event Borrowed(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    event Repaid(address indexed user, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n\n    event DebtSwap(address indexed user, address indexed fromToken, address indexed toToken, uint256 repayAmount, uint256 borrowAmount, uint256 timestamp);\n\n}\n"
    },
    "contracts/interfaces/facets/IBeefyFinance.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.4;\n\ninterface IBeefyFinance {\n    // -- Deposit/Withdraw underlying LP token --\n    function depositAll() external;\n\n    function deposit(uint256 amount) external;\n\n    function withdraw(uint256 amount) external;\n\n    function withdrawAll() external;\n\n    // ------------------------------------------\n\n    // User's balance of the vault's token\n    function balanceOf(address account) external view returns (uint256);\n\n    // Vault's balance of the underlying token\n    function balance() external view returns (uint256);\n\n    // Total supply of the vault's token\n    function totalSupply() external view returns (uint256);\n\n    // Decimals of the vault's token\n    function decimals() external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    // ---INTERFACE-----\n    struct BeefyStakingDetails {\n        address lpTokenAddress;\n        address vaultAddress;\n        bytes32 lpTokenSymbol;\n        bytes32 vaultTokenSymbol;\n        uint256 amount;\n    }\n\n}"
    },
    "contracts/interfaces/facets/IDiamondInit.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IDiamondInit {\n    function init() external;\n}\n"
    },
    "contracts/interfaces/facets/IGMDVault.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IGMDVault {\n    function enter(uint256 _amountin, uint256 _pid) external;\n    function leave(uint256 _share, uint256 _pid) external;\n    function poolInfo(uint256 pid) view external returns (PoolInfoStruct memory);\n\n    struct PoolInfoStruct {\n        address lpToken;\n        address GDlptoken;\n        uint256 EarnRateSec;\n        uint256 totalStaked;\n        uint256 lastUpdate;\n        uint256 vaultcap;\n        uint256 glpFees;\n        uint256 APR;\n        bool stakable;\n        bool withdrawable;\n        bool rewardStart;\n    }\n}\n"
    },
    "contracts/interfaces/facets/IGmxV2Facet.sol": {
      "content": "pragma solidity ^0.8.27;\n\nimport \"../gmx-v2/EventUtils.sol\";\nimport \"../gmx-v2/Deposit.sol\";\nimport \"../gmx-v2/Withdrawal.sol\";\n\ninterface IGmxV2Facet {\n    function depositBtcUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositEthUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositAvaxUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositArbUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositLinkUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositUniUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositSolUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositNearUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositAtomUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function depositGmxUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) external payable;\n\n    function withdrawEthUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawArbUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawLinkUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawUniUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawBtcUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawAvaxUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawSolUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawNearUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawAtomUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function withdrawGmxUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) external payable;\n\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external;\n\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external;\n\n    function afterWithdrawalExecution(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external;\n\n    function afterWithdrawalCancellation(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external;\n\n    function refundExecutionFee(bytes32 key, EventUtils.EventLogData memory eventData) external payable;\n}\n"
    },
    "contracts/interfaces/facets/IGmxV2PlusFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IGmxV2PlusFacet {\n    function depositBtcGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable;\n\n    function depositEthGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable;\n\n    function depositAvaxGmxV2Plus(\n        uint256 tokenAmount,\n        uint256 minGmAmount,\n        uint256 executionFee\n    ) external payable;\n\n    function withdrawBtcGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable;\n\n    function withdrawEthGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable;\n\n    function withdrawAvaxGmxV2Plus(\n        uint256 gmAmount,\n        uint256 minLongTokenAmount,\n        uint256 minShortTokenAmount,\n        uint256 executionFee\n    ) external payable;\n}\n"
    },
    "contracts/interfaces/facets/IHealthMeterFacetProd.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IHealthMeterFacetProd {\n    function getHealthMeter() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/facets/IOwnershipFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IOwnershipFacet {\n    function proposeOwnershipTransfer(address _newOwner) external;\n\n    function acceptOwnership() external;\n\n    function owner() external view returns (address owner_);\n\n    function proposedOwner() external view returns (address proposedOwner_);\n\n    function pauseAdmin() external view returns (address pauseAdmin);\n\n    function proposedPauseAdmin() external view returns (address proposedPauseAdmin);\n}\n"
    },
    "contracts/interfaces/facets/ISmartLoanLiquidationFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ISmartLoanLiquidationFacet {\n  function _getLTV (  ) external returns ( uint256 ltv );\n  function getMaxLiquidationBonus (  ) external view returns ( uint256 );\n  function getMaxLtv (  ) external view returns ( uint256 );\n  function getMinLtvAfterLiquidation (  ) external view returns ( uint256 );\n  function getPrice ( bytes32 symbol ) external view returns ( uint256 price );\n  function getPrices ( bytes32[] memory symbols ) external view returns ( uint256[] memory prices );\n  function liquidateLoan ( bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonus) external;\n  function unsafeLiquidateLoan ( bytes32[] memory assetsToRepay, uint256[] memory amountsToRepay, uint256 _liquidationBonus) external;\n  function whitelistLiquidators(address[] memory _liquidators) external;\n  function delistLiquidators(address[] memory _liquidators) external;\n  function isLiquidatorWhitelisted(address _liquidator) view external returns(bool);\n\n  event Liquidated(address indexed liquidator, bool indexed healing, uint256 initialTotal, uint256 initialDebt, uint256 repayAmount, uint256 bonusInUSD, uint256 health, uint256 timestamp);\n  event LiquidationRepay(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n  event LiquidationTransfer(address indexed liquidator, bytes32 indexed asset, uint256 amount, uint256 timestamp);\n  event LiquidatorWhitelisted(address indexed liquidator, address performer, uint256 timestamp);\n  event LiquidatorDelisted(address indexed liquidator, address performer, uint256 timestamp);\n}\n"
    },
    "contracts/interfaces/facets/ISmartLoanViewFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\nimport \"../../facets/SmartLoanViewFacet.sol\";\n\ninterface ISmartLoanViewFacet {\n    function getAllAssetsBalances() external view returns (SmartLoanViewFacet.AssetNameBalance[] memory);\n\n    function getAllAssetsBalancesDebtCoverages() external view returns (SmartLoanViewFacet.AssetNameBalanceDebtCoverage[] memory);\n\n    function getDebts() external view returns (SmartLoanViewFacet.AssetNameDebt[] memory);\n\n    function getAllAssetsPrices() external view returns (SmartLoanViewFacet.AssetNamePrice[] memory);\n\n    function getAllOwnedAssets() external view returns (bytes32[] memory result);\n\n    function getTotalAssetsValue() external view returns (uint256);\n\n    function getSupportedTokensAddresses() external view returns (address[] memory result);\n\n    function getBalance(bytes32 _asset) external view returns (uint256);\n\n    function getPercentagePrecision() external view returns (uint256);\n\n    function getContractOwner() external view returns (address _owner);\n\n    function getProposedOwner() external view returns (address _proposed);\n\n    function getStakedPositions() external view returns (IStakingPositions.StakedPosition[] memory  _positions);\n\n    function initialize(address owner) external;\n}\n"
    },
    "contracts/interfaces/facets/ISmartLoanWrappedNativeTokenFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ISmartLoanWrappedNativeTokenFacet {\n    function depositNativeToken() payable external;\n\n    function unwrapAndWithdraw(uint256 _amount) payable external;\n\n    function wrapNativeToken(uint256 amount) external;\n\n    event WrapNative(address indexed user, uint256 amount, uint256 timestamp);\n\n    event DepositNative(address indexed user, uint256 amount, uint256 timestamp);\n\n    event UnwrapAndWithdraw(address indexed user, uint256 amount, uint256 timestamp);\n}\n"
    },
    "contracts/interfaces/facets/ISolvencyFacetProd.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface ISolvencyFacetProd {\n    function getDebt() external view returns (uint256);\n\n    function getFullLoanStatus() external view returns (uint256[5] memory);\n\n    function getHealthRatio() external view returns (uint256);\n\n    function getThresholdWeightedValue() external view returns (uint256);\n\n    function getMaxDataTimestampDelay() external view returns (uint256);\n\n    function getTotalValue() external view returns (uint256);\n\n    function getTotalTraderJoeV2() external view returns (uint256);\n\n    function isSignerAuthorized(address _receivedSigner) external view returns (bool);\n\n    function isSolvent() external view returns (bool);\n\n    function isTimestampValid(uint256 _receivedTimestamp) external view returns (bool);\n\n    function getStakedValue() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/facets/IUniswapV2DEXFacet.sol": {
      "content": "pragma solidity ^0.8.27;\n\ninterface IUniswapV2DEXFacet {\n    event Swap(address indexed user, bytes32 indexed soldAsset, bytes32 indexed boughtAsset, uint256 maximumSold, uint256 minimumBought, uint256 timestamp);\n    event AddLiquidity(address indexed user, address indexed lpToken, bytes32 firstAsset, bytes32 secondAsset, uint liquidity, uint firstAmount, uint secondAmount, uint256 timestamp);\n    event RemoveLiquidity(address indexed user, address indexed lpToken, bytes32 firstAsset, bytes32 secondAsset, uint liquidity, uint firstAmount, uint secondAmount, uint256 timestamp);\n}\n"
    },
    "contracts/interfaces/facets/IYieldYakRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\ninterface IYieldYakRouter {\n    struct Trade {\n        uint256 amountIn;\n        uint256 amountOut;\n        address[] path;\n        address[] adapters;\n    }\n\n    struct FormattedOffer {\n        uint256[] amounts;\n        address[] adapters;\n        address[] path;\n    }\n\n    function swapNoSplit(\n        Trade calldata _trade,\n        address _to,\n        uint256 _fee\n    ) external;\n}"
    },
    "contracts/interfaces/gmx-v2/ArbSys.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title ArbSys\n// @dev Globally available variables for Arbitrum may have both an L1 and an L2\n// value, the ArbSys interface is used to retrieve the L2 value\ninterface ArbSys {\n    function arbBlockNumber() external view returns (uint256);\n    function arbBlockHash(uint256 blockNumber) external view returns (bytes32);\n}\n"
    },
    "contracts/interfaces/gmx-v2/BasicMulticall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n//import \"../error/ErrorUtils.sol\";\n\n/**\n * @title BasicMulticall\n */\nabstract contract BasicMulticall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external virtual payable returns  (bytes[] memory results) {\n        results = new bytes[](data.length);\n\n        for (uint256 i; i < data.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\n\n            if (!success) {\n//                ErrorUtils.revertWithParsedMessage(result);\n            }\n\n            results[i] = result;\n        }\n\n        return results;\n    }\n}\n"
    },
    "contracts/interfaces/gmx-v2/Chain.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./ArbSys.sol\";\n\n// @title Chain\n// @dev Wrap the calls to retrieve chain variables to handle differences\n// between chain implementations\nlibrary Chain {\n    // if the ARBITRUM_CHAIN_ID changes, a new version of this library\n    // and contracts depending on it would need to be deployed\n    uint256 constant public ARBITRUM_CHAIN_ID = 42161;\n    uint256 constant public ARBITRUM_GOERLI_CHAIN_ID = 421613;\n\n    ArbSys constant public arbSys = ArbSys(address(100));\n\n    // @dev return the current block's timestamp\n    // @return the current block's timestamp\n    function currentTimestamp() internal view returns (uint256) {\n        return block.timestamp;\n    }\n\n    // @dev return the current block's number\n    // @return the current block's number\n    function currentBlockNumber() internal view returns (uint256) {\n        if (shouldUseArbSysValues()) {\n            return arbSys.arbBlockNumber();\n        }\n\n        return block.number;\n    }\n\n    // @dev return the current block's hash\n    // @return the current block's hash\n    function getBlockHash(uint256 blockNumber) internal view returns (bytes32) {\n        if (shouldUseArbSysValues()) {\n            return arbSys.arbBlockHash(blockNumber);\n        }\n\n        return blockhash(blockNumber);\n    }\n\n    function shouldUseArbSysValues() internal view returns (bool) {\n        return block.chainid == ARBITRUM_CHAIN_ID || block.chainid == ARBITRUM_GOERLI_CHAIN_ID;\n\n    }\n}\n"
    },
    "contracts/interfaces/gmx-v2/Deposit.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n// @title Deposit\n// @dev Struct for deposits\nlibrary Deposit {\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account the account depositing liquidity\n    // @param receiver the address to send the liquidity tokens to\n    // @param callbackContract the callback contract\n    // @param uiFeeReceiver the ui fee receiver\n    // @param market the market to deposit to\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n\n    // @param initialLongTokenAmount the amount of long tokens to deposit\n    // @param initialShortTokenAmount the amount of short tokens to deposit\n    // @param minMarketTokens the minimum acceptable number of liquidity tokens\n    // @param updatedAtBlock the block that the deposit was last updated at\n    // sending funds back to the user in case the deposit gets cancelled\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    struct Numbers {\n        uint256 initialLongTokenAmount;\n        uint256 initialShortTokenAmount;\n        uint256 minMarketTokens;\n        uint256 updatedAtBlock;\n        uint256 updatedAtTime;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    function receiver(Props memory props) internal pure returns (address) {\n        return props.addresses.receiver;\n    }\n\n    function setReceiver(Props memory props, address value) internal pure {\n        props.addresses.receiver = value;\n    }\n\n    function callbackContract(Props memory props) internal pure returns (address) {\n        return props.addresses.callbackContract;\n    }\n\n    function setCallbackContract(Props memory props, address value) internal pure {\n        props.addresses.callbackContract = value;\n    }\n\n    function uiFeeReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.uiFeeReceiver;\n    }\n\n    function setUiFeeReceiver(Props memory props, address value) internal pure {\n        props.addresses.uiFeeReceiver = value;\n    }\n\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    function initialLongToken(Props memory props) internal pure returns (address) {\n        return props.addresses.initialLongToken;\n    }\n\n    function setInitialLongToken(Props memory props, address value) internal pure {\n        props.addresses.initialLongToken = value;\n    }\n\n    function initialShortToken(Props memory props) internal pure returns (address) {\n        return props.addresses.initialShortToken;\n    }\n\n    function setInitialShortToken(Props memory props, address value) internal pure {\n        props.addresses.initialShortToken = value;\n    }\n\n    function longTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.longTokenSwapPath;\n    }\n\n    function setLongTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.longTokenSwapPath = value;\n    }\n\n    function shortTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.shortTokenSwapPath;\n    }\n\n    function setShortTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.shortTokenSwapPath = value;\n    }\n\n    function initialLongTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.initialLongTokenAmount;\n    }\n\n    function setInitialLongTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.initialLongTokenAmount = value;\n    }\n\n    function initialShortTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.initialShortTokenAmount;\n    }\n\n    function setInitialShortTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.initialShortTokenAmount = value;\n    }\n\n    function minMarketTokens(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minMarketTokens;\n    }\n\n    function setMinMarketTokens(Props memory props, uint256 value) internal pure {\n        props.numbers.minMarketTokens = value;\n    }\n\n    function updatedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtBlock;\n    }\n\n    function setUpdatedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtBlock = value;\n    }\n\n    function updatedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtTime;\n    }\n\n    function setUpdatedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtTime = value;\n    }\n\n    function executionFee(Props memory props) internal pure returns (uint256) {\n        return props.numbers.executionFee;\n    }\n\n    function setExecutionFee(Props memory props, uint256 value) internal pure {\n        props.numbers.executionFee = value;\n    }\n\n    function callbackGasLimit(Props memory props) internal pure returns (uint256) {\n        return props.numbers.callbackGasLimit;\n    }\n\n    function setCallbackGasLimit(Props memory props, uint256 value) internal pure {\n        props.numbers.callbackGasLimit = value;\n    }\n\n    function shouldUnwrapNativeToken(Props memory props) internal pure returns (bool) {\n        return props.flags.shouldUnwrapNativeToken;\n    }\n\n    function setShouldUnwrapNativeToken(Props memory props, bool value) internal pure {\n        props.flags.shouldUnwrapNativeToken = value;\n    }\n}"
    },
    "contracts/interfaces/gmx-v2/EventUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nlibrary EventUtils {\n    struct EmitPositionDecreaseParams {\n        bytes32 key;\n        address account;\n        address market;\n        address collateralToken;\n        bool isLong;\n    }\n\n    struct EventLogData {\n        AddressItems addressItems;\n        UintItems uintItems;\n        IntItems intItems;\n        BoolItems boolItems;\n        Bytes32Items bytes32Items;\n        BytesItems bytesItems;\n        StringItems stringItems;\n    }\n\n    struct AddressItems {\n        AddressKeyValue[] items;\n        AddressArrayKeyValue[] arrayItems;\n    }\n\n    struct UintItems {\n        UintKeyValue[] items;\n        UintArrayKeyValue[] arrayItems;\n    }\n\n    struct IntItems {\n        IntKeyValue[] items;\n        IntArrayKeyValue[] arrayItems;\n    }\n\n    struct BoolItems {\n        BoolKeyValue[] items;\n        BoolArrayKeyValue[] arrayItems;\n    }\n\n    struct Bytes32Items {\n        Bytes32KeyValue[] items;\n        Bytes32ArrayKeyValue[] arrayItems;\n    }\n\n    struct BytesItems {\n        BytesKeyValue[] items;\n        BytesArrayKeyValue[] arrayItems;\n    }\n\n    struct StringItems {\n        StringKeyValue[] items;\n        StringArrayKeyValue[] arrayItems;\n    }\n\n    struct AddressKeyValue {\n        string key;\n        address value;\n    }\n\n    struct AddressArrayKeyValue {\n        string key;\n        address[] value;\n    }\n\n    struct UintKeyValue {\n        string key;\n        uint256 value;\n    }\n\n    struct UintArrayKeyValue {\n        string key;\n        uint256[] value;\n    }\n\n    struct IntKeyValue {\n        string key;\n        int256 value;\n    }\n\n    struct IntArrayKeyValue {\n        string key;\n        int256[] value;\n    }\n\n    struct BoolKeyValue {\n        string key;\n        bool value;\n    }\n\n    struct BoolArrayKeyValue {\n        string key;\n        bool[] value;\n    }\n\n    struct Bytes32KeyValue {\n        string key;\n        bytes32 value;\n    }\n\n    struct Bytes32ArrayKeyValue {\n        string key;\n        bytes32[] value;\n    }\n\n    struct BytesKeyValue {\n        string key;\n        bytes value;\n    }\n\n    struct BytesArrayKeyValue {\n        string key;\n        bytes[] value;\n    }\n\n    struct StringKeyValue {\n        string key;\n        string value;\n    }\n\n    struct StringArrayKeyValue {\n        string key;\n        string[] value;\n    }\n\n    function initItems(AddressItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.AddressKeyValue[](size);\n    }\n\n    function initArrayItems(AddressItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.AddressArrayKeyValue[](size);\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(AddressItems memory items, uint256 index, string memory key, address[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(UintItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.UintKeyValue[](size);\n    }\n\n    function initArrayItems(UintItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.UintArrayKeyValue[](size);\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(UintItems memory items, uint256 index, string memory key, uint256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(IntItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.IntKeyValue[](size);\n    }\n\n    function initArrayItems(IntItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.IntArrayKeyValue[](size);\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(IntItems memory items, uint256 index, string memory key, int256[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BoolItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BoolKeyValue[](size);\n    }\n\n    function initArrayItems(BoolItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BoolArrayKeyValue[](size);\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BoolItems memory items, uint256 index, string memory key, bool[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.items = new EventUtils.Bytes32KeyValue[](size);\n    }\n\n    function initArrayItems(Bytes32Items memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.Bytes32ArrayKeyValue[](size);\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32 value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(Bytes32Items memory items, uint256 index, string memory key, bytes32[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(BytesItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.BytesKeyValue[](size);\n    }\n\n    function initArrayItems(BytesItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.BytesArrayKeyValue[](size);\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(BytesItems memory items, uint256 index, string memory key, bytes[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n\n    function initItems(StringItems memory items, uint256 size) internal pure {\n        items.items = new EventUtils.StringKeyValue[](size);\n    }\n\n    function initArrayItems(StringItems memory items, uint256 size) internal pure {\n        items.arrayItems = new EventUtils.StringArrayKeyValue[](size);\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string memory value) internal pure {\n        items.items[index].key = key;\n        items.items[index].value = value;\n    }\n\n    function setItem(StringItems memory items, uint256 index, string memory key, string[] memory value) internal pure {\n        items.arrayItems[index].key = key;\n        items.arrayItems[index].value = value;\n    }\n}"
    },
    "contracts/interfaces/gmx-v2/IDepositCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./EventUtils.sol\";\nimport \"./Deposit.sol\";\n\n// @title IDepositCallbackReceiver\n// @dev interface for a deposit callback contract\ninterface IDepositCallbackReceiver {\n    // @dev called after a deposit execution\n    // @param key the key of the deposit\n    // @param deposit the deposit that was executed\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after a deposit cancellation\n    // @param key the key of the deposit\n    // @param deposit the deposit that was cancelled\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external;\n}\n"
    },
    "contracts/interfaces/gmx-v2/IDepositUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IDepositUtils {\n    struct CreateDepositParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialLongToken;\n        address initialShortToken;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minMarketTokens;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    function createDeposit(CreateDepositParams calldata params) external payable returns (bytes32);\n}"
    },
    "contracts/interfaces/gmx-v2/IGasFeeCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./EventUtils.sol\";\n\n// @title IGasFeeCallbackReceiver\n// @dev interface for a gas fee callback contract\ninterface IGasFeeCallbackReceiver {\n    function refundExecutionFee(bytes32 key, EventUtils.EventLogData memory eventData) external payable;\n}\n"
    },
    "contracts/interfaces/gmx-v2/IGmxV2Router.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IGmxV2Router {\n    function sendWnt(address receiver, uint256 amount) external payable;\n\n    function sendTokens(address token, address receiver, uint256 amount) external payable;\n}"
    },
    "contracts/interfaces/gmx-v2/IOrderCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./EventUtils.sol\";\nimport \"./Order.sol\";\n\n// @title IOrderCallbackReceiver\n// @dev interface for an order callback contract\ninterface IOrderCallbackReceiver {\n    // @dev called after an order execution\n    // @param key the key of the order\n    // @param order the order that was executed\n    function afterOrderExecution(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after an order cancellation\n    // @param key the key of the order\n    // @param order the order that was cancelled\n    function afterOrderCancellation(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after an order has been frozen, see OrderUtils.freezeOrder in OrderHandler for more info\n    // @param key the key of the order\n    // @param order the order that was frozen\n    function afterOrderFrozen(bytes32 key, Order.Props memory order, EventUtils.EventLogData memory eventData) external;\n}"
    },
    "contracts/interfaces/gmx-v2/IReaderDepositUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\ninterface IReaderDepositUtils {\n    function getDepositAmountOut(\n        address dataStore,\n        MarketProps memory market,\n        MarketPrices memory prices,\n        uint256 longTokenAmount,\n        uint256 shortTokenAmount,\n        address uiFeeReceiver\n    ) external view returns (uint256);\n\n    function getWithdrawalAmountOut(\n        address dataStore,\n        MarketProps memory market,\n        MarketPrices memory prices,\n        uint256 marketTokenAmount,\n        address uiFeeReceiver\n    ) external view returns (uint256, uint256);\n\n    struct MarketPrices {\n        PriceProps indexTokenPrice;\n        PriceProps longTokenPrice;\n        PriceProps shortTokenPrice;\n    }\n\n    struct PriceProps {\n        uint256 min;\n        uint256 max;\n    }\n\n    struct MarketProps {\n        address marketToken;\n        address indexToken;\n        address longToken;\n        address shortToken;\n    }\n}\n"
    },
    "contracts/interfaces/gmx-v2/IRoleStore.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title IRoleStore\n * @dev Stores roles and their members.\n */\ninterface IRoleStore {\n    /**\n     * @dev Returns true if the given account has the specified role.\n     *\n     * @param account The address of the account.\n     * @param roleKey The key of the role.\n     * @return True if the account has the role, false otherwise.\n     */\n    function hasRole(address account, bytes32 roleKey) external view returns (bool);\n}"
    },
    "contracts/interfaces/gmx-v2/IWithdrawalCallbackReceiver.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./EventUtils.sol\";\nimport \"./Withdrawal.sol\";\n\n// @title IWithdrawalCallbackReceiver\n// @dev interface for a withdrawal callback contract\ninterface IWithdrawalCallbackReceiver {\n    // @dev called after a withdrawal execution\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was executed\n    function afterWithdrawalExecution(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external;\n\n    // @dev called after a withdrawal cancellation\n    // @param key the key of the withdrawal\n    // @param withdrawal the withdrawal that was cancelled\n    function afterWithdrawalCancellation(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external;\n}\n"
    },
    "contracts/interfaces/gmx-v2/IWithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface IWithdrawalUtils {\n    struct CreateWithdrawalParams {\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        bool shouldUnwrapNativeToken;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    function createWithdrawal(CreateWithdrawalParams calldata params) external payable returns (bytes32);\n}"
    },
    "contracts/interfaces/gmx-v2/Order.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\nimport \"./Chain.sol\";\n\n// @title Order\n// @dev Struct for orders\nlibrary Order {\n    using Order for Props;\n\n    enum OrderType {\n        // @dev MarketSwap: swap token A to token B at the current market price\n        // the order will be cancelled if the minOutputAmount cannot be fulfilled\n        MarketSwap,\n        // @dev LimitSwap: swap token A to token B if the minOutputAmount can be fulfilled\n        LimitSwap,\n        // @dev MarketIncrease: increase position at the current market price\n        // the order will be cancelled if the position cannot be increased at the acceptablePrice\n        MarketIncrease,\n        // @dev LimitIncrease: increase position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitIncrease,\n        // @dev MarketDecrease: decrease position at the current market price\n        // the order will be cancelled if the position cannot be decreased at the acceptablePrice\n        MarketDecrease,\n        // @dev LimitDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        LimitDecrease,\n        // @dev StopLossDecrease: decrease position if the triggerPrice is reached and the acceptablePrice can be fulfilled\n        StopLossDecrease,\n        // @dev Liquidation: allows liquidation of positions if the criteria for liquidation are met\n        Liquidation\n    }\n\n    // to help further differentiate orders\n    enum SecondaryOrderType {\n        None,\n        Adl\n    }\n\n    enum DecreasePositionSwapType {\n        NoSwap,\n        SwapPnlTokenToCollateralToken,\n        SwapCollateralTokenToPnlToken\n    }\n\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account the account of the order\n    // @param receiver the receiver for any token transfers\n    // this field is meant to allow the output of an order to be\n    // received by an address that is different from the creator of the\n    // order whether this is for swaps or whether the account is the owner\n    // of a position\n    // for funding fees and claimable collateral, the funds are still\n    // credited to the owner of the position indicated by order.account\n    // @param callbackContract the contract to call for callbacks\n    // @param uiFeeReceiver the ui fee receiver\n    // @param market the trading market\n    // @param initialCollateralToken for increase orders, initialCollateralToken\n    // is the token sent in by the user, the token will be swapped through the\n    // specified swapPath, before being deposited into the position as collateral\n    // for decrease orders, initialCollateralToken is the collateral token of the position\n    // withdrawn collateral from the decrease of the position will be swapped\n    // through the specified swapPath\n    // for swaps, initialCollateralToken is the initial token sent for the swap\n    // @param swapPath an array of market addresses to swap through\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address initialCollateralToken;\n        address[] swapPath;\n    }\n\n    // @param sizeDeltaUsd the requested change in position size\n    // @param initialCollateralDeltaAmount for increase orders, initialCollateralDeltaAmount\n    // is the amount of the initialCollateralToken sent in by the user\n    // for decrease orders, initialCollateralDeltaAmount is the amount of the position's\n    // collateralToken to withdraw\n    // for swaps, initialCollateralDeltaAmount is the amount of initialCollateralToken sent\n    // in for the swap\n    // @param orderType the order type\n    // @param triggerPrice the trigger price for non-market orders\n    // @param acceptablePrice the acceptable execution price for increase / decrease orders\n    // @param executionFee the execution fee for keepers\n    // @param callbackGasLimit the gas limit for the callbackContract\n    // @param minOutputAmount the minimum output amount for decrease orders and swaps\n    // note that for decrease orders, multiple tokens could be received, for this reason, the\n    // minOutputAmount value is treated as a USD value for validation in decrease orders\n    // @param updatedAtBlock the block at which the order was last updated\n    struct Numbers {\n        OrderType orderType;\n        DecreasePositionSwapType decreasePositionSwapType;\n        uint256 sizeDeltaUsd;\n        uint256 initialCollateralDeltaAmount;\n        uint256 triggerPrice;\n        uint256 acceptablePrice;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n        uint256 minOutputAmount;\n        uint256 updatedAtBlock;\n    }\n\n    // @param isLong whether the order is for a long or short\n    // @param shouldUnwrapNativeToken whether to unwrap native tokens before\n    // transferring to the user\n    // @param isFrozen whether the order is frozen\n    struct Flags {\n        bool isLong;\n        bool shouldUnwrapNativeToken;\n        bool isFrozen;\n    }\n\n    // @dev the order account\n    // @param props Props\n    // @return the order account\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    // @dev set the order account\n    // @param props Props\n    // @param value the value to set to\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    // @dev the order receiver\n    // @param props Props\n    // @return the order receiver\n    function receiver(Props memory props) internal pure returns (address) {\n        return props.addresses.receiver;\n    }\n\n    // @dev set the order receiver\n    // @param props Props\n    // @param value the value to set to\n    function setReceiver(Props memory props, address value) internal pure {\n        props.addresses.receiver = value;\n    }\n\n    // @dev the order callbackContract\n    // @param props Props\n    // @return the order callbackContract\n    function callbackContract(Props memory props) internal pure returns (address) {\n        return props.addresses.callbackContract;\n    }\n\n    // @dev set the order callbackContract\n    // @param props Props\n    // @param value the value to set to\n    function setCallbackContract(Props memory props, address value) internal pure {\n        props.addresses.callbackContract = value;\n    }\n\n    // @dev the order market\n    // @param props Props\n    // @return the order market\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    // @dev set the order market\n    // @param props Props\n    // @param value the value to set to\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    // @dev the order initialCollateralToken\n    // @param props Props\n    // @return the order initialCollateralToken\n    function initialCollateralToken(Props memory props) internal pure returns (address) {\n        return props.addresses.initialCollateralToken;\n    }\n\n    // @dev set the order initialCollateralToken\n    // @param props Props\n    // @param value the value to set to\n    function setInitialCollateralToken(Props memory props, address value) internal pure {\n        props.addresses.initialCollateralToken = value;\n    }\n\n    // @dev the order uiFeeReceiver\n    // @param props Props\n    // @return the order uiFeeReceiver\n    function uiFeeReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.uiFeeReceiver;\n    }\n\n    // @dev set the order uiFeeReceiver\n    // @param props Props\n    // @param value the value to set to\n    function setUiFeeReceiver(Props memory props, address value) internal pure {\n        props.addresses.uiFeeReceiver = value;\n    }\n\n    // @dev the order swapPath\n    // @param props Props\n    // @return the order swapPath\n    function swapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.swapPath;\n    }\n\n    // @dev set the order swapPath\n    // @param props Props\n    // @param value the value to set to\n    function setSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.swapPath = value;\n    }\n\n    // @dev the order type\n    // @param props Props\n    // @return the order type\n    function orderType(Props memory props) internal pure returns (OrderType) {\n        return props.numbers.orderType;\n    }\n\n    // @dev set the order type\n    // @param props Props\n    // @param value the value to set to\n    function setOrderType(Props memory props, OrderType value) internal pure {\n        props.numbers.orderType = value;\n    }\n\n    function decreasePositionSwapType(Props memory props) internal pure returns (DecreasePositionSwapType) {\n        return props.numbers.decreasePositionSwapType;\n    }\n\n    function setDecreasePositionSwapType(Props memory props, DecreasePositionSwapType value) internal pure {\n        props.numbers.decreasePositionSwapType = value;\n    }\n\n    // @dev the order sizeDeltaUsd\n    // @param props Props\n    // @return the order sizeDeltaUsd\n    function sizeDeltaUsd(Props memory props) internal pure returns (uint256) {\n        return props.numbers.sizeDeltaUsd;\n    }\n\n    // @dev set the order sizeDeltaUsd\n    // @param props Props\n    // @param value the value to set to\n    function setSizeDeltaUsd(Props memory props, uint256 value) internal pure {\n        props.numbers.sizeDeltaUsd = value;\n    }\n\n    // @dev the order initialCollateralDeltaAmount\n    // @param props Props\n    // @return the order initialCollateralDeltaAmount\n    function initialCollateralDeltaAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.initialCollateralDeltaAmount;\n    }\n\n    // @dev set the order initialCollateralDeltaAmount\n    // @param props Props\n    // @param value the value to set to\n    function setInitialCollateralDeltaAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.initialCollateralDeltaAmount = value;\n    }\n\n    // @dev the order triggerPrice\n    // @param props Props\n    // @return the order triggerPrice\n    function triggerPrice(Props memory props) internal pure returns (uint256) {\n        return props.numbers.triggerPrice;\n    }\n\n    // @dev set the order triggerPrice\n    // @param props Props\n    // @param value the value to set to\n    function setTriggerPrice(Props memory props, uint256 value) internal pure {\n        props.numbers.triggerPrice = value;\n    }\n\n    // @dev the order acceptablePrice\n    // @param props Props\n    // @return the order acceptablePrice\n    function acceptablePrice(Props memory props) internal pure returns (uint256) {\n        return props.numbers.acceptablePrice;\n    }\n\n    // @dev set the order acceptablePrice\n    // @param props Props\n    // @param value the value to set to\n    function setAcceptablePrice(Props memory props, uint256 value) internal pure {\n        props.numbers.acceptablePrice = value;\n    }\n\n    // @dev set the order executionFee\n    // @param props Props\n    // @param value the value to set to\n    function setExecutionFee(Props memory props, uint256 value) internal pure {\n        props.numbers.executionFee = value;\n    }\n\n    // @dev the order executionFee\n    // @param props Props\n    // @return the order executionFee\n    function executionFee(Props memory props) internal pure returns (uint256) {\n        return props.numbers.executionFee;\n    }\n\n    // @dev the order callbackGasLimit\n    // @param props Props\n    // @return the order callbackGasLimit\n    function callbackGasLimit(Props memory props) internal pure returns (uint256) {\n        return props.numbers.callbackGasLimit;\n    }\n\n    // @dev set the order callbackGasLimit\n    // @param props Props\n    // @param value the value to set to\n    function setCallbackGasLimit(Props memory props, uint256 value) internal pure {\n        props.numbers.callbackGasLimit = value;\n    }\n\n    // @dev the order minOutputAmount\n    // @param props Props\n    // @return the order minOutputAmount\n    function minOutputAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minOutputAmount;\n    }\n\n    // @dev set the order minOutputAmount\n    // @param props Props\n    // @param value the value to set to\n    function setMinOutputAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.minOutputAmount = value;\n    }\n\n    // @dev the order updatedAtBlock\n    // @param props Props\n    // @return the order updatedAtBlock\n    function updatedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtBlock;\n    }\n\n    // @dev set the order updatedAtBlock\n    // @param props Props\n    // @param value the value to set to\n    function setUpdatedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtBlock = value;\n    }\n\n    // @dev whether the order is for a long or short\n    // @param props Props\n    // @return whether the order is for a long or short\n    function isLong(Props memory props) internal pure returns (bool) {\n        return props.flags.isLong;\n    }\n\n    // @dev set whether the order is for a long or short\n    // @param props Props\n    // @param value the value to set to\n    function setIsLong(Props memory props, bool value) internal pure {\n        props.flags.isLong = value;\n    }\n\n    // @dev whether to unwrap the native token before transfers to the user\n    // @param props Props\n    // @return whether to unwrap the native token before transfers to the user\n    function shouldUnwrapNativeToken(Props memory props) internal pure returns (bool) {\n        return props.flags.shouldUnwrapNativeToken;\n    }\n\n    // @dev set whether the native token should be unwrapped before being\n    // transferred to the receiver\n    // @param props Props\n    // @param value the value to set to\n    function setShouldUnwrapNativeToken(Props memory props, bool value) internal pure {\n        props.flags.shouldUnwrapNativeToken = value;\n    }\n\n    // @dev whether the order is frozen\n    // @param props Props\n    // @return whether the order is frozen\n    function isFrozen(Props memory props) internal pure returns (bool) {\n        return props.flags.isFrozen;\n    }\n\n    // @dev set whether the order is frozen\n    // transferred to the receiver\n    // @param props Props\n    // @param value the value to set to\n    function setIsFrozen(Props memory props, bool value) internal pure {\n        props.flags.isFrozen = value;\n    }\n\n    // @dev set the order.updatedAtBlock to the current block number\n    // @param props Props\n    function touch(Props memory props) internal view {\n        props.setUpdatedAtBlock(Chain.currentBlockNumber());\n    }\n}"
    },
    "contracts/interfaces/gmx-v2/Withdrawal.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.0;\n\n/**\n * @title Withdrawal\n * @dev Struct for withdrawals\n */\nlibrary Withdrawal {\n    // @dev there is a limit on the number of fields a struct can have when being passed\n    // or returned as a memory variable which can cause \"Stack too deep\" errors\n    // use sub-structs to avoid this issue\n    // @param addresses address values\n    // @param numbers number values\n    // @param flags boolean values\n    struct Props {\n        Addresses addresses;\n        Numbers numbers;\n        Flags flags;\n    }\n\n    // @param account The account to withdraw for.\n    // @param receiver The address that will receive the withdrawn tokens.\n    // @param callbackContract The contract that will be called back.\n    // @param uiFeeReceiver The ui fee receiver.\n    // @param market The market on which the withdrawal will be executed.\n    struct Addresses {\n        address account;\n        address receiver;\n        address callbackContract;\n        address uiFeeReceiver;\n        address market;\n        address[] longTokenSwapPath;\n        address[] shortTokenSwapPath;\n    }\n\n    // @param marketTokenAmount The amount of market tokens that will be withdrawn.\n    // @param minLongTokenAmount The minimum amount of long tokens that must be withdrawn.\n    // @param minShortTokenAmount The minimum amount of short tokens that must be withdrawn.\n    // @param updatedAtBlock The block at which the withdrawal was last updated.\n    // @param executionFee The execution fee for the withdrawal.\n    // @param callbackGasLimit The gas limit for calling the callback contract.\n    struct Numbers {\n        uint256 marketTokenAmount;\n        uint256 minLongTokenAmount;\n        uint256 minShortTokenAmount;\n        uint256 updatedAtBlock;\n        uint256 updatedAtTime;\n        uint256 executionFee;\n        uint256 callbackGasLimit;\n    }\n\n    // @param shouldUnwrapNativeToken whether to unwrap the native token when\n    struct Flags {\n        bool shouldUnwrapNativeToken;\n    }\n\n    function account(Props memory props) internal pure returns (address) {\n        return props.addresses.account;\n    }\n\n    function setAccount(Props memory props, address value) internal pure {\n        props.addresses.account = value;\n    }\n\n    function receiver(Props memory props) internal pure returns (address) {\n        return props.addresses.receiver;\n    }\n\n    function setReceiver(Props memory props, address value) internal pure {\n        props.addresses.receiver = value;\n    }\n\n    function callbackContract(Props memory props) internal pure returns (address) {\n        return props.addresses.callbackContract;\n    }\n\n    function setCallbackContract(Props memory props, address value) internal pure {\n        props.addresses.callbackContract = value;\n    }\n\n    function uiFeeReceiver(Props memory props) internal pure returns (address) {\n        return props.addresses.uiFeeReceiver;\n    }\n\n    function setUiFeeReceiver(Props memory props, address value) internal pure {\n        props.addresses.uiFeeReceiver = value;\n    }\n\n    function market(Props memory props) internal pure returns (address) {\n        return props.addresses.market;\n    }\n\n    function setMarket(Props memory props, address value) internal pure {\n        props.addresses.market = value;\n    }\n\n    function longTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.longTokenSwapPath;\n    }\n\n    function setLongTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.longTokenSwapPath = value;\n    }\n\n    function shortTokenSwapPath(Props memory props) internal pure returns (address[] memory) {\n        return props.addresses.shortTokenSwapPath;\n    }\n\n    function setShortTokenSwapPath(Props memory props, address[] memory value) internal pure {\n        props.addresses.shortTokenSwapPath = value;\n    }\n\n    function marketTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.marketTokenAmount;\n    }\n\n    function setMarketTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.marketTokenAmount = value;\n    }\n\n    function minLongTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minLongTokenAmount;\n    }\n\n    function setMinLongTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.minLongTokenAmount = value;\n    }\n\n    function minShortTokenAmount(Props memory props) internal pure returns (uint256) {\n        return props.numbers.minShortTokenAmount;\n    }\n\n    function setMinShortTokenAmount(Props memory props, uint256 value) internal pure {\n        props.numbers.minShortTokenAmount = value;\n    }\n\n    function updatedAtBlock(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtBlock;\n    }\n\n    function setUpdatedAtBlock(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtBlock = value;\n    }\n\n    function updatedAtTime(Props memory props) internal pure returns (uint256) {\n        return props.numbers.updatedAtTime;\n    }\n\n    function setUpdatedAtTime(Props memory props, uint256 value) internal pure {\n        props.numbers.updatedAtTime = value;\n    }\n\n    function executionFee(Props memory props) internal pure returns (uint256) {\n        return props.numbers.executionFee;\n    }\n\n    function setExecutionFee(Props memory props, uint256 value) internal pure {\n        props.numbers.executionFee = value;\n    }\n\n    function callbackGasLimit(Props memory props) internal pure returns (uint256) {\n        return props.numbers.callbackGasLimit;\n    }\n\n    function setCallbackGasLimit(Props memory props, uint256 value) internal pure {\n        props.numbers.callbackGasLimit = value;\n    }\n\n    function shouldUnwrapNativeToken(Props memory props) internal pure returns (bool) {\n        return props.flags.shouldUnwrapNativeToken;\n    }\n\n    function setShouldUnwrapNativeToken(Props memory props, bool value) internal pure {\n        props.flags.shouldUnwrapNativeToken = value;\n    }\n}"
    },
    "contracts/interfaces/IAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAddressProvider {\n    function getRecoveryContract() external view returns (address);\n}\n"
    },
    "contracts/interfaces/IAssetsExchange.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/**\n * @title IAssetExchange\n * @dev Basic interface for investing into assets\n * It could be linked either to DEX or to a synthetic assets platform\n */\ninterface IAssetsExchange {\n\n    /*\n     * Swaps selected ERC20 token with other ERC20 token\n     * @param soldToken_ sold ERC20 token's address\n     * @param boughtToken_ bought ERC20 token's address\n     * @param _amountSold exact amount of ERC20 token to be sold\n     * @param _amountBought minimum amount of ERC20 token to be bought\n     **/\n    function swap(address soldToken_, address boughtToken_, uint256 _exactAmountIn, uint256 _minAmountOut) external returns (uint256[] memory);\n\n    /*\n     * Adds liquidity of ERC20 tokens\n     */\n    function addLiquidity(address tokenA, address tokenB, uint amountADesired, uint amountBDesired, uint amountAMin, uint amountBMin) external returns (address, uint, uint, uint);\n\n    /*\n     * Removes liquidity of ERC20 tokens\n     */\n    function removeLiquidity(address tokenA, address tokenB, uint liquidity, uint amountAMin, uint amountBMin) external returns (uint, uint);\n\n    /**\n     * Returns the minimum _soldToken amount that is required to be sold to receive _exactAmountOut of a _boughtToken.\n     **/\n    function getMinimumTokensNeeded(uint256 _exactAmountOut, address _soldToken, address _boughtToken) external returns (uint256);\n\n    /**\n     * Returns the maximum _boughtToken amount that will be obtained in the event of selling _amountIn of _soldToken token.\n     **/\n    function getMaximumTokensReceived(uint256 _amountIn, address _soldToken, address _boughtToken) external returns (uint256);\n\n    /**\n     * getPair\n     **/\n    function getPair(address _tokenA, address _tokenB) external returns (address);\n\n}\n"
    },
    "contracts/interfaces/IBorrowersRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\n/**\n * @title IBorrowersRegistry\n * Keeps a registry of created trading accounts to verify their borrowing rights\n */\ninterface IBorrowersRegistry {\n    function canBorrow(address _account) external view returns (bool);\n\n    function getLoanForOwner(address _owner) external view returns (address);\n\n    function getOwnerOfLoan(address _loan) external view returns (address);\n}\n"
    },
    "contracts/interfaces/ICurvePool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ninterface ICurvePool {\n    function underlying_coins(uint256 arg0) external view returns (address);\n\n    function token() external view returns (address);\n\n    function calc_withdraw_one_coin(\n        uint256 token_amount,\n        uint256 i\n    ) external view returns (uint256);\n\n    function add_liquidity(\n        uint256[5] calldata _amounts,\n        uint256 _min_mint_amount\n    ) external;\n\n    function remove_liquidity(\n        uint256 _amount,\n        uint256[5] calldata _min_amounts\n    ) external;\n\n    function remove_liquidity_one_coin(\n        uint256 _token_amount,\n        uint256 i,\n        uint256 _min_amount\n    ) external;\n}\n"
    },
    "contracts/interfaces/IDepositRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\ninterface IDepositRewarder {\n\n    function getRewardsFor(address payable _user) external;\n\n    function earned(address _account) external view returns (uint);\n\n    function balanceOf(address _account) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IDiamondBeacon.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity 0.8.27;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IDiamondBeacon {\n\n    function implementation() external view returns (address);\n\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {SmartLoanDiamondProxy} will check that this address is a contract.\n     */\n    function implementation(bytes4) external view returns (address);\n\n    function getStatus() external view returns (bool);\n\n    function proposeBeaconOwnershipTransfer(address _newOwner) external;\n\n    function acceptBeaconOwnership() external;\n}\n"
    },
    "contracts/interfaces/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    function pause() external;\n\n    function unpause() external;\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n}"
    },
    "contracts/interfaces/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet) external view returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses() external view returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector) external view returns (address facetAddress_);\n}"
    },
    "contracts/interfaces/IERC173.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\n/// @title ERC-173 Contract Ownership Standard\n///  Note: the ERC-165 identifier for this interface is 0x7f5828d0\n/* is ERC165 */\ninterface IERC173 {\n    /// @dev This emits when ownership of a contract changes.\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /// @notice Get the address of the owner\n    /// @return owner_ The address of the owner.\n    function owner() external view returns (address owner_);\n\n    /// @notice Set the address of the new owner of the contract\n    /// @dev Set _newOwner to address(0) to renounce any ownership.\n    /// @param _newOwner The address of the new owner of the contract\n    function transferOwnership(address _newOwner) external;\n}"
    },
    "contracts/interfaces/IGgAvax.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\n/**\n * @title IGgAvax\n */\ninterface IGgAvax {\n    function depositAVAX() external payable;\n}\n"
    },
    "contracts/interfaces/IIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\ninterface IIndex {\n\n    function setRate(uint256 _rate) external;\n\n    function updateUser(address user) external;\n\n    function getIndex() external view returns (uint256);\n\n    function getIndexedValue(uint256 value, address user) external view returns (uint256);\n\n}\n"
    },
    "contracts/interfaces/IMasterChefVTX.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IMasterChefVTX {\n    function earned(address account, address rewardToken) external view returns (uint256);\n}"
    },
    "contracts/interfaces/IPendingOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IPendingOwnableUpgradeable {\n    function transferOwnership(address newOwner) external;\n    function acceptOwnership() external;\n    function pendingOwner() external view returns (address);\n}"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IPool is IERC20 {\n    function getLockedBalance(address account) external view returns (uint256);\n    function lockDeposit(uint256 amount, uint256 lockTime) external;\n    function getFullyVestedLockedBalance(address account) external view returns (uint256);\n    function setVPrimeController(address _vPrimeController) external;\n    function deposit(uint256 _amount) external;\n    function depositOnBehalf(uint256 _amount, address _of) external;\n    function withdraw(uint256 _amount) external;\n    function borrow(uint256 _amount) external;\n    function repay(uint256 amount) external;\n    function getBorrowed(address _user) external view returns (uint256);\n    function balanceOf(address user) external view override returns (uint256);\n    function getDepositRate() external view returns (uint256);\n    function getBorrowingRate() external view returns (uint256);\n    function getFullPoolStatus() external view returns (uint256[5] memory);\n    function recoverSurplus(uint256 amount, address account) external;\n    function isWithdrawalAmountAvailable(address account, uint256 amount) external view returns (bool);\n    function getMaxPoolUtilisationForBorrowing() external view returns (uint256);\n    function totalBorrowed() external view returns (uint256);\n    function totalSupply() external view returns (uint256);\n    function decimals() external view returns (uint8);\n    function symbol() external view returns (string memory);\n    function name() external view returns (string memory);\n    function totalSupplyCap() external view returns (uint256);\n    function ratesCalculator() external view returns (address);\n    function borrowersRegistry() external view returns (address);\n    function poolRewarder() external view returns (address);\n    function depositIndex() external view returns (address);\n    function borrowIndex() external view returns (address);\n    function tokenAddress() external view returns (address);\n    function vestingDistributor() external view returns (address);\n    function vPrimeControllerContract() external view returns (address);\n\n    /**\n     * @dev emitted after the user deposits funds\n     * @param user the address performing the deposit\n     * @param value the amount deposited\n     * @param timestamp of the deposit\n     **/\n    event Deposit(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after the user deposits funds on behalf of other user\n     * @param user the address performing the deposit\n     * @param _of the address on behalf of which the deposit is being performed\n     * @param value the amount deposited\n     * @param timestamp of the deposit\n     **/\n    event DepositOnBehalfOf(address indexed user, address indexed _of, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after the user withdraws funds\n     * @param user the address performing the withdrawal\n     * @param value the amount withdrawn\n     * @param timestamp of the withdrawal\n     **/\n    event Withdrawal(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after the user borrows funds\n     * @param user the address that borrows\n     * @param value the amount borrowed\n     * @param timestamp time of the borrowing\n     **/\n    event Borrowing(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after the user repays debt\n     * @param user the address that repays debt\n     * @param value the amount repaid\n     * @param timestamp of the repayment\n     **/\n    event Repayment(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after accumulating deposit interest\n     * @param user the address that the deposit interest is accumulated for\n     * @param value the amount that interest is calculated from\n     * @param timestamp of the interest accumulation\n     **/\n    event InterestCollected(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n    * @dev emitted after changing borrowers registry\n    * @param registry an address of the newly set borrowers registry\n    * @param timestamp of the borrowers registry change\n    **/\n    event BorrowersRegistryChanged(address indexed registry, uint256 timestamp);\n\n    /**\n    * @dev emitted after changing rates calculator\n    * @param calculator an address of the newly set rates calculator\n    * @param timestamp of the borrowers registry change\n    **/\n    event RatesCalculatorChanged(address indexed calculator, uint256 timestamp);\n\n    /**\n    * @dev emitted after changing pool rewarder\n    * @param poolRewarder an address of the newly set pool rewarder\n    * @param timestamp of the pool rewarder change\n    **/\n    event PoolRewarderChanged(address indexed poolRewarder, uint256 timestamp);\n\n\n    /**\n     * @dev emitted after the user locks deposit\n     * @param user the address that locks the deposit\n     * @param amount the amount locked\n     * @param lockTime the time for which the deposit is locked\n     * @param unlockTime the time when the deposit will be unlocked\n     **/\n    event DepositLocked(address indexed user, uint256 amount, uint256 lockTime, uint256 unlockTime);\n}"
    },
    "contracts/interfaces/IPoolRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\ninterface IPoolRewarder {\n\n    function stakeFor(uint _amount, address _stakeFor) external;\n\n    function withdrawFor(uint _amount, address _unstakeFor) external returns (uint);\n\n    function getRewardsFor(address _user) external;\n\n    function earned(address _account) external view returns (uint);\n\n    function balanceOf(address _account) external view returns (uint);\n}\n"
    },
    "contracts/interfaces/IPositionManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.27;\n\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\nimport \"./ISPrimeTraderJoe.sol\";\n\ninterface IPositionManager is IERC721Enumerable {\n    // details about the position\n    struct Position {\n        // the liquidity of the position\n        uint256 totalShare;\n        uint256 centerId;\n        uint256[] liquidityMinted;\n    }\n\n    struct DepositConfig {\n        uint256[] depositIds;\n        bytes32[] liquidityConfigs;\n    }\n\n\n    struct UpdateParams {\n        uint256 tokenId;\n        uint256 share;\n        uint256[] liquidityAmounts;\n        bool isAdd;\n    }\n\n    struct MintParams {\n        address recipient;\n        uint256 totalShare;\n        uint256 centerId;\n        uint256[] liquidityMinted;\n        bytes32[] liquidityConfigs;\n        uint256[] depositIds;\n    }\n\n    event SPrimeUpdated(ISPrimeTraderJoe prime);\n\n    // Mint new position NFT\n    function mint(\n        MintParams calldata params\n    )\n        external\n        returns (\n            uint256 tokenId\n        );\n\n    // Burn position NFT\n    function burn(\n        uint256 tokenId\n    )\n        external;\n\n    function update(\n        UpdateParams calldata params\n    )\n        external;\n\n    function forceTransfer(address from, address to, uint256 tokenId) external;\n    function getDepositConfig(uint256 centerId) external view returns(DepositConfig memory);\n    function getDepositConfigFromTokenId(uint256 tokenId) external view returns(DepositConfig memory);\n    \n    // Get position details\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            IERC20 token0,\n            IERC20 token1,\n            ILBPair pairAddr,\n            uint256 totalShare,\n            uint256 centerId,\n            uint256[] memory liquidityMinted\n        );\n}"
    },
    "contracts/interfaces/IRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\n/**\n * @title IRatesCalculator\n * @dev Interface defining base method for contracts implementing interest rates calculation.\n * The calculated value could be based on the relation between funds borrowed and deposited.\n */\ninterface IRatesCalculator {\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external view returns (uint256);\n\n    function calculateDepositRate(uint256 totalLoans, uint256 totalDeposits) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/ISPrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISPrime {\n    /**\n    * @dev Struct representing details of a locked amount.\n    * @param lockPeriod The duration for which the amount is locked.\n    * @param amount The amount that is locked.\n    * @param unlockTime The timestamp when the locked amount will be able to released.\n    */\n    struct LockDetails {\n        uint256 lockPeriod;\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    /**\n    * @dev Users can use withdraw function for withdrawing their share.\n    * @param shareWithdraw The amount of share to withdraw.\n    * @param amountXMin The minimum amount of token X to receive.\n    * @param amountYMin The minimum amount of token Y to receive.\n    */\n    function withdraw(\n        uint256 shareWithdraw,\n        uint256 amountXMin,\n        uint256 amountYMin\n    ) external;\n\n    /**\n    * @dev Users can use deposit function for depositing tokens\n    * @param activeIdDesired The active id that user wants to add liquidity from\n    * @param idSlippage The active id slippage that are allowed to slip\n    * @param amountX The amount of token X to deposit.\n    * @param amountY The amount of token Y to deposit.\n    * @param isRebalance Rebalance the existing position with deposit.\n    * @param swapSlippage Slippage for the rebalance.\n    */\n    function deposit(uint256 activeIdDesired, uint256 idSlippage, uint256 amountX, uint256 amountY, bool isRebalance, uint256 swapSlippage) external;\n\n    function getTokenX() external view returns(IERC20);\n    function getTokenY() external view returns(IERC20);\n    function getPoolPrice() external view returns(uint256);\n    function getUserValueInTokenY(address user, uint256 poolPrice) external view returns (uint256);\n    function getFullyVestedLockedBalance(address account) external view returns(uint256);\n}"
    },
    "contracts/interfaces/ISPrimeTraderJoe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.27;\n\nimport \"./ISPrime.sol\";\nimport \"./joe-v2/ILBPair.sol\";\nimport \"./IPositionManager.sol\";\n\ninterface ISPrimeTraderJoe is ISPrime {\n  struct DepositForm{\n    int256 deltaId;\n    uint64 distributionX;\n    uint64 distributionY;\n  }\n\n  /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param activeIdDesired The active id that user wants to add liquidity from\n    * @param idSlippage The number of id that are allowed to slip\n    * @param amountX The amount of token X to deposit.\n    * @param amountY The amount of token Y to deposit.\n    * @param isRebalance Rebalance the existing position with deposit.\n    * @param swapSlippage Slippage for the rebalance.\n    */\n    function deposit(\n        uint256 activeIdDesired,\n        uint256 idSlippage,\n        uint256 amountX,\n        uint256 amountY,\n        bool isRebalance,\n        uint256 swapSlippage\n    ) external;\n    \n  function getLBPair() external view returns(ILBPair);\n  function positionManager() external view returns(IPositionManager);\n}\n"
    },
    "contracts/interfaces/ISPrimeUniswap.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISPrimeUniswap {\n  /**\n   * @dev Struct representing the information for the nft position.\n   * @param tokenId NFT Position Token Id.\n   * @param lpAmount LP token amount for the specific token id.\n   * @param share sPrime token share amount for the nft position\n   */\n  struct LiquidityInfo {\n    uint256 tokenId;\n    uint128 lpAmount;\n    uint256 share;\n  }\n\n  /**\n   * @dev Users can use deposit function for depositing tokens to the specific bin.\n   * @param tickDesired The tick that user wants to add liquidity from\n   * @param tickSlippage The tick slippage that are allowed to slip\n   * @param amountX The amount of token X to deposit.\n   * @param amountY The amount of token Y to deposit.\n   * @param desiredAmountX The desired amount of token X to deposit.\n   * @param desiredAmountY The desired amount of token Y to deposit.\n   * @param isRebalance Rebalance the existing position with deposit.\n   * @param swapSlippage Slippage for the rebalance.\n   */\n  function deposit(\n    int24 tickDesired,\n    int24 tickSlippage,\n    uint256 amountX,\n    uint256 amountY,\n    uint256 desiredAmountX,\n    uint256 desiredAmountY,\n    bool isRebalance,\n    uint256 swapSlippage\n  ) external;\n\n    /**\n     * @dev Users can use withdraw function for withdrawing their share.\n     * @param shareWithdraw The amount of share to withdraw.\n     * @param amountXMin The minimum amount of token X to receive.\n     * @param amountYMin The minimum amount of token Y to receive.\n     */\n    function withdraw(\n        uint256 shareWithdraw,\n        uint256 amountXMin,\n        uint256 amountYMin\n    ) external;\n\n    /**\n      * @dev Struct representing details of a locked amount.\n      * @param lockPeriod The duration for which the amount is locked.\n      * @param amount The amount that is locked.\n      * @param unlockTime The timestamp when the locked amount will be able to released.\n      */\n    struct LockDetails {\n      uint256 lockPeriod;\n      uint256 amount;\n      uint256 unlockTime;\n    }\n\n    function getTokenX() external view returns(IERC20);\n    function getTokenY() external view returns(IERC20);\n    function getPoolPrice() external view returns(uint256);\n    function getUserValueInTokenY(address user, uint256 poolPrice) external view returns (uint256);\n    function getFullyVestedLockedBalance(address account) external view returns(uint256);\n}\n"
    },
    "contracts/interfaces/IStakingPositions.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\n/**\n * @title IStakingPositions\n * Types for staking\n */\ninterface IStakingPositions {\n    struct StakedPosition {\n        // Asset is either the token (symbol) address being staked or the address of the PTP LP token in case where a pool for that token (symbol) already exists within the VectorFinance\n        address asset;\n        bytes32 symbol;\n        bytes32 identifier;\n        bytes4 balanceSelector;\n        bytes4 unstakeSelector;\n    }\n}\n"
    },
    "contracts/interfaces/ITokenManager.sol": {
      "content": "interface ITokenManager {\n    struct poolAsset {\n        bytes32 asset;\n        address poolAddress;\n    }\n\n    struct Asset {\n        bytes32 asset;\n        address assetAddress;\n        uint256 debtCoverage;\n    }\n\n    function activateToken ( address token ) external;\n    function addPoolAssets ( poolAsset[] memory poolAssets ) external;\n    function addTokenAssets ( Asset[] memory tokenAssets ) external;\n    function deactivateToken ( address token ) external;\n    function debtCoverage ( address ) external view returns ( uint256 );\n    function getVPrimeControllerAddress ( ) external view returns ( address );\n    function debtCoverageStaked ( bytes32 ) external view returns ( uint256 );\n    function getAllPoolAssets (  ) external view returns ( bytes32[] memory result );\n    function getAllTokenAssets (  ) external view returns ( bytes32[] memory result );\n    function identifierToExposureGroup ( bytes32 _asset) external view returns ( bytes32 );\n    function getAssetAddress ( bytes32 _asset, bool allowInactive ) external view returns ( address );\n    function getPoolAddress ( bytes32 _asset ) external view returns ( address );\n    function getSupportedTokensAddresses (  ) external view returns ( address[] memory);\n    function initialize ( Asset[] memory tokenAssets, poolAsset[] memory poolAssets ) external;\n    function increaseProtocolExposure ( bytes32 assetIdentifier, uint256 exposureIncrease ) external;\n    function decreaseProtocolExposure(bytes32 assetIdentifier, uint256 exposureDecrease) external;\n    function isTokenAssetActive ( address token ) external view returns ( bool );\n    function owner (  ) external view returns ( address );\n    function removePoolAssets ( bytes32[] memory _poolAssets ) external;\n    function removeTokenAssets ( bytes32[] memory _tokenAssets ) external;\n    function renounceOwnership (  ) external;\n    function setDebtCoverage ( address token, uint256 coverage ) external;\n    function setMaxProtocolsExposure (bytes32[] memory groupIdentifiers, uint256[] memory maxExposures) external;\n    function setIdentifiersToExposureGroups (bytes32[] memory identifiers, bytes32[] memory exposureGroups) external;\n    function setDebtCoverageStaked ( bytes32 stakedAsset, uint256 coverage ) external;\n    function supportedTokensList ( uint256 ) external view returns ( address );\n    function tokenAddressToSymbol ( address ) external view returns ( bytes32 );\n    function tokenToStatus ( address ) external view returns ( uint256 );\n    function transferOwnership ( address newOwner ) external;\n    function increasePendingExposure ( bytes32 , address, uint256 ) external;\n    function setPendingExposureToZero ( bytes32, address ) external;\n}"
    },
    "contracts/interfaces/IVectorFinanceCompounder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IVectorFinanceCompounder {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    function decimals() external view returns (uint256);\n\n    function withdraw(uint256 amount, uint256 minAmount) external;\n\n    function deposit(uint256 amount) external;\n\n    function stakingToken() external view returns (address);\n\n    function depositTracking(address) external view returns (uint256);\n\n    function migrateAllUserDepositsFromManual() external;\n\n    function migrateAllUserDepositsToManual() external;\n\n    function getDepositTokensForShares(uint256 amount) external view returns (uint256);\n}"
    },
    "contracts/interfaces/IVectorFinanceMainStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IVectorFinanceMainStaking {\n    struct PoolInfo {\n        uint256 pid;\n        bool isActive;\n        address token;\n        address lp;\n        uint256 sizeLp;\n        address receipt;\n        uint256 size;\n        address rewards_addr;\n        address helper;\n    }\n\n    function getPoolInfo(address _address)\n    external\n    view\n    returns (PoolInfo memory);\n}"
    },
    "contracts/interfaces/IVectorFinanceStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./IVectorFinanceCompounder.sol\";\nimport \"./IVectorRewarder.sol\";\n\ninterface IVectorFinanceStaking {\n    function balance(address account) external view returns (uint256);\n\n    function compounder() external view returns (IVectorFinanceCompounder);\n\n    function withdraw(uint256 amount, uint256 minAmount) external;\n\n    function deposit(uint256 amount) external;\n\n    function decimals() external view returns (uint256);\n\n    function earned(address rewardToken) external view returns (uint256);\n\n    function masterVtx() external view returns (address);\n\n    function stakingToken() external view returns (address);\n\n    function rewarder() external view returns (IVectorRewarder);\n}"
    },
    "contracts/interfaces/IVectorRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\ninterface IVectorRewarder {\n    function rewardTokens(uint256 index) external view returns (address);\n\n    function earned(address account, address rewardToken) external view returns (uint256);\n\n    function updateFor(address account) external;\n}"
    },
    "contracts/interfaces/IVPrimeController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.27;\n\ninterface IVPrimeController {\n    function updateVPrimeSnapshotsForAccounts(address[] memory accounts) external;\n    function updateVPrimeSnapshot(address userAddress) external;\n    function setUserNeedsUpdate(address userAddress) external;\n}"
    },
    "contracts/interfaces/IWrappedNativeToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.27;\n\ninterface IWrappedNativeToken {\n\n    function balanceOf(address account) external view returns (uint);\n\n    function deposit() external payable;\n\n    function withdraw(uint wad) external;\n\n    function totalSupply() external view returns (uint);\n\n    function approve(address guy, uint wad) external returns (bool);\n\n    function transfer(address dst, uint wad) external returns (bool);\n\n    function transferFrom(address src, address dst, uint wad) external returns (bool);\n\n}"
    },
    "contracts/interfaces/IYakWrapRouter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\ninterface IYakWrapRouter {\n\n    struct FormattedOffer {\n        uint256[] amounts;\n        address[] adapters;\n        address[] path;\n        uint256 gasEstimate;\n    }\n\n    function findBestPathAndWrap(\n        uint256 amountIn,\n        address tokenIn,\n        address wrapper,\n        uint256 maxSteps,\n        uint256 gasPrice\n    ) external view returns (FormattedOffer memory bestOffer);\n\n    function unwrapAndFindBestPath(\n        uint256 amountIn,\n        address tokenOut,\n        address wrapper,\n        uint256 maxSteps,\n        uint256 gasPrice\n    ) external view returns (FormattedOffer memory bestOffer);\n}"
    },
    "contracts/interfaces/joe-v2/IJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/// @title Joe V1 Factory Interface\n/// @notice Interface to interact with Joe V1 Factory\ninterface IJoeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/IJoePair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/// @title Joe V1 Pair Interface\n/// @notice Interface to interact with Joe V1 Pairs\ninterface IJoePair {\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function name() external pure returns (string memory);\n\n    function symbol() external pure returns (string memory);\n\n    function decimals() external pure returns (uint8);\n\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n    function nonces(address owner) external view returns (uint256);\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)\n        external;\n\n    event Mint(address indexed sender, uint256 amount0, uint256 amount1);\n    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address indexed to\n    );\n    event Sync(uint112 reserve0, uint112 reserve1);\n\n    function MINIMUM_LIQUIDITY() external pure returns (uint256);\n\n    function factory() external view returns (address);\n\n    function token0() external view returns (address);\n\n    function token1() external view returns (address);\n\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function price0CumulativeLast() external view returns (uint256);\n\n    function price1CumulativeLast() external view returns (uint256);\n\n    function kLast() external view returns (uint256);\n\n    function mint(address to) external returns (uint256 liquidity);\n\n    function burn(address to) external returns (uint256 amount0, uint256 amount1);\n\n    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;\n\n    function skim(address to) external;\n\n    function sync() external;\n\n    function initialize(address, address) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/IJoeRouter01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/// @title Joe V1 Router01 Interface\n/// @notice Interface to interact with Joe V1 Router\ninterface IJoeRouter01 {\n    function factory() external pure returns (address);\n\n    function WAVAX() external pure returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 amountADesired,\n        uint256 amountBDesired,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);\n\n    function addLiquidityAVAX(\n        address token,\n        uint256 amountTokenDesired,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountToken, uint256 amountAVAX, uint256 liquidity);\n\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAX(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        uint256 liquidity,\n        uint256 amountAMin,\n        uint256 amountBMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountA, uint256 amountB);\n\n    function removeLiquidityAVAXWithPermit(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactAVAXForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256[] memory amounts);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapAVAXForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256[] memory amounts);\n\n    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);\n\n    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)\n        external\n        pure\n        returns (uint256 amountOut);\n\n    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)\n        external\n        pure\n        returns (uint256 amountIn);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n}\n"
    },
    "contracts/interfaces/joe-v2/IJoeRouter02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\nimport {IJoeRouter01} from \"./IJoeRouter01.sol\";\n\n/// @title Joe V1 Router Interface\n/// @notice Interface to interact with Joe V1 Router\ninterface IJoeRouter02 is IJoeRouter01 {\n    function removeLiquidityAVAXSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountAVAX);\n\n    function removeLiquidityAVAXWithPermitSupportingFeeOnTransferTokens(\n        address token,\n        uint256 liquidity,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        address to,\n        uint256 deadline,\n        bool approveMax,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256 amountAVAX);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable;\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBPair} from \"./ILBPair.sol\";\nimport {IPendingOwnable} from \"./IPendingOwnable.sol\";\n\n/**\n * @title Liquidity Book Factory Interface\n * @author Trader Joe\n * @notice Required interface of LBFactory contract\n */\ninterface ILBFactory is IPendingOwnable {\n    error LBFactory__IdenticalAddresses(IERC20 token);\n    error LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\n    error LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\n    error LBFactory__AddressZero();\n    error LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\n    error LBFactory__LBPairDoesNotExist(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\n    error LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\n    error LBFactory__FlashLoanFeeAboveMax(uint256 fees, uint256 maxFees);\n    error LBFactory__BinStepTooLow(uint256 binStep);\n    error LBFactory__PresetIsLockedForUsers(address user, uint256 binStep);\n    error LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\n    error LBFactory__BinStepHasNoPreset(uint256 binStep);\n    error LBFactory__PresetOpenStateIsAlreadyInTheSameState();\n    error LBFactory__SameFeeRecipient(address feeRecipient);\n    error LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\n    error LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\n    error LBFactory__SameImplementation(address LBPairImplementation);\n    error LBFactory__ImplementationNotSet();\n\n    /**\n     * @dev Structure to store the LBPair information, such as:\n     * binStep: The bin step of the LBPair\n     * LBPair: The address of the LBPair\n     * createdByOwner: Whether the pair was created by the owner of the factory\n     * ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\n     */\n    struct LBPairInformation {\n        uint16 binStep;\n        ILBPair LBPair;\n        bool createdByOwner;\n        bool ignoredForRouting;\n    }\n\n    event LBPairCreated(\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBPair LBPair, uint256 pid\n    );\n\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\n\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n\n    event LBPairIgnoredStateChanged(ILBPair indexed LBPair, bool ignored);\n\n    event PresetSet(\n        uint256 indexed binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator\n    );\n\n    event PresetOpenStateChanged(uint256 indexed binStep, bool indexed isOpen);\n\n    event PresetRemoved(uint256 indexed binStep);\n\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\n\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\n\n    function getMinBinStep() external pure returns (uint256);\n\n    function getFeeRecipient() external view returns (address);\n\n    function getMaxFlashLoanFee() external pure returns (uint256);\n\n    function getFlashLoanFee() external view returns (uint256);\n\n    function getLBPairImplementation() external view returns (address);\n\n    function getNumberOfLBPairs() external view returns (uint256);\n\n    function getLBPairAtIndex(uint256 id) external returns (ILBPair);\n\n    function getNumberOfQuoteAssets() external view returns (uint256);\n\n    function getQuoteAssetAtIndex(uint256 index) external view returns (IERC20);\n\n    function isQuoteAsset(IERC20 token) external view returns (bool);\n\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\n        external\n        view\n        returns (LBPairInformation memory);\n\n    function getPreset(uint256 binStep)\n        external\n        view\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxAccumulator,\n            bool isOpen\n        );\n\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\n\n    function getOpenBinSteps() external view returns (uint256[] memory openBinStep);\n\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\n        external\n        view\n        returns (LBPairInformation[] memory LBPairsBinStep);\n\n    function setLBPairImplementation(address lbPairImplementation) external;\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBPair pair);\n\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external;\n\n    function setPreset(\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        bool isOpen\n    ) external;\n\n    function setPresetOpenState(uint16 binStep, bool isOpen) external;\n\n    function removePreset(uint16 binStep) external;\n\n    function setFeesParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function setFeeRecipient(address feeRecipient) external;\n\n    function setFlashLoanFee(uint256 flashLoanFee) external;\n\n    function addQuoteAsset(IERC20 quoteAsset) external;\n\n    function removeQuoteAsset(IERC20 quoteAsset) external;\n\n    function forceDecay(ILBPair lbPair) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBFlashLoanCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Liquidity Book Flashloan Callback Interface\n/// @author Trader Joe\n/// @notice Required interface to interact with LB flash loans\ninterface ILBFlashLoanCallback {\n    function LBFlashLoanCallback(\n        address sender,\n        IERC20 tokenX,\n        IERC20 tokenY,\n        bytes32 amounts,\n        bytes32 totalFees,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBHookLens.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Factory Interface\n * @author Trader Joe\n * @notice Required interface of LBFactory contract\n */\ninterface ILBHookLens {\n    struct Parameters {\n        address hooks;\n        bool beforeSwap;\n        bool afterSwap;\n        bool beforeFlashLoan;\n        bool afterFlashLoan;\n        bool beforeMint;\n        bool afterMint;\n        bool beforeBurn;\n        bool afterBurn;\n        bool beforeBatchTransferFrom;\n        bool afterBatchTransferFrom;\n    }\n\n    function getHooks(address pair) external view returns (Parameters memory);\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBHooksBaseRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title LB Hooks Base Rewarder Interface\n * @dev Interface for the LB Hooks Base Rewarder\n */\ninterface ILBHooksBaseRewarder {\n    error LBHooksBaseRewarder__InvalidDeltaBins();\n    error LBHooksBaseRewarder__Overflow();\n    error LBHooksBaseRewarder__NativeTransferFailed();\n    error LBHooksBaseRewarder__UnlinkedHooks();\n    error LBHooksBaseRewarder__InvalidHooksParameters();\n    error LBHooksBaseRewarder__ZeroBalance();\n    error LBHooksBaseRewarder__LockedRewardToken();\n    error LBHooksBaseRewarder__NotNativeRewarder();\n    error LBHooksBaseRewarder__NotImplemented();\n    error LBHooksBaseRewarder__UnauthorizedCaller();\n    error LBHooksBaseRewarder__ExceedsMaxNumberOfBins();\n\n    event DeltaBinsSet(int24 deltaBinA, int24 deltaBinB);\n    event Claim(address indexed user, uint256 amount);\n\n    struct Bin {\n        uint256 accRewardsPerShareX64;\n        mapping(address => uint256) userAccRewardsPerShareX64;\n    }\n\n    function getRewardToken() external view returns (IERC20);\n\n    function getLBHooksManager() external view returns (address);\n\n    function isStopped() external view returns (bool);\n\n    function getRewardedRange() external view returns (uint256 binStart, uint256 binEnd);\n\n    function getPendingRewards(address user, uint256[] calldata ids) external view returns (uint256 pendingRewards);\n\n    function claim(address user, uint256[] calldata ids) external;\n\n    function setDeltaBins(int24 deltaBinA, int24 deltaBinB) external;\n\n    function sweep(IERC20 token, address to) external;\n}"
    },
    "contracts/interfaces/joe-v2/ILBLegacyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBLegacyPair} from \"./ILBLegacyPair.sol\";\nimport {IPendingOwnable} from \"./IPendingOwnable.sol\";\n\n/// @title Liquidity Book Factory Interface\n/// @author Trader Joe\n/// @notice Required interface of LBFactory contract\ninterface ILBLegacyFactory is IPendingOwnable {\n    /// @dev Structure to store the LBPair information, such as:\n    /// - binStep: The bin step of the LBPair\n    /// - LBPair: The address of the LBPair\n    /// - createdByOwner: Whether the pair was created by the owner of the factory\n    /// - ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\n    struct LBPairInformation {\n        uint16 binStep;\n        ILBLegacyPair LBPair;\n        bool createdByOwner;\n        bool ignoredForRouting;\n    }\n\n    event LBPairCreated(\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBLegacyPair LBPair, uint256 pid\n    );\n\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\n\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n\n    event FeeParametersSet(\n        address indexed sender,\n        ILBLegacyPair indexed LBPair,\n        uint256 binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator\n    );\n\n    event FactoryLockedStatusUpdated(bool unlocked);\n\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n\n    event LBPairIgnoredStateChanged(ILBLegacyPair indexed LBPair, bool ignored);\n\n    event PresetSet(\n        uint256 indexed binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator,\n        uint256 sampleLifetime\n    );\n\n    event PresetRemoved(uint256 indexed binStep);\n\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\n\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\n\n    function MAX_FEE() external pure returns (uint256);\n\n    function MIN_BIN_STEP() external pure returns (uint256);\n\n    function MAX_BIN_STEP() external pure returns (uint256);\n\n    function MAX_PROTOCOL_SHARE() external pure returns (uint256);\n\n    function LBPairImplementation() external view returns (address);\n\n    function getNumberOfQuoteAssets() external view returns (uint256);\n\n    function getQuoteAsset(uint256 index) external view returns (IERC20);\n\n    function isQuoteAsset(IERC20 token) external view returns (bool);\n\n    function feeRecipient() external view returns (address);\n\n    function flashLoanFee() external view returns (uint256);\n\n    function creationUnlocked() external view returns (bool);\n\n    function allLBPairs(uint256 id) external returns (ILBLegacyPair);\n\n    function getNumberOfLBPairs() external view returns (uint256);\n\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\n        external\n        view\n        returns (LBPairInformation memory);\n\n    function getPreset(uint16 binStep)\n        external\n        view\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxAccumulator,\n            uint256 sampleLifetime\n        );\n\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\n\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\n        external\n        view\n        returns (LBPairInformation[] memory LBPairsBinStep);\n\n    function setLBPairImplementation(address LBPairImplementation) external;\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBLegacyPair pair);\n\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint256 binStep, bool ignored) external;\n\n    function setPreset(\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        uint16 sampleLifetime\n    ) external;\n\n    function removePreset(uint16 binStep) external;\n\n    function setFeesParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function setFeeRecipient(address feeRecipient) external;\n\n    function setFlashLoanFee(uint256 flashLoanFee) external;\n\n    function setFactoryLockedState(bool locked) external;\n\n    function addQuoteAsset(IERC20 quoteAsset) external;\n\n    function removeQuoteAsset(IERC20 quoteAsset) external;\n\n    function forceDecay(ILBLegacyPair LBPair) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBLegacyPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBLegacyToken} from \"./ILBLegacyToken.sol\";\n\n/// @title Liquidity Book Pair V2 Interface\n/// @author Trader Joe\n/// @notice Required interface of LBPair contract\ninterface ILBLegacyPair is ILBLegacyToken {\n    /// @dev Structure to store the protocol fees:\n    /// - binStep: The bin step\n    /// - baseFactor: The base factor\n    /// - filterPeriod: The filter period, where the fees stays constant\n    /// - decayPeriod: The decay period, where the fees are halved\n    /// - reductionFactor: The reduction factor, used to calculate the reduction of the accumulator\n    /// - variableFeeControl: The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// - protocolShare: The share of fees sent to protocol\n    /// - maxVolatilityAccumulated: The max value of volatility accumulated\n    /// - volatilityAccumulated: The value of volatility accumulated\n    /// - volatilityReference: The value of volatility reference\n    /// - indexRef: The index reference\n    /// - time: The last time the accumulator was called\n    struct FeeParameters {\n        // 144 lowest bits in slot\n        uint16 binStep;\n        uint16 baseFactor;\n        uint16 filterPeriod;\n        uint16 decayPeriod;\n        uint16 reductionFactor;\n        uint24 variableFeeControl;\n        uint16 protocolShare;\n        uint24 maxVolatilityAccumulated;\n        // 112 highest bits in slot\n        uint24 volatilityAccumulated;\n        uint24 volatilityReference;\n        uint24 indexRef;\n        uint40 time;\n    }\n\n    /// @dev Structure used during swaps to distributes the fees:\n    /// - total: The total amount of fees\n    /// - protocol: The amount of fees reserved for protocol\n    struct FeesDistribution {\n        uint128 total;\n        uint128 protocol;\n    }\n\n    /// @dev Structure to store the reserves of bins:\n    /// - reserveX: The current reserve of tokenX of the bin\n    /// - reserveY: The current reserve of tokenY of the bin\n    struct Bin {\n        uint112 reserveX;\n        uint112 reserveY;\n        uint256 accTokenXPerShare;\n        uint256 accTokenYPerShare;\n    }\n\n    /// @dev Structure to store the information of the pair such as:\n    /// slot0:\n    /// - activeId: The current id used for swaps, this is also linked with the price\n    /// - reserveX: The sum of amounts of tokenX across all bins\n    /// slot1:\n    /// - reserveY: The sum of amounts of tokenY across all bins\n    /// - oracleSampleLifetime: The lifetime of an oracle sample\n    /// - oracleSize: The current size of the oracle, can be increase by users\n    /// - oracleActiveSize: The current active size of the oracle, composed only from non empty data sample\n    /// - oracleLastTimestamp: The current last timestamp at which a sample was added to the circular buffer\n    /// - oracleId: The current id of the oracle\n    /// slot2:\n    /// - feesX: The current amount of fees to distribute in tokenX (total, protocol)\n    /// slot3:\n    /// - feesY: The current amount of fees to distribute in tokenY (total, protocol)\n    struct PairInformation {\n        uint24 activeId;\n        uint136 reserveX;\n        uint136 reserveY;\n        uint16 oracleSampleLifetime;\n        uint16 oracleSize;\n        uint16 oracleActiveSize;\n        uint40 oracleLastTimestamp;\n        uint16 oracleId;\n        FeesDistribution feesX;\n        FeesDistribution feesY;\n    }\n\n    /// @dev Structure to store the debts of users\n    /// - debtX: The tokenX's debt\n    /// - debtY: The tokenY's debt\n    struct Debts {\n        uint256 debtX;\n        uint256 debtY;\n    }\n\n    /// @dev Structure to store fees:\n    /// - tokenX: The amount of fees of token X\n    /// - tokenY: The amount of fees of token Y\n    struct Fees {\n        uint128 tokenX;\n        uint128 tokenY;\n    }\n\n    /// @dev Structure to minting informations:\n    /// - amountXIn: The amount of token X sent\n    /// - amountYIn: The amount of token Y sent\n    /// - amountXAddedToPair: The amount of token X that have been actually added to the pair\n    /// - amountYAddedToPair: The amount of token Y that have been actually added to the pair\n    /// - activeFeeX: Fees X currently generated\n    /// - activeFeeY: Fees Y currently generated\n    /// - totalDistributionX: Total distribution of token X. Should be 1e18 (100%) or 0 (0%)\n    /// - totalDistributionY: Total distribution of token Y. Should be 1e18 (100%) or 0 (0%)\n    /// - id: Id of the current working bin when looping on the distribution array\n    /// - amountX: The amount of token X deposited in the current bin\n    /// - amountY: The amount of token Y deposited in the current bin\n    /// - distributionX: Distribution of token X for the current working bin\n    /// - distributionY: Distribution of token Y for the current working bin\n    struct MintInfo {\n        uint256 amountXIn;\n        uint256 amountYIn;\n        uint256 amountXAddedToPair;\n        uint256 amountYAddedToPair;\n        uint256 activeFeeX;\n        uint256 activeFeeY;\n        uint256 totalDistributionX;\n        uint256 totalDistributionY;\n        uint256 id;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 distributionX;\n        uint256 distributionY;\n    }\n\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed id,\n        bool swapForY,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 volatilityAccumulated,\n        uint256 fees\n    );\n\n    event FlashLoan(address indexed sender, address indexed receiver, IERC20 token, uint256 amount, uint256 fee);\n\n    event CompositionFee(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 feesX, uint256 feesY\n    );\n\n    event DepositedToBin(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 amountX, uint256 amountY\n    );\n\n    event WithdrawnFromBin(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 amountX, uint256 amountY\n    );\n\n    event FeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event ProtocolFeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event OracleSizeIncreased(uint256 previousSize, uint256 newSize);\n\n    function tokenX() external view returns (IERC20);\n\n    function tokenY() external view returns (IERC20);\n\n    function factory() external view returns (address);\n\n    function getReservesAndId() external view returns (uint256 reserveX, uint256 reserveY, uint256 activeId);\n\n    function getGlobalFees()\n        external\n        view\n        returns (uint128 feesXTotal, uint128 feesYTotal, uint128 feesXProtocol, uint128 feesYProtocol);\n\n    function getOracleParameters()\n        external\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        );\n\n    function getOracleSampleFrom(uint256 timeDelta)\n        external\n        view\n        returns (uint256 cumulativeId, uint256 cumulativeAccumulator, uint256 cumulativeBinCrossed);\n\n    function feeParameters() external view returns (FeeParameters memory);\n\n    function findFirstNonEmptyBinId(uint24 id_, bool sentTokenY) external view returns (uint24 id);\n\n    function getBin(uint24 id) external view returns (uint256 reserveX, uint256 reserveY);\n\n    function pendingFees(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 amountX, uint256 amountY);\n\n    function swap(bool sentTokenY, address to) external returns (uint256 amountXOut, uint256 amountYOut);\n\n    function flashLoan(address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n\n    function mint(\n        uint256[] calldata ids,\n        uint256[] calldata distributionX,\n        uint256[] calldata distributionY,\n        address to\n    ) external returns (uint256 amountXAddedToPair, uint256 amountYAddedToPair, uint256[] memory liquidityMinted);\n\n    function burn(uint256[] calldata ids, uint256[] calldata amounts, address to)\n        external\n        returns (uint256 amountX, uint256 amountY);\n\n    function increaseOracleLength(uint16 newSize) external;\n\n    function collectFees(address account, uint256[] calldata ids) external returns (uint256 amountX, uint256 amountY);\n\n    function collectProtocolFees() external returns (uint128 amountX, uint128 amountY);\n\n    function setFeesParameters(bytes32 packedFeeParameters) external;\n\n    function forceDecay() external;\n\n    function initialize(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint24 activeId,\n        uint16 sampleLifetime,\n        bytes32 packedFeeParameters\n    ) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBLegacyRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {IJoeFactory} from \"./IJoeFactory.sol\";\nimport {ILBLegacyPair} from \"./ILBLegacyPair.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\nimport {IWNATIVE} from \"./IWNATIVE.sol\";\n\n/// @title Liquidity Book Router Interface\n/// @author Trader Joe\n/// @notice Required interface of LBRouter contract\ninterface ILBLegacyRouter {\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        uint256 deadline;\n    }\n\n    function factory() external view returns (address);\n\n    function wavax() external view returns (address);\n\n    function oldFactory() external view returns (address);\n\n    function getIdFromPrice(ILBLegacyPair LBPair, uint256 price) external view returns (uint24);\n\n    function getPriceFromId(ILBLegacyPair LBPair, uint24 id) external view returns (uint256);\n\n    function getSwapIn(ILBLegacyPair lbPair, uint256 amountOut, bool swapForY)\n        external\n        view\n        returns (uint256 amountIn, uint256 feesIn);\n\n    function getSwapOut(ILBLegacyPair lbPair, uint256 amountIn, bool swapForY)\n        external\n        view\n        returns (uint256 amountOut, uint256 feesIn);\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBLegacyPair pair);\n\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function addLiquidityAVAX(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function removeLiquidityAVAX(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amountsIn);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function sweep(IERC20 token, address to, uint256 amount) external;\n\n    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n        external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBLegacyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/// @title Liquidity Book V2 Token Interface\n/// @author Trader Joe\n/// @notice Required interface of LBToken contract\ninterface ILBLegacyToken is IERC165 {\n    event TransferSingle(address indexed sender, address indexed from, address indexed to, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory batchBalances);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function setApprovalForAll(address sender, bool approved) external;\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount) external;\n\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata id, uint256[] calldata amount)\n        external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {ILBFlashLoanCallback} from \"./ILBFlashLoanCallback.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\n\ninterface ILBPair is ILBToken {\n    error LBPair__ZeroBorrowAmount();\n    error LBPair__AddressZero();\n    error LBPair__AlreadyInitialized();\n    error LBPair__EmptyMarketConfigs();\n    error LBPair__FlashLoanCallbackFailed();\n    error LBPair__FlashLoanInsufficientAmount();\n    error LBPair__InsufficientAmountIn();\n    error LBPair__InsufficientAmountOut();\n    error LBPair__InvalidInput();\n    error LBPair__InvalidStaticFeeParameters();\n    error LBPair__OnlyFactory();\n    error LBPair__OnlyProtocolFeeRecipient();\n    error LBPair__OutOfLiquidity();\n    error LBPair__TokenNotSupported();\n    error LBPair__ZeroAmount(uint24 id);\n    error LBPair__ZeroAmountsOut(uint24 id);\n    error LBPair__ZeroShares(uint24 id);\n    error LBPair__MaxTotalFeeExceeded();\n\n    struct MintArrays {\n        uint256[] ids;\n        bytes32[] amounts;\n        uint256[] liquidityMinted;\n    }\n\n    event DepositedToBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\n\n    event WithdrawnFromBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\n\n    event CompositionFees(address indexed sender, uint24 id, bytes32 totalFees, bytes32 protocolFees);\n\n    event CollectedProtocolFees(address indexed feeRecipient, bytes32 protocolFees);\n\n    event Swap(\n        address indexed sender,\n        address indexed to,\n        uint24 id,\n        bytes32 amountsIn,\n        bytes32 amountsOut,\n        uint24 volatilityAccumulator,\n        bytes32 totalFees,\n        bytes32 protocolFees\n    );\n\n    event StaticFeeParametersSet(\n        address indexed sender,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    );\n\n    event FlashLoan(\n        address indexed sender,\n        ILBFlashLoanCallback indexed receiver,\n        uint24 activeId,\n        bytes32 amounts,\n        bytes32 totalFees,\n        bytes32 protocolFees\n    );\n\n    event OracleLengthIncreased(address indexed sender, uint16 oracleLength);\n\n    event ForcedDecay(address indexed sender, uint24 idReference, uint24 volatilityReference);\n\n    function initialize(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        uint24 activeId\n    ) external;\n\n    function getFactory() external view returns (ILBFactory factory);\n\n    function getTokenX() external view returns (IERC20 tokenX);\n\n    function getTokenY() external view returns (IERC20 tokenY);\n\n    function getBinStep() external view returns (uint16 binStep);\n\n    function getReserves() external view returns (uint128 reserveX, uint128 reserveY);\n\n    function getActiveId() external view returns (uint24 activeId);\n\n    function getBin(uint24 id) external view returns (uint128 binReserveX, uint128 binReserveY);\n\n    function getNextNonEmptyBin(bool swapForY, uint24 id) external view returns (uint24 nextId);\n\n    function getProtocolFees() external view returns (uint128 protocolFeeX, uint128 protocolFeeY);\n\n    function getStaticFeeParameters()\n        external\n        view\n        returns (\n            uint16 baseFactor,\n            uint16 filterPeriod,\n            uint16 decayPeriod,\n            uint16 reductionFactor,\n            uint24 variableFeeControl,\n            uint16 protocolShare,\n            uint24 maxVolatilityAccumulator\n        );\n\n    function getLBHooksParameters() external view returns (bytes32 hooksParameters);\n\n    function getVariableFeeParameters()\n        external\n        view\n        returns (uint24 volatilityAccumulator, uint24 volatilityReference, uint24 idReference, uint40 timeOfLastUpdate);\n\n    function getOracleParameters()\n        external\n        view\n        returns (uint8 sampleLifetime, uint16 size, uint16 activeSize, uint40 lastUpdated, uint40 firstTimestamp);\n\n    function getOracleSampleAt(uint40 lookupTimestamp)\n        external\n        view\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed);\n\n    function getPriceFromId(uint24 id) external view returns (uint256 price);\n\n    function getIdFromPrice(uint256 price) external view returns (uint24 id);\n\n    function getSwapIn(uint128 amountOut, bool swapForY)\n        external\n        view\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n\n    function getSwapOut(uint128 amountIn, bool swapForY)\n        external\n        view\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n\n    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);\n\n    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\n\n    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\n        external\n        returns (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted);\n\n    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n        external\n        returns (bytes32[] memory amounts);\n\n    function collectProtocolFees() external returns (bytes32 collectedProtocolFees);\n\n    function increaseOracleLength(uint16 newLength) external;\n\n    function setStaticFeeParameters(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function forceDecay() external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IJoeFactory} from \"./IJoeFactory.sol\";\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {ILBLegacyFactory} from \"./ILBLegacyFactory.sol\";\nimport {ILBLegacyRouter} from \"./ILBLegacyRouter.sol\";\nimport {ILBPair} from \"./ILBPair.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\nimport {IWNATIVE} from \"./IWNATIVE.sol\";\n\n/**\n * @title Liquidity Book Router Interface\n * @author Trader Joe\n * @notice Required interface of LBRouter contract\n */\ninterface ILBRouter {\n    error LBRouter__SenderIsNotWNATIVE();\n    error LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\n    error LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\n    error LBRouter__SwapOverflows(uint256 id);\n    error LBRouter__BrokenSwapSafetyCheck();\n    error LBRouter__NotFactoryOwner();\n    error LBRouter__TooMuchTokensIn(uint256 excess);\n    error LBRouter__BinReserveOverflows(uint256 id);\n    error LBRouter__IdOverflows(int256 id);\n    error LBRouter__LengthsMismatch();\n    error LBRouter__WrongTokenOrder();\n    error LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\n    error LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\n    error LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\n    error LBRouter__FailedToSendNATIVE(address recipient, uint256 amount);\n    error LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\n    error LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\n    error LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\n    error LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\n    error LBRouter__InvalidTokenPath(address wrongToken);\n    error LBRouter__InvalidVersion(uint256 version);\n    error LBRouter__WrongNativeLiquidityParameters(\n        address tokenX, address tokenY, uint256 amountX, uint256 amountY, uint256 msgValue\n    );\n\n    /**\n     * @dev This enum represents the version of the pair requested\n     * - V1: Joe V1 pair\n     * - V2: LB pair V2. Also called legacyPair\n     * - V2_1: LB pair V2.1\n     * - V2_2: LB pair V2.2 (current version)\n     */\n    enum Version {\n        V1,\n        V2,\n        V2_1,\n        V2_2\n    }\n\n    /**\n     * @dev The liquidity parameters, such as:\n     * - tokenX: The address of token X\n     * - tokenY: The address of token Y\n     * - binStep: The bin step of the pair\n     * - amountX: The amount to send of token X\n     * - amountY: The amount to send of token Y\n     * - amountXMin: The min amount of token X added to liquidity\n     * - amountYMin: The min amount of token Y added to liquidity\n     * - activeIdDesired: The active id that user wants to add liquidity from\n     * - idSlippage: The number of id that are allowed to slip\n     * - deltaIds: The list of delta ids to add liquidity (`deltaId = activeId - desiredId`)\n     * - distributionX: The distribution of tokenX with sum(distributionX) = 1e18 (100%) or 0 (0%)\n     * - distributionY: The distribution of tokenY with sum(distributionY) = 1e18 (100%) or 0 (0%)\n     * - to: The address of the recipient\n     * - refundTo: The address of the recipient of the refunded tokens if too much tokens are sent\n     * - deadline: The deadline of the transaction\n     */\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        address refundTo;\n        uint256 deadline;\n    }\n\n    /**\n     * @dev The path parameters, such as:\n     * - pairBinSteps: The list of bin steps of the pairs to go through\n     * - versions: The list of versions of the pairs to go through\n     * - tokenPath: The list of tokens in the path to go through\n     */\n    struct Path {\n        uint256[] pairBinSteps;\n        Version[] versions;\n        IERC20[] tokenPath;\n    }\n\n    function getFactory() external view returns (ILBFactory);\n\n    function getFactoryV2_1() external view returns (ILBFactory);\n\n    function getLegacyFactory() external view returns (ILBLegacyFactory);\n\n    function getV1Factory() external view returns (IJoeFactory);\n\n    function getLegacyRouter() external view returns (ILBLegacyRouter);\n\n    function getWNATIVE() external view returns (IWNATIVE);\n\n    function getIdFromPrice(ILBPair LBPair, uint256 price) external view returns (uint24);\n\n    function getPriceFromId(ILBPair LBPair, uint24 id) external view returns (uint256);\n\n    function getSwapIn(ILBPair LBPair, uint128 amountOut, bool swapForY)\n        external\n        view\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n\n    function getSwapOut(ILBPair LBPair, uint128 amountIn, bool swapForY)\n        external\n        view\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBPair pair);\n\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        );\n\n    function addLiquidityNATIVE(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        );\n\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function removeLiquidityNATIVE(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountNATIVEMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountNATIVE);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForNATIVE(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactNATIVEForTokens(uint256 amountOutMin, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapTokensForExactNATIVE(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapNATIVEForExactTokens(uint256 amountOut, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256[] memory amountsIn);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForNATIVESupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactNATIVEForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function sweep(IERC20 token, address to, uint256 amount) external;\n\n    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n        external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Token Interface\n * @author Trader Joe\n * @notice Interface to interact with the LBToken.\n */\ninterface ILBToken {\n    error LBToken__AddressThisOrZero();\n    error LBToken__InvalidLength();\n    error LBToken__SelfApproval(address owner);\n    error LBToken__SpenderNotApproved(address from, address spender);\n    error LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\n    error LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function approveForAll(address spender, bool approved) external;\n\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/IPendingOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Pending Ownable Interface\n * @author Trader Joe\n * @notice Required interface of Pending Ownable contract used for LBFactory\n */\ninterface IPendingOwnable {\n    error PendingOwnable__AddressZero();\n    error PendingOwnable__NoPendingOwner();\n    error PendingOwnable__NotOwner();\n    error PendingOwnable__NotPendingOwner();\n    error PendingOwnable__PendingOwnerAlreadySet();\n\n    event PendingOwnerSet(address indexed pendingOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function setPendingOwner(address pendingOwner) external;\n\n    function revokePendingOwner() external;\n\n    function becomeOwner() external;\n\n    function renounceOwnership() external;\n}\n"
    },
    "contracts/interfaces/joe-v2/IRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IRewarder {\n    /**\n     * @dev Structure to store the Merkle tree entry. It contains:\n     * - `market` is the address of the market.\n     * - `epoch` is the epoch of the market.\n     * - `token` is the token address of the market.\n     * - `user` is the user address.\n     * - `amount` is the amount of tokens to be claimed.\n     * - `merkleProof` is the Merkle proof of the claim.\n     */\n    struct MerkleEntry {\n        address market;\n        uint256 epoch;\n        IERC20 token;\n        address user;\n        uint256 amount;\n        bytes32[] merkleProof;\n    }\n\n    function batchClaim(MerkleEntry[] calldata merkleEntries) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/IWNATIVE.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title WNATIVE Interface\n * @notice Required interface of Wrapped NATIVE contract\n */\ninterface IWNATIVE is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/interfaces/SmartLoanGigaChadInterface.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"./facets/avalanche/IYieldYakFacet.sol\";\nimport \"./facets/avalanche/IGMDFacet.sol\";\nimport \"./facets/avalanche/IYieldYakSwapFacet.sol\";\nimport \"./facets/avalanche/IParaSwapFacet.sol\";\nimport \"./facets/avalanche/ICaiFacet.sol\";\nimport \"./facets/avalanche/IGLPFacet.sol\";\nimport \"./facets/avalanche/IPangolinDEXFacet.sol\";\nimport \"./facets/avalanche/ITraderJoeDEXFacet.sol\";\nimport \"./facets/IUniswapV2DEXFacet.sol\";\nimport \"./facets/IAssetsOperationsFacet.sol\";\nimport \"./facets/IOwnershipFacet.sol\";\nimport \"./facets/ISmartLoanViewFacet.sol\";\nimport \"./facets/ISmartLoanLiquidationFacet.sol\";\nimport \"./facets/ISmartLoanWrappedNativeTokenFacet.sol\";\nimport \"./facets/ISolvencyFacetProd.sol\";\nimport \"./facets/IHealthMeterFacetProd.sol\";\nimport \"./IDiamondLoupe.sol\";\nimport \"./facets/celo/IUbeswapDEXFacet.sol\";\nimport \"./facets/IGmxV2Facet.sol\";\nimport \"./facets/IGmxV2PlusFacet.sol\";\nimport \"./facets/avalanche/IVectorFinanceFacet.sol\";\nimport \"./facets/avalanche/IVectorFinanceFacetOld.sol\";\nimport \"./facets/avalanche/IBeefyFinanceFacet.sol\";\nimport \"./facets/avalanche/ICurveFacet.sol\";\nimport \"./facets/avalanche/ISteakHutFinanceFacet.sol\";\nimport \"./facets/avalanche/ITraderJoeV2Facet.sol\";\nimport \"./facets/avalanche/IUniswapV3Facet.sol\";\nimport \"./facets/avalanche/ITraderJoeV2AutopoolsFacet.sol\";\nimport \"./facets/avalanche/IBalancerV2Facet.sol\";\nimport \"./facets/avalanche/IGogoPoolFacet.sol\";\nimport \"./facets/arbitrum/ISushiSwapDEXFacet.sol\";\nimport \"./facets/arbitrum/IBeefyFinanceArbitrumFacet.sol\";\nimport \"./facets/arbitrum/ISushiSwapFacet.sol\";\nimport \"./facets/arbitrum/ILevelFinanceFacet.sol\";\nimport \"./facets/arbitrum/IPenpieFacet.sol\";\nimport \"./facets/arbitrum/ILTIPFacet.sol\";\nimport \"./facets/avalanche/IWombatFacet.sol\";\nimport \"./facets/avalanche/IYieldYakWombatFacet.sol\";\n\ninterface SmartLoanGigaChadInterface is\n    IGMDFacet,\n    IHealthMeterFacetProd,\n    IGLPFacet,\n    IYieldYakSwapFacet,\n    IParaSwapFacet,\n    ICaiFacet,\n    IDiamondLoupe,\n    IBeefyFinanceFacet,\n    IBeefyFinanceArbitrumFacet,\n    ISushiSwapFacet,\n    ILevelFinanceFacet,\n    IPenpieFacet,\n    ILTIPFacet,\n    IWombatFacet,\n    IYieldYakWombatFacet,\n    ISmartLoanWrappedNativeTokenFacet,\n    IPangolinDEXFacet,\n    IUniswapV2DEXFacet,\n    IAssetsOperationsFacet,\n    IOwnershipFacet,\n    ISmartLoanLiquidationFacet,\n    ISmartLoanViewFacet,\n    ISolvencyFacetProd,\n    IYieldYakFacet,\n    IVectorFinanceFacet,\n    IVectorFinanceFacetOld,\n    IUbeswapDEXFacet,\n    ITraderJoeDEXFacet,\n    ICurveFacet,\n    ISteakHutFinanceFacet,\n    ITraderJoeV2Facet,\n    IUniswapV3Facet,\n    ITraderJoeV2AutopoolsFacet,\n    ISushiSwapDEXFacet,\n    IGmxV2Facet,\n    IGmxV2PlusFacet,\n    IBalancerV2Facet,\n    IGogoPoolFacet\n{}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '../../lib/uniswap-v3/PoolAddress.sol';\nimport './IPeripheryImmutableState.sol';\nimport '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\n/// @title Non-fungible token for positions\n/// @notice Wraps Uniswap V3 positions in a non-fungible token interface which allows for them to be transferred\n/// and authorized.\ninterface INonfungiblePositionManager is IPeripheryImmutableState, IERC721\n{\n    /// @notice Emitted when liquidity is increased for a position NFT\n    /// @dev Also emitted when a token is minted\n    /// @param tokenId The ID of the token for which liquidity was increased\n    /// @param liquidity The amount by which liquidity for the NFT position was increased\n    /// @param amount0 The amount of token0 that was paid for the increase in liquidity\n    /// @param amount1 The amount of token1 that was paid for the increase in liquidity\n    event IncreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when liquidity is decreased for a position NFT\n    /// @param tokenId The ID of the token for which liquidity was decreased\n    /// @param liquidity The amount by which liquidity for the NFT position was decreased\n    /// @param amount0 The amount of token0 that was accounted for the decrease in liquidity\n    /// @param amount1 The amount of token1 that was accounted for the decrease in liquidity\n    event DecreaseLiquidity(uint256 indexed tokenId, uint128 liquidity, uint256 amount0, uint256 amount1);\n    /// @notice Emitted when tokens are collected for a position NFT\n    /// @dev The amounts reported may not be exactly equivalent to the amounts transferred, due to rounding behavior\n    /// @param tokenId The ID of the token for which underlying tokens were collected\n    /// @param recipient The address of the account that received the collected tokens\n    /// @param amount0 The amount of token0 owed to the position that was collected\n    /// @param amount1 The amount of token1 owed to the position that was collected\n    event Collect(uint256 indexed tokenId, address recipient, uint256 amount0, uint256 amount1);\n\n    /// @notice Returns the position information associated with a given token ID.\n    /// @dev Throws if the token ID is not valid.\n    /// @param tokenId The ID of the token that represents the position\n    /// @return nonce The nonce for permits\n    /// @return operator The address that is approved for spending\n    /// @return token0 The address of the token0 for a specific pool\n    /// @return token1 The address of the token1 for a specific pool\n    /// @return fee The fee associated with the pool\n    /// @return tickLower The lower end of the tick range for the position\n    /// @return tickUpper The higher end of the tick range for the position\n    /// @return liquidity The liquidity of the position\n    /// @return feeGrowthInside0LastX128 The fee growth of token0 as of the last action on the individual position\n    /// @return feeGrowthInside1LastX128 The fee growth of token1 as of the last action on the individual position\n    /// @return tokensOwed0 The uncollected amount of token0 owed to the position as of the last computation\n    /// @return tokensOwed1 The uncollected amount of token1 owed to the position as of the last computation\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            uint96 nonce,\n            address operator,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n        \n    struct MintParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        address recipient;\n        uint256 deadline;\n    }\n\n    /// @notice Creates a new position wrapped in a NFT\n    /// @dev Call this when the pool does exist and is initialized. Note that if the pool is created but not initialized\n    /// a method does not exist, i.e. the pool is assumed to be initialized.\n    /// @param params The params necessary to mint a position, encoded as `MintParams` in calldata\n    /// @return tokenId The ID of the token that represents the minted position\n    /// @return liquidity The amount of liquidity for this position\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function mint(MintParams calldata params)\n        external\n        payable\n        returns (\n            uint256 tokenId,\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Increases the amount of liquidity in a position, with tokens paid by the `msg.sender`\n    /// @param params tokenId The ID of the token for which liquidity is being increased,\n    /// amount0Desired The desired amount of token0 to be spent,\n    /// amount1Desired The desired amount of token1 to be spent,\n    /// amount0Min The minimum amount of token0 to spend, which serves as a slippage check,\n    /// amount1Min The minimum amount of token1 to spend, which serves as a slippage check,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return liquidity The new liquidity amount as a result of the increase\n    /// @return amount0 The amount of token0 to acheive resulting liquidity\n    /// @return amount1 The amount of token1 to acheive resulting liquidity\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (\n            uint128 liquidity,\n            uint256 amount0,\n            uint256 amount1\n        );\n\n    struct DecreaseLiquidityParams {\n        uint256 tokenId;\n        uint128 liquidity;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    /// @notice Decreases the amount of liquidity in a position and accounts it to the position\n    /// @param params tokenId The ID of the token for which liquidity is being decreased,\n    /// amount The amount by which liquidity will be decreased,\n    /// amount0Min The minimum amount of token0 that should be accounted for the burned liquidity,\n    /// amount1Min The minimum amount of token1 that should be accounted for the burned liquidity,\n    /// deadline The time by which the transaction must be included to effect the change\n    /// @return amount0 The amount of token0 accounted to the position's tokens owed\n    /// @return amount1 The amount of token1 accounted to the position's tokens owed\n    function decreaseLiquidity(DecreaseLiquidityParams calldata params)\n        external\n        payable\n        returns (uint256 amount0, uint256 amount1);\n\n    struct CollectParams {\n        uint256 tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(CollectParams calldata params) external payable returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Burns a token ID, which deletes it from the NFT contract. The token must have 0 liquidity and all tokens\n    /// must be collected first.\n    /// @param tokenId The ID of the token that is being burned\n    function burn(uint256 tokenId) external payable;\n}\n"
    },
    "contracts/interfaces/uniswap-v3-periphery/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/callback/IUniswapV3FlashCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#flash\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\ninterface IUniswapV3FlashCallback {\n    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\n    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\n    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\n    function uniswapV3FlashCallback(\n        uint256 fee0,\n        uint256 fee1,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n    /// @notice Returns the balance of a token\n    /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n    /// @return The number of tokens held by the account\n    function balanceOf(address account) external view returns (uint256);\n\n    /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n    /// @param recipient The account that will receive the amount transferred\n    /// @param amount The number of tokens to send from the sender to the recipient\n    /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /// @notice Returns the current allowance given to a spender by an owner\n    /// @param owner The account of the token owner\n    /// @param spender The account of the token spender\n    /// @return The current allowance granted by `owner` to `spender`\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n    /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n    /// @param amount The amount of tokens allowed to be used by `spender`\n    /// @return Returns true for a successful approval, false for unsuccessful\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n    /// @param sender The account from which the transfer will be initiated\n    /// @param recipient The recipient of the transfer\n    /// @param amount The amount of the transfer\n    /// @return Returns true for a successful transfer, false for unsuccessful\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n    /// @param from The account from which the tokens were sent, i.e. the balance decreased\n    /// @param to The account to which the tokens were sent, i.e. the balance increased\n    /// @param value The amount of tokens that were transferred\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n    /// @param owner The account that approved spending of its tokens\n    /// @param spender The account for which the spending allowance was modified\n    /// @param value The new allowance from the owner to the spender\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport './IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools\n/// @notice A contract that constructs a pool must implement this to pass arguments to the pool\n/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash\n/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain\ninterface IUniswapV3PoolDeployer {\n    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.\n    /// @dev Called by the pool constructor to fetch the parameters of the pool\n    /// Returns factory The factory address\n    /// Returns token0 The first token of the pool by address sort order\n    /// Returns token1 The second token of the pool by address sort order\n    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// Returns tickSpacing The minimum number of ticks between initialized ticks\n    function parameters()\n        external\n        view\n        returns (\n            address factory,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickSpacing\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/interfaces/uniswap-v3/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "contracts/interfaces/uniswap-v3/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/interfaces/uniswap-v3/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "contracts/lib/arbitrum/DeploymentConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../../interfaces/ITokenManager.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n/**\n * DeploymentConstants\n * These constants are updated during test and prod deployments using JS scripts. Defined as constants\n * to decrease gas costs. Not meant to be updated unless really necessary.\n * BE CAREFUL WHEN UPDATING. CONSTANTS CAN BE USED AMONG MANY FACETS.\n **/\nlibrary DeploymentConstants {\n\n    // Used for LiquidationBonus calculations\n    uint256 private constant _PERCENTAGE_PRECISION = 1000;\n\n    bytes32 private constant _NATIVE_TOKEN_SYMBOL = 'ETH';\n\n    address private constant _NATIVE_ADDRESS = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n\n    address private constant _DIAMOND_BEACON_ADDRESS = 0x62Cf82FB0484aF382714cD09296260edc1DC0c6c;\n\n    address private constant _SMART_LOANS_FACTORY_ADDRESS = 0xFf5e3dDaefF411a1dC6CcE00014e4Bca39265c20;\n\n    address private constant _TOKEN_MANAGER_ADDRESS = 0x0a0D954d4b0F0b47a5990C0abd179A90fF74E255;\n\n    address private constant _ADDRESS_PROVIDER = 0x6Aa0Fe94731aDD419897f5783712eBc13E8F3982;\n\n    address private constant _FEES_TREASURY_ADDREESS = 0x764a9756994f4E6cd9358a6FcD924d566fC2e666;\n\n    address private constant _STABILITY_POOL_ADDREESS = 0x6B9836D18978a2e865A935F12F4f958317DA4619;\n\n    address private constant _FEES_REDISTRIBUTION_ADDREESS = 0x5e7d3d4F744378C2259bb6C52fbF247be473860D;\n\n    //implementation-specific\n\n    function getPercentagePrecision() internal pure returns (uint256) {\n        return _PERCENTAGE_PRECISION;\n    }\n\n    //blockchain-specific\n\n    function getNativeTokenSymbol() internal pure returns (bytes32 symbol) {\n        return _NATIVE_TOKEN_SYMBOL;\n    }\n\n    function getNativeToken() internal pure returns (address payable) {\n        return payable(_NATIVE_ADDRESS);\n    }\n\n    //deployment-specific\n\n    function getDiamondAddress() internal pure returns (address) {\n        return _DIAMOND_BEACON_ADDRESS;\n    }\n\n    function getSmartLoansFactoryAddress() internal pure returns (address) {\n        return _SMART_LOANS_FACTORY_ADDRESS;\n    }\n\n    function getTokenManager() internal pure returns (ITokenManager) {\n        return ITokenManager(_TOKEN_MANAGER_ADDRESS);\n    }\n\n    function getAddressProvider() internal pure returns (address) {\n        return _ADDRESS_PROVIDER;\n    }\n\n    function getTreasuryAddress() internal pure returns (address) {\n        return _FEES_TREASURY_ADDREESS;\n    }\n\n    function getStabilityPoolAddress() internal pure returns (address) {\n        return _STABILITY_POOL_ADDREESS;\n    }\n\n    function getFeesRedistributionAddress() internal pure returns (address) {\n        return _FEES_REDISTRIBUTION_ADDREESS;\n    }\n\n    /**\n    * Returns all owned assets keys\n    **/\n    function getAllOwnedAssets() internal view returns (bytes32[] memory result) {\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\n        return sls.ownedAssets._inner._keys._inner._values;\n    }\n}"
    },
    "contracts/lib/avalanche/DeploymentConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"../../interfaces/ITokenManager.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n/**\n * DeploymentConstants\n * These constants are updated during test and prod deployments using JS scripts. Defined as constants\n * to decrease gas costs. Not meant to be updated unless really necessary.\n * BE CAREFUL WHEN UPDATING. CONSTANTS CAN BE USED AMONG MANY FACETS.\n **/\nlibrary DeploymentConstants {\n\n    // Used for LiquidationBonus calculations\n    uint256 private constant _PERCENTAGE_PRECISION = 1000;\n\n    bytes32 private constant _NATIVE_TOKEN_SYMBOL = 'AVAX';\n\n    address private constant _NATIVE_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    address private constant _DIAMOND_BEACON_ADDRESS = 0x2916B3bf7C35bd21e63D01C93C62FB0d4994e56D;\n\n    address private constant _SMART_LOANS_FACTORY_ADDRESS = 0x3Ea9D480295A73fd2aF95b4D96c2afF88b21B03D;\n\n    address private constant _TOKEN_MANAGER_ADDRESS = 0xF3978209B7cfF2b90100C6F87CEC77dE928Ed58e;\n\n    address private constant _ADDRESS_PROVIDER = address(0);\n\n    address private constant _FEES_TREASURY_ADDREESS = 0x18C244c62372dF1b933CD455769f9B4DdB820F0C;\n\n    address private constant _STABILITY_POOL_ADDREESS = 0x8Ac151296Ae72a8AeE01ECB33cd8Ad9842F2704f;\n\n    address private constant _FEES_REDISTRIBUTION_ADDREESS = 0x8995d790169023Ee4fF67621948EBDFe7383f59e;\n\n    //implementation-specific\n\n    function getPercentagePrecision() internal pure returns (uint256) {\n        return _PERCENTAGE_PRECISION;\n    }\n\n    //blockchain-specific\n\n    function getNativeTokenSymbol() internal pure returns (bytes32 symbol) {\n        return _NATIVE_TOKEN_SYMBOL;\n    }\n\n    function getNativeToken() internal pure returns (address payable) {\n        return payable(_NATIVE_ADDRESS);\n    }\n\n    //deployment-specific\n\n    function getDiamondAddress() internal pure returns (address) {\n        return _DIAMOND_BEACON_ADDRESS;\n    }\n\n    function getSmartLoansFactoryAddress() internal pure returns (address) {\n        return _SMART_LOANS_FACTORY_ADDRESS;\n    }\n\n    function getTokenManager() internal pure returns (ITokenManager) {\n        return ITokenManager(_TOKEN_MANAGER_ADDRESS);\n    }\n\n    function getAddressProvider() internal pure returns (address) {\n        return _ADDRESS_PROVIDER;\n    }\n\n    function getTreasuryAddress() internal pure returns (address) {\n        return _FEES_TREASURY_ADDREESS;\n    }\n\n    function getStabilityPoolAddress() internal pure returns (address) {\n        return _STABILITY_POOL_ADDREESS;\n    }\n\n    function getFeesRedistributionAddress() internal pure returns (address) {\n        return _FEES_REDISTRIBUTION_ADDREESS;\n    }\n\n    /**\n    * Returns all owned assets keys\n    **/\n    function getAllOwnedAssets() internal view returns (bytes32[] memory result) {\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\n        return sls.ownedAssets._inner._keys._inner._values;\n    }\n}"
    },
    "contracts/lib/avalanche/ParaSwapLib.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\nlibrary ParaSwapLib {\n    struct SimpleData {\n        address fromToken;\n        address toToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address[] callees;\n        bytes exchangeData;\n        uint256[] startIndexes;\n        uint256[] values;\n        address payable beneficiary;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct Route {\n        uint256 index; //Adapter at which index needs to be used\n        address targetExchange;\n        uint256 percent;\n        bytes payload;\n        uint256 networkFee; //NOT USED - Network fee is associated with 0xv3 trades\n    }\n\n    struct Adapter {\n        address payable adapter;\n        uint256 percent;\n        uint256 networkFee; //NOT USED\n        Route[] route;\n    }\n\n    struct Path {\n        address to;\n        uint256 totalNetworkFee; //NOT USED - Network fee is associated with 0xv3 trades\n        Adapter[] adapters;\n    }\n\n    struct SellData {\n        address fromToken;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        address payable beneficiary;\n        Path[] path;\n        address payable partner;\n        uint256 feePercent;\n        bytes permit;\n        uint256 deadline;\n        bytes16 uuid;\n    }\n\n    struct DirectUniV3 {\n        address fromToken;\n        address toToken;\n        address exchange;\n        uint256 fromAmount;\n        uint256 toAmount;\n        uint256 expectedAmount;\n        uint256 feePercent;\n        uint256 deadline;\n        address payable partner;\n        bool isApproved;\n        address payable beneficiary;\n        bytes path;\n        bytes permit;\n        bytes16 uuid;\n    }\n\n    bytes4 private constant SIMPLESWAP_SELECTOR = 0x54e3f31b;\n    bytes4 private constant MULTISWAP_SELECTOR = 0xa94e78ef;\n    bytes4 private constant DIRECT_UNIV3_SELECTOR = 0xa6886da9;\n\n    function extractTokensAndAmount(bytes4 selector, bytes memory data) internal pure returns (address fromToken, address toToken, uint256 fromAmount) {\n        if (selector == SIMPLESWAP_SELECTOR) {\n            return getSimpleSwapData(data);\n        } else if (selector == MULTISWAP_SELECTOR) {\n            return getMultiSwapData(data);\n        } else if (selector == DIRECT_UNIV3_SELECTOR) {\n            return getDirectUniV3SwapData(data);\n        } else {\n            revert (\"Unknown Selector\");\n        }\n    }\n\n    function getSimpleSwapData(bytes memory data) internal pure returns (address fromToken, address toToken, uint256 fromAmount) {\n        SimpleData memory simpleData = abi.decode(data, (SimpleData));\n        (fromToken, toToken, fromAmount) = (simpleData.fromToken, simpleData.toToken, simpleData.fromAmount);\n    }\n\n    function getMultiSwapData(bytes memory data) internal pure returns (address fromToken, address toToken, uint256 fromAmount) {\n        SellData memory sellData = abi.decode(data, (SellData));\n        toToken = sellData.path[sellData.path.length - 1].to;\n        (fromToken, fromAmount) = (sellData.fromToken, sellData.fromAmount);\n    }\n\n    function getDirectUniV3SwapData(bytes memory data) internal pure returns (address fromToken, address toToken, uint256 fromAmount) {\n        DirectUniV3 memory directData = abi.decode(data, (DirectUniV3));\n        (fromToken, toToken, fromAmount) = (directData.fromToken, directData.toToken, directData.fromAmount);\n    }\n}\n"
    },
    "contracts/lib/Bytes32EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n//It's Open Zeppelin EnumerableMap library modified to accept bytes32 type as a key\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Bytes32ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function _set(\n        Map storage map,\n        bytes32 key,\n        bytes32 value\n    ) private returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function _remove(Map storage map, bytes32 key) private returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function _contains(Map storage map, bytes32 key) private view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function _length(Map storage map) private view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Map storage map, uint256 index) private view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function _tryGet(Map storage map, bytes32 key) private view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (_contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function _get(Map storage map, bytes32 key) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {_get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {_tryGet}.\n     */\n    function _get(\n        Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) private view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || _contains(map, key), errorMessage);\n        return value;\n    }\n\n    // Bytes32ToAddressMap\n\n    struct Bytes32ToAddressMap {\n        Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(\n        Bytes32ToAddressMap storage map,\n        bytes32 key,\n        address value\n    ) internal returns (bool) {\n        return _set(map._inner, key, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToAddressMap storage map, bytes32 key) internal returns (bool) {\n        return _remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool) {\n        return _contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToAddressMap storage map) internal view returns (uint256) {\n        return _length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToAddressMap storage map, uint256 index) internal view returns (bytes32, address) {\n        (bytes32 key, bytes32 value) = _at(map._inner, index);\n        return (key, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`.  O(1).\n     * Does not revert if `key` is not in the map.\n     *\n     * _Available since v3.4._\n     */\n    function tryGet(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = _tryGet(map._inner, key);\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`.  O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToAddressMap storage map, bytes32 key) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, key))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToAddressMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(_get(map._inner, key, errorMessage))));\n    }\n}\n"
    },
    "contracts/lib/celo/DeploymentConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"../../interfaces/ITokenManager.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n/**\n * DeploymentConstants\n * These constants are updated during test and prod deployments using JS scripts. Defined as constants\n * to decrease gas costs. Not meant to be updated unless really necessary.\n * BE CAREFUL WHEN UPDATING. CONSTANTS CAN BE USED AMONG MANY FACETS.\n **/\nlibrary DeploymentConstants {\n\n    // Used for LiquidationBonus calculations\n    uint256 private constant _PERCENTAGE_PRECISION = 1000;\n\n    bytes32 private constant _NATIVE_TOKEN_SYMBOL = 'CELO';\n\n    address private constant _NATIVE_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    address private constant _DIAMOND_BEACON_ADDRESS = 0x8198f5d8F8CfFE8f9C413d98a0A55aEB8ab9FbB7;\n\n    address private constant _SMART_LOANS_FACTORY_ADDRESS = 0x4EE6eCAD1c2Dae9f525404De8555724e3c35d07B;\n\n    address private constant _TOKEN_MANAGER_ADDRESS = 0x4EE6eCAD1c2Dae9f525404De8555724e3c35d07B;\n\n    address private constant _ADDRESS_PROVIDER = address(0);\n\n    //implementation-specific\n\n    function getPercentagePrecision() internal pure returns (uint256) {\n        return _PERCENTAGE_PRECISION;\n    }\n\n    //blockchain-specific\n\n    function getNativeTokenSymbol() internal pure returns (bytes32 symbol) {\n        return _NATIVE_TOKEN_SYMBOL;\n    }\n\n    function getNativeToken() internal pure returns (address payable) {\n        return payable(_NATIVE_ADDRESS);\n    }\n\n    //deployment-specific\n\n    function getDiamondAddress() internal pure returns (address) {\n        return _DIAMOND_BEACON_ADDRESS;\n    }\n\n    function getSmartLoansFactoryAddress() internal pure returns (address) {\n        return _SMART_LOANS_FACTORY_ADDRESS;\n    }\n\n    function getTokenManager() internal pure returns (ITokenManager) {\n        return ITokenManager(_TOKEN_MANAGER_ADDRESS);\n    }\n\n    /**\n    * Returns all owned assets keys\n    **/\n    function getAllOwnedAssets() internal view returns (bytes32[] memory result) {\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\n        return sls.ownedAssets._inner._keys._inner._values;\n    }\n}"
    },
    "contracts/lib/DiamondStorageLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamonds: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\nimport {IDiamondCut} from \"../interfaces/IDiamondCut.sol\";\nimport \"../lib/Bytes32EnumerableMap.sol\";\nimport \"../interfaces/IStakingPositions.sol\";\nimport \"../interfaces/facets/avalanche/ITraderJoeV2Facet.sol\";\n\n// Remember to add the loupe functions from DiamondLoupeFacet to the diamond.\n// The loupe functions are required by the EIP2535 Diamonds standard\n\nlibrary DiamondStorageLib {\n    using EnumerableMap for EnumerableMap.Bytes32ToAddressMap;\n\n    bytes32 constant DIAMOND_STORAGE_POSITION = keccak256(\"diamond.standard.diamond.storage\");\n    bytes32 constant LIQUIDATION_STORAGE_POSITION = keccak256(\"diamond.standard.liquidation.storage\");\n    bytes32 constant SMARTLOAN_STORAGE_POSITION = keccak256(\"diamond.standard.smartloan.storage\");\n    bytes32 constant REENTRANCY_GUARD_STORAGE_POSITION = keccak256(\"diamond.standard.reentrancy.guard.storage\");\n    bytes32 constant OWNED_TRADERJOE_V2_BINS_POSITION = keccak256(\"diamond.standard.traderjoe_v2_bins_1685370112\");\n    //TODO: maybe we should keep here a tuple[tokenId, factory] to account for multiple Uniswap V3 deployments\n    bytes32 constant OWNED_UNISWAP_V3_TOKEN_IDS_POSITION = keccak256(\"diamond.standard.uniswap_v3_token_ids_1685370112\");\n\n    struct FacetAddressAndPosition {\n        address facetAddress;\n        uint96 functionSelectorPosition; // position in facetFunctionSelectors.functionSelectors array\n    }\n\n    struct FacetFunctionSelectors {\n        bytes4[] functionSelectors;\n        uint256 facetAddressPosition; // position of facetAddress in facetAddresses array\n    }\n\n    struct DiamondStorage {\n        // ----------- DIAMOND-SPECIFIC VARIABLES --------------\n        // maps function selector to the facet address and\n        // the position of the selector in the facetFunctionSelectors.selectors array\n        mapping(bytes4 => FacetAddressAndPosition) selectorToFacetAndPosition;\n        // maps facet addresses to function selectors\n        mapping(address => FacetFunctionSelectors) facetFunctionSelectors;\n        // facet addresses\n        address[] facetAddresses;\n        // Used to query if a contract implements an interface.\n        // Used to implement ERC-165.\n        mapping(bytes4 => bool) supportedInterfaces;\n        // Used to select methods that can be executed even when Diamond is paused\n        mapping(bytes4 => bool) canBeExecutedWhenPaused;\n\n        bool _initialized;\n        bool _active;\n\n        uint256 _lastBorrowTimestamp;\n    }\n\n    struct SmartLoanStorage {\n        // PauseAdmin has the power to pause/unpause the contract without the timelock delay in case of a critical bug/exploit\n        address pauseAdmin;\n        // Owner of the contract\n        address contractOwner;\n        // Proposed owner of the contract\n        address proposedOwner;\n        // Proposed pauseAdmin of the contract\n        address proposedPauseAdmin;\n        // Is contract initialized?\n        bool _initialized;\n        // TODO: mock staking tokens until redstone oracle supports them\n        EnumerableMap.Bytes32ToAddressMap ownedAssets;\n        // Staked positions of the contract\n        IStakingPositions.StakedPosition[] currentStakedPositions;\n\n        // Timestamp since which the account is frozen\n        // 0 means an account that is not frozen. Any other value means that the account is frozen\n        uint256 frozenSince;\n    }\n\n    struct TraderJoeV2Storage {\n        // TJ v2 bins of the contract\n        ITraderJoeV2Facet.TraderJoeV2Bin[] ownedTjV2Bins;\n    }\n\n    struct UniswapV3Storage {\n        // UniswapV3 token IDs of the contract\n        uint256[] ownedUniswapV3TokenIds;\n    }\n\n    struct LiquidationStorage {\n        // Mapping controlling addresses that can execute the liquidation methods\n        mapping(address=>bool) canLiquidate;\n    }\n\n    struct ReentrancyGuardStorage {\n        uint256 _status;\n    }\n\n    function reentrancyGuardStorage() internal pure returns (ReentrancyGuardStorage storage rgs) {\n        bytes32 position = REENTRANCY_GUARD_STORAGE_POSITION;\n        assembly {\n            rgs.slot := position\n        }\n    }\n\n    function traderJoeV2Storage() internal pure returns (TraderJoeV2Storage storage tjv2s) {\n        bytes32 position = OWNED_TRADERJOE_V2_BINS_POSITION;\n        assembly {\n            tjv2s.slot := position\n        }\n    }\n\n    function uniswapV3Storage() internal pure returns (UniswapV3Storage storage uv3s) {\n        bytes32 position = OWNED_UNISWAP_V3_TOKEN_IDS_POSITION;\n        assembly {\n            uv3s.slot := position\n        }\n    }\n\n\n    function diamondStorage() internal pure returns (DiamondStorage storage ds) {\n        bytes32 position = DIAMOND_STORAGE_POSITION;\n        assembly {\n            ds.slot := position\n        }\n    }\n\n    function liquidationStorage() internal pure returns (LiquidationStorage storage ls) {\n        bytes32 position = LIQUIDATION_STORAGE_POSITION;\n        assembly {\n            ls.slot := position\n        }\n    }\n\n    function smartLoanStorage() internal pure returns (SmartLoanStorage storage sls) {\n        bytes32 position = SMARTLOAN_STORAGE_POSITION;\n        assembly {\n            sls.slot := position\n        }\n    }\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    event PauseAdminOwnershipTransferred(address indexed previousPauseAdmin, address indexed newPauseAdmin);\n\n    event AccountFrozen(address indexed freezeToken, uint256 timestamp);\n\n    event AccountUnfrozen(address indexed keeper, uint256 timestamp);\n\n    function setContractOwner(address _newOwner) internal {\n        SmartLoanStorage storage sls = smartLoanStorage();\n        address previousOwner = sls.contractOwner;\n        sls.contractOwner = _newOwner;\n        emit OwnershipTransferred(previousOwner, _newOwner);\n    }\n\n    function freezeAccount(address freezeToken) internal {\n        SmartLoanStorage storage sls = smartLoanStorage();\n        require(sls.frozenSince == 0, \"Account is already frozen\");\n        sls.frozenSince = block.timestamp;\n        emit AccountFrozen(freezeToken, block.timestamp);\n    }\n\n    function isAccountFrozen() internal view returns (bool){\n        SmartLoanStorage storage sls = smartLoanStorage();\n        return sls.frozenSince != 0;\n    }\n\n    function unfreezeAccount(address keeperAddress) internal {\n        SmartLoanStorage storage sls = smartLoanStorage();\n        require(sls.frozenSince != 0, \"Account is not frozen\");\n        sls.frozenSince = 0;\n        emit AccountUnfrozen(keeperAddress, block.timestamp);\n    }\n\n    function getTjV2OwnedBins() internal returns(ITraderJoeV2Facet.TraderJoeV2Bin[] storage bins){\n        TraderJoeV2Storage storage tjv2s = traderJoeV2Storage();\n        bins = tjv2s.ownedTjV2Bins;\n    }\n\n    function getTjV2OwnedBinsView() internal view returns(ITraderJoeV2Facet.TraderJoeV2Bin[] storage bins){\n        TraderJoeV2Storage storage tjv2s = traderJoeV2Storage();\n        bins = tjv2s.ownedTjV2Bins;\n    }\n\n    function getUV3OwnedTokenIds() internal returns(uint256[] storage tokenIds){\n        UniswapV3Storage storage uv3s = uniswapV3Storage();\n        tokenIds = uv3s.ownedUniswapV3TokenIds;\n    }\n\n    function getUV3OwnedTokenIdsView() internal view returns(uint256[] storage tokenIds){\n        UniswapV3Storage storage uv3s = uniswapV3Storage();\n        tokenIds = uv3s.ownedUniswapV3TokenIds;\n    }\n\n    function setContractPauseAdmin(address _newPauseAdmin) internal {\n        SmartLoanStorage storage sls = smartLoanStorage();\n        address previousPauseAdmin = sls.pauseAdmin;\n        sls.pauseAdmin = _newPauseAdmin;\n        emit PauseAdminOwnershipTransferred(previousPauseAdmin, _newPauseAdmin);\n    }\n\n    function contractOwner() internal view returns (address contractOwner_) {\n        contractOwner_ = smartLoanStorage().contractOwner;\n    }\n\n    function pauseAdmin() internal view returns (address pauseAdmin) {\n        pauseAdmin = smartLoanStorage().pauseAdmin;\n    }\n\n    function setProposedOwner(address _newOwner) internal {\n        SmartLoanStorage storage sls = smartLoanStorage();\n        sls.proposedOwner = _newOwner;\n    }\n\n    function setProposedPauseAdmin(address _newPauseAdmin) internal {\n        SmartLoanStorage storage sls = smartLoanStorage();\n        sls.proposedPauseAdmin = _newPauseAdmin;\n    }\n\n    function getPausedMethodExemption(bytes4 _methodSig) internal view returns (bool) {\n        DiamondStorage storage ds = diamondStorage();\n        return ds.canBeExecutedWhenPaused[_methodSig];\n    }\n\n    function proposedOwner() internal view returns (address proposedOwner_) {\n        proposedOwner_ = smartLoanStorage().proposedOwner;\n    }\n\n    function proposedPauseAdmin() internal view returns (address proposedPauseAdmin) {\n        proposedPauseAdmin = smartLoanStorage().proposedPauseAdmin;\n    }\n\n    function stakedPositions() internal view returns (IStakingPositions.StakedPosition[] storage _positions) {\n        _positions = smartLoanStorage().currentStakedPositions;\n    }\n\n    function addStakedPosition(IStakingPositions.StakedPosition memory position) internal {\n        IStakingPositions.StakedPosition[] storage positions = stakedPositions();\n\n        bool found;\n\n        for (uint256 i; i < positions.length; i++) {\n            if (positions[i].identifier == position.identifier) {\n                found = true;\n                break;\n            }\n        }\n\n        if (!found) {\n            positions.push(position);\n        }\n    }\n\n    function removeStakedPosition(bytes32 identifier) internal {\n        IStakingPositions.StakedPosition[] storage positions = stakedPositions();\n\n        for (uint256 i; i < positions.length; i++) {\n            if (positions[i].identifier == identifier) {\n                positions[i] = positions[positions.length - 1];\n                positions.pop();\n            }\n        }\n    }\n\n    function addOwnedAsset(bytes32 _symbol, address _address) internal {\n        require(_symbol != \"\", \"Symbol cannot be empty\");\n        require(_address != address(0), \"Invalid AddressZero\");\n        SmartLoanStorage storage sls = smartLoanStorage();\n        EnumerableMap.set(sls.ownedAssets, _symbol, _address);\n        emit OwnedAssetAdded(_symbol, block.timestamp);\n    }\n\n    function hasAsset(bytes32 _symbol) internal view returns (bool){\n        SmartLoanStorage storage sls = smartLoanStorage();\n        return sls.ownedAssets.contains(_symbol);\n    }\n\n    function removeOwnedAsset(bytes32 _symbol) internal {\n        SmartLoanStorage storage sls = smartLoanStorage();\n        EnumerableMap.remove(sls.ownedAssets, _symbol);\n\n        emit OwnedAssetRemoved(_symbol, block.timestamp);\n    }\n\n    function enforceIsContractOwner() internal view {\n        require(msg.sender == smartLoanStorage().contractOwner, \"DiamondStorageLib: Must be contract owner\");\n    }\n\n    function enforceIsPauseAdmin() internal view {\n        require(msg.sender == smartLoanStorage().pauseAdmin, \"DiamondStorageLib: Must be contract pauseAdmin\");\n    }\n\n    event DiamondCut(IDiamondCut.FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    // Internal function version of diamondCut\n    function diamondCut(\n        IDiamondCut.FacetCut[] memory _diamondCut,\n        address _init,\n        bytes memory _calldata\n    ) internal {\n        for (uint256 facetIndex; facetIndex < _diamondCut.length; facetIndex++) {\n            IDiamondCut.FacetCutAction action = _diamondCut[facetIndex].action;\n            if (action == IDiamondCut.FacetCutAction.Add) {\n                addFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Replace) {\n                replaceFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else if (action == IDiamondCut.FacetCutAction.Remove) {\n                removeFunctions(_diamondCut[facetIndex].facetAddress, _diamondCut[facetIndex].functionSelectors);\n            } else {\n                revert(\"DiamondStorageLibCut: Incorrect FacetCutAction\");\n            }\n        }\n        emit DiamondCut(_diamondCut, _init, _calldata);\n        initializeDiamondCut(_init, _calldata);\n    }\n\n    function addFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"DiamondStorageLibCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"DiamondStorageLibCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress == address(0), \"DiamondStorageLibCut: Can't add function that already exists\");\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function replaceFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"DiamondStorageLibCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        require(_facetAddress != address(0), \"DiamondStorageLibCut: Add facet can't be address(0)\");\n        uint96 selectorPosition = uint96(ds.facetFunctionSelectors[_facetAddress].functionSelectors.length);\n        // add new facet address if it does not exist\n        if (selectorPosition == 0) {\n            addFacet(ds, _facetAddress);\n        }\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            require(oldFacetAddress != _facetAddress, \"DiamondStorageLibCut: Can't replace function with same function\");\n            removeFunction(ds, oldFacetAddress, selector);\n            addFunction(ds, selector, selectorPosition, _facetAddress);\n            selectorPosition++;\n        }\n    }\n\n    function removeFunctions(address _facetAddress, bytes4[] memory _functionSelectors) internal {\n        require(_functionSelectors.length > 0, \"DiamondStorageLibCut: No selectors in facet to cut\");\n        DiamondStorage storage ds = diamondStorage();\n        // if function does not exist then do nothing and return\n        require(_facetAddress == address(0), \"DiamondStorageLibCut: Remove facet address must be address(0)\");\n        for (uint256 selectorIndex; selectorIndex < _functionSelectors.length; selectorIndex++) {\n            bytes4 selector = _functionSelectors[selectorIndex];\n            address oldFacetAddress = ds.selectorToFacetAndPosition[selector].facetAddress;\n            removeFunction(ds, oldFacetAddress, selector);\n        }\n    }\n\n    function addFacet(DiamondStorage storage ds, address _facetAddress) internal {\n        enforceHasContractCode(_facetAddress, \"DiamondStorageLibCut: New facet has no code\");\n        ds.facetFunctionSelectors[_facetAddress].facetAddressPosition = ds.facetAddresses.length;\n        ds.facetAddresses.push(_facetAddress);\n    }\n\n\n    function addFunction(DiamondStorage storage ds, bytes4 _selector, uint96 _selectorPosition, address _facetAddress) internal {\n        ds.selectorToFacetAndPosition[_selector].functionSelectorPosition = _selectorPosition;\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.push(_selector);\n        ds.selectorToFacetAndPosition[_selector].facetAddress = _facetAddress;\n    }\n\n    function removeFunction(DiamondStorage storage ds, address _facetAddress, bytes4 _selector) internal {\n        require(_facetAddress != address(0), \"DiamondStorageLibCut: Can't remove function that doesn't exist\");\n        // an immutable function is a function defined directly in a diamond\n        require(_facetAddress != address(this), \"DiamondStorageLibCut: Can't remove immutable function\");\n        // replace selector with last selector, then delete last selector\n        uint256 selectorPosition = ds.selectorToFacetAndPosition[_selector].functionSelectorPosition;\n        uint256 lastSelectorPosition = ds.facetFunctionSelectors[_facetAddress].functionSelectors.length - 1;\n        // if not the same then replace _selector with lastSelector\n        if (selectorPosition != lastSelectorPosition) {\n            bytes4 lastSelector = ds.facetFunctionSelectors[_facetAddress].functionSelectors[lastSelectorPosition];\n            ds.facetFunctionSelectors[_facetAddress].functionSelectors[selectorPosition] = lastSelector;\n            ds.selectorToFacetAndPosition[lastSelector].functionSelectorPosition = uint96(selectorPosition);\n        }\n        // delete the last selector\n        ds.facetFunctionSelectors[_facetAddress].functionSelectors.pop();\n        delete ds.selectorToFacetAndPosition[_selector];\n\n        // if no more selectors for facet address then delete the facet address\n        if (lastSelectorPosition == 0) {\n            // replace facet address with last facet address and delete last facet address\n            uint256 lastFacetAddressPosition = ds.facetAddresses.length - 1;\n            uint256 facetAddressPosition = ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n            if (facetAddressPosition != lastFacetAddressPosition) {\n                address lastFacetAddress = ds.facetAddresses[lastFacetAddressPosition];\n                ds.facetAddresses[facetAddressPosition] = lastFacetAddress;\n                ds.facetFunctionSelectors[lastFacetAddress].facetAddressPosition = facetAddressPosition;\n            }\n            ds.facetAddresses.pop();\n            delete ds.facetFunctionSelectors[_facetAddress].facetAddressPosition;\n        }\n    }\n\n    function initializeDiamondCut(address _init, bytes memory _calldata) internal {\n        if (_init == address(0)) {\n            require(_calldata.length == 0, \"DiamondStorageLibCut: _init is address(0) but_calldata is not empty\");\n        } else {\n            require(_calldata.length > 0, \"DiamondStorageLibCut: _calldata is empty but _init is not address(0)\");\n            if (_init != address(this)) {\n                enforceHasContractCode(_init, \"DiamondStorageLibCut: _init address has no code\");\n            }\n            (bool success, bytes memory error) = _init.delegatecall(_calldata);\n            if (!success) {\n                if (error.length > 0) {\n                    // bubble up the error\n                    revert(string(error));\n                } else {\n                    revert(\"DiamondStorageLibCut: _init function reverted\");\n                }\n            }\n        }\n    }\n\n    function enforceHasContractCode(address _contract, string memory _errorMessage) internal view {\n        uint256 contractSize;\n        assembly {\n            contractSize := extcodesize(_contract)\n        }\n        require(contractSize > 0, _errorMessage);\n    }\n\n    event OwnedAssetAdded(bytes32 indexed asset, uint256 timestamp);\n\n    event OwnedAssetRemoved(bytes32 indexed asset, uint256 timestamp);\n}"
    },
    "contracts/lib/hexagate/Gator.sol": {
      "content": "// SPDX-License-Identifier: PRIVATE\n// all rights reserved to Hexagate\n\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/UUPSUpgradeable.sol\";\n\ninterface IGator {\n    function initialize(address owner) external;\n\n    function enter(bytes4 signature) external;\n    function exit(bytes4 signature) external;\n\n    function approveClient(address client) external;\n    function approveClients(address[] calldata clients) external;\n\n    function denyClient(address client) external;\n    function denyClients(address[] calldata clients) external;\n\n    function approveFlow(bytes32 flow) external;\n    function approveFlows(bytes32[] calldata flows) external;\n\n    function denyFlow(bytes32 flow) external;\n    function denyFlows(bytes32[] calldata flows) external;\n\n    function enable() external;\n    function disable() external;\n}\n\nerror ClientNotApproved(address client);\nerror FlowNotApproved(bytes32 flow);\nerror AlreadyEnabled();\nerror AlreadyDisabled();\n\ncontract Gator is Ownable, Initializable, UUPSUpgradeable {\n    // == Events ==\n    event Enabled();\n    event Disabled();\n    event ClientApproved(address indexed client);\n    event ClientDenied(address indexed client);\n    event FlowApproved(bytes32 indexed flow);\n    event FlowDenied(bytes32 indexed flow);\n\n    // == Constants ==\n    uint256 private constant FALSE = 1;\n    uint256 private constant TRUE = 2;\n    // keccak(\"gator.flow\")\n    uint256 private constant FLOW_SLOT = 0xe2f2692cd9a0f44c494c30611a5682d690a3ed957ac1867be2e6a4a331e5b271;\n\n    // == Storage data ==\n    uint256 public $enabled;\n    mapping(bytes32 flow => uint256) private $allowedFlows;\n    mapping(address client => uint256) private $gatedClients;\n\n    // This contract is to be used behind a proxy, so the constructor should not be used\n    constructor() Ownable() {\n        _disableInitializers();\n    }\n\n    // Allow upgrades to this contract by the owner\n    function _authorizeUpgrade(address) internal override onlyOwner {}\n\n    // This initializer is used instead of the constructor\n    function initialize(address owner) external initializer {\n        _transferOwnership(owner);\n        $enabled = TRUE;\n    }\n\n    // == Modifiers ==\n\n    modifier onlyGated() {\n        if ($gatedClients[msg.sender] != TRUE) {\n            revert ClientNotApproved(msg.sender);\n        }\n\n        _;\n    }\n\n    // == Gator client called functions ==\n\n    function _checkFlow(bytes4 selector, bool isEnter) internal {\n        if ($enabled == FALSE) {\n            return;\n        }\n\n        bytes32 flow;\n        // Load the current flow identifier from the transient storage\n        // slot `FLOW_SLOT`\n        assembly {\n            flow := tload(FLOW_SLOT)\n        }\n\n        // Calculate the the new flow identifier according to the current state\n        flow = keccak256(abi.encodePacked(flow, msg.sender, selector, isEnter));\n        if ($allowedFlows[flow] != TRUE) {\n            revert FlowNotApproved(flow);\n        }\n\n        // Store the new flow identifier to the transient storage\n        // slot `FLOW_SLOT`\n        assembly {\n            tstore(FLOW_SLOT, flow)\n        }\n    }\n\n    function enter(bytes4 selector) external onlyGated {\n        _checkFlow(selector, true);\n    }\n\n    function exit(bytes4 selector) external onlyGated {\n        _checkFlow(selector, false);\n    }\n\n    // == Admin functions ==\n\n    function approveFlow(bytes32 flow) public onlyOwner {\n        $allowedFlows[flow] = TRUE;\n        emit FlowApproved(flow);\n    }\n\n    function approveFlows(bytes32[] calldata flows) external onlyOwner {\n        for (uint256 i = 0; i < flows.length; i++) {\n            approveFlow(flows[i]);\n        }\n    }\n\n    function denyFlow(bytes32 flow) public onlyOwner {\n        $allowedFlows[flow] = FALSE;\n        emit FlowDenied(flow);\n    }\n\n    function denyFlows(bytes32[] calldata flows) external onlyOwner {\n        for (uint256 i = 0; i < flows.length; i++) {\n            denyFlow(flows[i]);\n        }\n    }\n\n    function approveClient(address client) public onlyOwner {\n        $gatedClients[client] = TRUE;\n        emit ClientApproved(client);\n    }\n\n    function approveClients(address[] calldata clients) external onlyOwner {\n        for (uint256 i = 0; i < clients.length; i++) {\n            approveClient(clients[i]);\n        }\n    }\n\n    function denyClient(address client) public onlyOwner {\n        $gatedClients[client] = FALSE;\n        emit ClientDenied(client);\n    }\n\n    function denyClients(address[] calldata clients) external onlyOwner {\n        for (uint256 i = 0; i < clients.length; i++) {\n            denyClient(clients[i]);\n        }\n    }\n\n    function enable() public onlyOwner {\n        if ($enabled == TRUE) {\n            revert AlreadyEnabled();\n        }\n        $enabled = TRUE;\n        emit Enabled();\n    }\n\n    function disable() public onlyOwner {\n        if ($enabled == FALSE) {\n            revert AlreadyDisabled();\n        }\n        $enabled = FALSE;\n        emit Disabled();\n    }\n}\n"
    },
    "contracts/lib/hexagate/GatorClient.sol": {
      "content": "// SPDX-License-Identifier: PRIVATE\n// all rights reserved to Hexagate\n\npragma solidity ^0.8.27;\n\nimport {IGator} from \"./Gator.sol\";\n\nabstract contract GatorClient {\n    // keccak32(\"gatorclient.gator\")\n    bytes32 private constant GATOR_SLOT = 0xa53f6f8ec545fba22c6f5161ad4c3981dee87a9993a6055a4c0ede893f9496e3;\n\n    /**\n     * @dev Reads the gator address from `GATOR_SLOT` storage slot\n     */\n    function gator() public view returns (IGator gatorAddress) {\n        assembly {\n            gatorAddress := sload(GATOR_SLOT)\n        }\n    }\n\n    /**\n     * @dev Sets the gator address stored in `GATOR_SLOT` storage slot\n     */\n    function _setGator(address _gator) internal {\n        assembly {\n            sstore(GATOR_SLOT, _gator)\n        }\n    }\n\n    /**\n     * @dev Calls gator with the current function selector\n     * to check if the flow is approved\n     */\n    modifier gated() {\n        IGator _gator = gator();\n        if (address(_gator) == address(0)) {\n            _;\n            return;\n        }\n\n        // calldataload(0) loads the first 32 bytes of calldata,\n        // and the assignment to `selector` which is a bytes4 variable\n        // truncates it to the first 4 bytes of the calldata\n        bytes4 selector;\n        assembly {\n            selector := calldataload(0)\n        }\n\n        _gator.enter(selector);\n        _;\n        _gator.exit(selector);\n    }\n}\n"
    },
    "contracts/lib/joe-v2/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Constants Library\n * @author Trader Joe\n * @notice Set of constants for Liquidity Book contracts\n */\nlibrary Constants {\n    uint8 internal constant SCALE_OFFSET = 128;\n    uint256 internal constant SCALE = 1 << SCALE_OFFSET;\n\n    uint256 internal constant PRECISION = 1e18;\n    uint256 internal constant SQUARED_PRECISION = PRECISION * PRECISION;\n\n    uint256 internal constant MAX_FEE = 0.1e18; // 10%\n    uint256 internal constant MAX_PROTOCOL_SHARE = 2_500; // 25% of the fee\n\n    uint256 internal constant BASIS_POINT_MAX = 10_000;\n\n    /// @dev The expected return after a successful flash loan\n    bytes32 internal constant CALLBACK_SUCCESS = keccak256(\"LBPair.onFlashLoan\");\n}\n"
    },
    "contracts/lib/joe-v2/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./math/Uint256x256Math.sol\";\nimport \"./PriceHelper.sol\";\nimport \"./Constants.sol\";\nimport \"./math/SafeCast.sol\";\nimport \"../../interfaces/joe-v2/ILBPair.sol\";\nimport \"../../interfaces/joe-v2/ILBToken.sol\";\n\n/// @title Liquidity Book periphery library for Liquidity Amount\n/// @author Trader Joe\n/// @notice Periphery library to help compute liquidity amounts from amounts and ids.\n/// @dev The caller must ensure that the parameters are valid following the comments.\nlibrary LiquidityAmounts {\n    using Uint256x256Math for uint256;\n    using SafeCast for uint256;\n\n    error LiquidityAmounts__LengthMismatch();\n\n    /// @notice Return the liquidities amounts received for a given amount of tokenX and tokenY\n    /// @dev The caller needs to ensure that the ids are unique, if not, the result will be wrong.\n    /// @param ids the list of ids where the user want to add liquidity\n    /// @param binStep the binStep of the pair\n    /// @param amountX the amount of tokenX\n    /// @param amountY the amount of tokenY\n    /// @return liquidities the amounts of liquidity received\n    function getLiquiditiesForAmounts(uint256[] memory ids, uint16 binStep, uint112 amountX, uint112 amountY)\n        internal\n        pure\n        returns (uint256[] memory liquidities)\n    {\n        liquidities = new uint256[](ids.length);\n\n        for (uint256 i; i < ids.length; ++i) {\n            uint256 price = PriceHelper.getPriceFromId(ids[i].safe24(), binStep);\n\n            liquidities[i] = price.mulShiftRoundDown(amountX, Constants.SCALE_OFFSET) + amountY;\n        }\n    }\n\n    /// @notice Return the amounts of token received for a given amount of liquidities\n    /// @dev The different arrays needs to use the same binId for each index\n    /// @param liquidities the list of liquidity amounts for each binId\n    /// @param totalSupplies the list of totalSupply for each binId\n    /// @param binReservesX the list of reserve of token X for each binId\n    /// @param binReservesY the list of reserve of token Y for each binId\n    /// @return amountX the amount of tokenX received by the user\n    /// @return amountY the amount of tokenY received by the user\n    function getAmountsForLiquidities(\n        uint256[] memory liquidities,\n        uint256[] memory totalSupplies,\n        uint112[] memory binReservesX,\n        uint112[] memory binReservesY\n    ) internal pure returns (uint256 amountX, uint256 amountY) {\n        if (\n            liquidities.length != totalSupplies.length && liquidities.length != binReservesX.length\n                && liquidities.length != binReservesY.length\n        ) revert LiquidityAmounts__LengthMismatch();\n\n        for (uint256 i; i < liquidities.length; ++i) {\n            amountX += liquidities[i].mulDivRoundDown(binReservesX[i], totalSupplies[i]);\n            amountY += liquidities[i].mulDivRoundDown(binReservesY[i], totalSupplies[i]);\n        }\n    }\n\n    /// @notice Return the ids and liquidities of an user\n    /// @dev The caller needs to ensure that the ids are unique, if not, the result will be wrong.\n    /// @param user The address of the user\n    /// @param ids the list of ids where the user have liquidity\n    /// @param LBPair The address of the LBPair\n    /// @return liquidities the list of amount of liquidity of the user\n    function getLiquiditiesOf(address user, uint256[] memory ids, address LBPair)\n        internal\n        view\n        returns (uint256[] memory liquidities)\n    {\n        liquidities = new uint256[](ids.length);\n\n        for (uint256 i; i < ids.length; ++i) {\n            liquidities[i] = ILBToken(LBPair).balanceOf(user, ids[i].safe24());\n        }\n    }\n\n    /// @notice Return the amounts received by an user if he were to burn all its liquidity\n    /// @dev The caller needs to ensure that the ids are unique, if not, the result will be wrong.\n    /// @param user The address of the user\n    /// @param ids the list of ids where the user would remove its liquidity, ids need to be in ascending order to assert uniqueness\n    /// @param LBPair The address of the LBPair\n    /// @return amountX the amount of tokenX received by the user\n    /// @return amountY the amount of tokenY received by the user\n    function getAmountsOf(address user, uint256[] memory ids, address LBPair)\n        internal\n        view\n        returns (uint256 amountX, uint256 amountY)\n    {\n        for (uint256 i; i < ids.length; ++i) {\n            uint24 id = ids[i].safe24();\n\n            uint256 liquidity = ILBToken(LBPair).balanceOf(user, id);\n            (uint256 binReserveX, uint256 binReserveY) = ILBPair(LBPair).getBin(id);\n            uint256 totalSupply = ILBToken(LBPair).totalSupply(id);\n\n            amountX += liquidity.mulDivRoundDown(binReserveX, totalSupply);\n            amountY += liquidity.mulDivRoundDown(binReserveY, totalSupply);\n        }\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/BitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Bit Math Library\n * @author Trader Joe\n * @notice Helper contract used for bit calculations\n */\nlibrary BitMath {\n    /**\n     * @dev Returns the index of the closest bit on the right of x that is non null\n     * @param x The value as a uint256\n     * @param bit The index of the bit to start searching at\n     * @return id The index of the closest non null bit on the right of x.\n     * If there is no closest bit, it returns max(uint256)\n     */\n    function closestBitRight(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            uint256 shift = 255 - bit;\n            x <<= shift;\n\n            // can't overflow as it's non-zero and we shifted it by `_shift`\n            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - shift;\n        }\n    }\n\n    /**\n     * @dev Returns the index of the closest bit on the left of x that is non null\n     * @param x The value as a uint256\n     * @param bit The index of the bit to start searching at\n     * @return id The index of the closest non null bit on the left of x.\n     * If there is no closest bit, it returns max(uint256)\n     */\n    function closestBitLeft(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            x >>= bit;\n\n            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;\n        }\n    }\n\n    /**\n     * @dev Returns the index of the most significant bit of x\n     * This function returns 0 if x is 0\n     * @param x The value as a uint256\n     * @return msb The index of the most significant bit of x\n     */\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 msb) {\n        assembly {\n            if gt(x, 0xffffffffffffffffffffffffffffffff) {\n                x := shr(128, x)\n                msb := 128\n            }\n            if gt(x, 0xffffffffffffffff) {\n                x := shr(64, x)\n                msb := add(msb, 64)\n            }\n            if gt(x, 0xffffffff) {\n                x := shr(32, x)\n                msb := add(msb, 32)\n            }\n            if gt(x, 0xffff) {\n                x := shr(16, x)\n                msb := add(msb, 16)\n            }\n            if gt(x, 0xff) {\n                x := shr(8, x)\n                msb := add(msb, 8)\n            }\n            if gt(x, 0xf) {\n                x := shr(4, x)\n                msb := add(msb, 4)\n            }\n            if gt(x, 0x3) {\n                x := shr(2, x)\n                msb := add(msb, 2)\n            }\n            if gt(x, 0x1) { msb := add(msb, 1) }\n        }\n    }\n\n    /**\n     * @dev Returns the index of the least significant bit of x\n     * This function returns 255 if x is 0\n     * @param x The value as a uint256\n     * @return lsb The index of the least significant bit of x\n     */\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 lsb) {\n        assembly {\n            let sx := shl(128, x)\n            if iszero(iszero(sx)) {\n                lsb := 128\n                x := sx\n            }\n            sx := shl(64, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 64)\n            }\n            sx := shl(32, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 32)\n            }\n            sx := shl(16, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 16)\n            }\n            sx := shl(8, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 8)\n            }\n            sx := shl(4, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 4)\n            }\n            sx := shl(2, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 2)\n            }\n            if iszero(iszero(shl(1, x))) { lsb := add(lsb, 1) }\n\n            lsb := sub(255, lsb)\n        }\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/Encoded.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Encoded Library\n * @author Trader Joe\n * @notice Helper contract used for decoding bytes32 sample\n */\nlibrary Encoded {\n    uint256 internal constant MASK_UINT1 = 0x1;\n    uint256 internal constant MASK_UINT8 = 0xff;\n    uint256 internal constant MASK_UINT12 = 0xfff;\n    uint256 internal constant MASK_UINT14 = 0x3fff;\n    uint256 internal constant MASK_UINT16 = 0xffff;\n    uint256 internal constant MASK_UINT20 = 0xfffff;\n    uint256 internal constant MASK_UINT24 = 0xffffff;\n    uint256 internal constant MASK_UINT40 = 0xffffffffff;\n    uint256 internal constant MASK_UINT64 = 0xffffffffffffffff;\n    uint256 internal constant MASK_UINT128 = 0xffffffffffffffffffffffffffffffff;\n\n    /**\n     * @notice Internal function to set a value in an encoded bytes32 using a mask and offset\n     * @dev This function can overflow\n     * @param encoded The previous encoded value\n     * @param value The value to encode\n     * @param mask The mask\n     * @param offset The offset\n     * @return newEncoded The new encoded value\n     */\n    function set(bytes32 encoded, uint256 value, uint256 mask, uint256 offset)\n        internal\n        pure\n        returns (bytes32 newEncoded)\n    {\n        assembly {\n            newEncoded := and(encoded, not(shl(offset, mask)))\n            newEncoded := or(newEncoded, shl(offset, and(value, mask)))\n        }\n    }\n\n    /**\n     * @notice Internal function to set a bool in an encoded bytes32 using an offset\n     * @dev This function can overflow\n     * @param encoded The previous encoded value\n     * @param boolean The bool to encode\n     * @param offset The offset\n     * @return newEncoded The new encoded value\n     */\n    function setBool(bytes32 encoded, bool boolean, uint256 offset) internal pure returns (bytes32 newEncoded) {\n        return set(encoded, boolean ? 1 : 0, MASK_UINT1, offset);\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample using a mask and offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param mask The mask\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decode(bytes32 encoded, uint256 mask, uint256 offset) internal pure returns (uint256 value) {\n        assembly {\n            value := and(shr(offset, encoded), mask)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a bool using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return boolean The decoded value as a bool\n     */\n    function decodeBool(bytes32 encoded, uint256 offset) internal pure returns (bool boolean) {\n        assembly {\n            boolean := and(shr(offset, encoded), MASK_UINT1)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint8 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint8(bytes32 encoded, uint256 offset) internal pure returns (uint8 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT8)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint12 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint16, since uint12 is not supported\n     */\n    function decodeUint12(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT12)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint14 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint16, since uint14 is not supported\n     */\n    function decodeUint14(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT14)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint16 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint16(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT16)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint20 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint24, since uint20 is not supported\n     */\n    function decodeUint20(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT20)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint24 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint24(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT24)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint40 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint40(bytes32 encoded, uint256 offset) internal pure returns (uint40 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT40)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint64 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint64(bytes32 encoded, uint256 offset) internal pure returns (uint64 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT64)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint128 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint128(bytes32 encoded, uint256 offset) internal pure returns (uint128 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT128)\n        }\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/LiquidityConfigurations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {PackedUint128Math} from \"./PackedUint128Math.sol\";\nimport {Encoded} from \"./Encoded.sol\";\n\n/**\n * @title Liquidity Book Liquidity Configurations Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode the config of a pool and interact with the encoded bytes32.\n */\nlibrary LiquidityConfigurations {\n    using PackedUint128Math for bytes32;\n    using PackedUint128Math for uint128;\n    using Encoded for bytes32;\n\n    error LiquidityConfigurations__InvalidConfig();\n\n    uint256 private constant OFFSET_ID = 0;\n    uint256 private constant OFFSET_DISTRIBUTION_Y = 24;\n    uint256 private constant OFFSET_DISTRIBUTION_X = 88;\n\n    uint256 private constant PRECISION = 1e18;\n\n    /**\n     * @dev Encode the distributionX, distributionY and id into a single bytes32\n     * @param distributionX The distribution of the first token\n     * @param distributionY The distribution of the second token\n     * @param id The id of the pool\n     * @return config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     */\n    function encodeParams(uint64 distributionX, uint64 distributionY, uint24 id)\n        internal\n        pure\n        returns (bytes32 config)\n    {\n        config = config.set(distributionX, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_X);\n        config = config.set(distributionY, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_Y);\n        config = config.set(id, Encoded.MASK_UINT24, OFFSET_ID);\n    }\n\n    /**\n     * @dev Decode the distributionX, distributionY and id from a single bytes32\n     * @param config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     * @return distributionX The distribution of the first token\n     * @return distributionY The distribution of the second token\n     * @return id The id of the bin to add the liquidity to\n     */\n    function decodeParams(bytes32 config)\n        internal\n        pure\n        returns (uint64 distributionX, uint64 distributionY, uint24 id)\n    {\n        distributionX = config.decodeUint64(OFFSET_DISTRIBUTION_X);\n        distributionY = config.decodeUint64(OFFSET_DISTRIBUTION_Y);\n        id = config.decodeUint24(OFFSET_ID);\n\n        if (uint256(config) > type(uint152).max || distributionX > PRECISION || distributionY > PRECISION) {\n            revert LiquidityConfigurations__InvalidConfig();\n        }\n    }\n\n    /**\n     * @dev Get the amounts and id from a config and amountsIn\n     * @param config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     * @param amountsIn The amounts to distribute as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return amounts The distributed amounts as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return id The id of the bin to add the liquidity to\n     */\n    function getAmountsAndId(bytes32 config, bytes32 amountsIn) internal pure returns (bytes32, uint24) {\n        (uint64 distributionX, uint64 distributionY, uint24 id) = decodeParams(config);\n\n        (uint128 x1, uint128 x2) = amountsIn.decode();\n\n        assembly {\n            x1 := div(mul(x1, distributionX), PRECISION)\n            x2 := div(mul(x2, distributionY), PRECISION)\n        }\n\n        return (x1.encode(x2), id);\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/PackedUint128Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"../Constants.sol\";\n\n/**\n * @title Liquidity Book Packed Uint128 Math Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode two uint128 into a single bytes32\n * and interact with the encoded bytes32.\n */\nlibrary PackedUint128Math {\n    error PackedUint128Math__AddOverflow();\n    error PackedUint128Math__SubUnderflow();\n    error PackedUint128Math__MultiplierTooLarge();\n\n    uint256 private constant OFFSET = 128;\n    uint256 private constant MASK_128 = 0xffffffffffffffffffffffffffffffff;\n    uint256 private constant MASK_128_PLUS_ONE = MASK_128 + 1;\n\n    /**\n     * @dev Encodes two uint128 into a single bytes32\n     * @param x1 The first uint128\n     * @param x2 The second uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     */\n    function encode(uint128 x1, uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := or(and(x1, MASK_128), shl(OFFSET, x2))\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first uint128\n     * @param x1 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     */\n    function encodeFirst(uint128 x1) internal pure returns (bytes32 z) {\n        assembly {\n            z := and(x1, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the second uint128\n     * @param x2 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     */\n    function encodeSecond(uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := shl(OFFSET, x2)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first or second uint128\n     * @param x The uint128\n     * @param first Whether to encode as the first or second uint128\n     * @return z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x\n     */\n    function encode(uint128 x, bool first) internal pure returns (bytes32 z) {\n        return first ? encodeFirst(x) : encodeSecond(x);\n    }\n\n    /**\n     * @dev Decodes a bytes32 into two uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return x1 The first uint128\n     * @return x2 The second uint128\n     */\n    function decode(bytes32 z) internal pure returns (uint128 x1, uint128 x2) {\n        assembly {\n            x1 := and(z, MASK_128)\n            x2 := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x\n     * [128 - 256[: any\n     * @return x The first uint128\n     */\n    function decodeX(bytes32 z) internal pure returns (uint128 x) {\n        assembly {\n            x := and(z, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the second uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: any\n     * [128 - 256[: y\n     * @return y The second uint128\n     */\n    function decodeY(bytes32 z) internal pure returns (uint128 y) {\n        assembly {\n            y := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first or second uint128\n     * @param z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     * @param first Whether to decode as the first or second uint128\n     * @return x The decoded uint128\n     */\n    function decode(bytes32 z, bool first) internal pure returns (uint128 x) {\n        return first ? decodeX(z) : decodeY(z);\n    }\n\n    /**\n     * @dev Adds two encoded bytes32, reverting on overflow on any of the uint128\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return z The sum of x and y encoded as follows:\n     * [0 - 128[: x1 + y1\n     * [128 - 256[: x2 + y2\n     */\n    function add(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        assembly {\n            z := add(x, y)\n        }\n\n        if (z < x || uint128(uint256(z)) < uint128(uint256(x))) {\n            revert PackedUint128Math__AddOverflow();\n        }\n    }\n\n    /**\n     * @dev Adds an encoded bytes32 and two uint128, reverting on overflow on any of the uint128\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y1 The first uint128\n     * @param y2 The second uint128\n     * @return z The sum of x and y encoded as follows:\n     * [0 - 128[: x1 + y1\n     * [128 - 256[: x2 + y2\n     */\n    function add(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\n        return add(x, encode(y1, y2));\n    }\n\n    /**\n     * @dev Subtracts two encoded bytes32, reverting on underflow on any of the uint128\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return z The difference of x and y encoded as follows:\n     * [0 - 128[: x1 - y1\n     * [128 - 256[: x2 - y2\n     */\n    function sub(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        assembly {\n            z := sub(x, y)\n        }\n\n        if (z > x || uint128(uint256(z)) > uint128(uint256(x))) {\n            revert PackedUint128Math__SubUnderflow();\n        }\n    }\n\n    /**\n     * @dev Subtracts an encoded bytes32 and two uint128, reverting on underflow on any of the uint128\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y1 The first uint128\n     * @param y2 The second uint128\n     * @return z The difference of x and y encoded as follows:\n     * [0 - 128[: x1 - y1\n     * [128 - 256[: x2 - y2\n     */\n    function sub(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\n        return sub(x, encode(y1, y2));\n    }\n\n    /**\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return x1 < y1 || x2 < y2\n     */\n    function lt(bytes32 x, bytes32 y) internal pure returns (bool) {\n        (uint128 x1, uint128 x2) = decode(x);\n        (uint128 y1, uint128 y2) = decode(y);\n\n        return x1 < y1 || x2 < y2;\n    }\n\n    /**\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return x1 < y1 || x2 < y2\n     */\n    function gt(bytes32 x, bytes32 y) internal pure returns (bool) {\n        (uint128 x1, uint128 x2) = decode(x);\n        (uint128 y1, uint128 y2) = decode(y);\n\n        return x1 > y1 || x2 > y2;\n    }\n\n    /**\n     * @dev Multiplies an encoded bytes32 by a uint128 then divides the result by 10_000, rounding down\n     * The result can't overflow as the multiplier needs to be smaller or equal to 10_000\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param multiplier The uint128 to multiply by (must be smaller or equal to 10_000)\n     * @return z The product of x and multiplier encoded as follows:\n     * [0 - 128[: floor((x1 * multiplier) / 10_000)\n     * [128 - 256[: floor((x2 * multiplier) / 10_000)\n     */\n    function scalarMulDivBasisPointRoundDown(bytes32 x, uint128 multiplier) internal pure returns (bytes32 z) {\n        if (multiplier == 0) return 0;\n\n        uint256 BASIS_POINT_MAX = Constants.BASIS_POINT_MAX;\n        if (multiplier > BASIS_POINT_MAX) revert PackedUint128Math__MultiplierTooLarge();\n\n        (uint128 x1, uint128 x2) = decode(x);\n\n        assembly {\n            x1 := div(mul(x1, multiplier), BASIS_POINT_MAX)\n            x2 := div(mul(x2, multiplier), BASIS_POINT_MAX)\n        }\n\n        return encode(x1, x2);\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Safe Cast Library\n * @author Trader Joe\n * @notice This library contains functions to safely cast uint256 to different uint types.\n */\nlibrary SafeCast {\n    error SafeCast__Exceeds248Bits();\n    error SafeCast__Exceeds240Bits();\n    error SafeCast__Exceeds232Bits();\n    error SafeCast__Exceeds224Bits();\n    error SafeCast__Exceeds216Bits();\n    error SafeCast__Exceeds208Bits();\n    error SafeCast__Exceeds200Bits();\n    error SafeCast__Exceeds192Bits();\n    error SafeCast__Exceeds184Bits();\n    error SafeCast__Exceeds176Bits();\n    error SafeCast__Exceeds168Bits();\n    error SafeCast__Exceeds160Bits();\n    error SafeCast__Exceeds152Bits();\n    error SafeCast__Exceeds144Bits();\n    error SafeCast__Exceeds136Bits();\n    error SafeCast__Exceeds128Bits();\n    error SafeCast__Exceeds120Bits();\n    error SafeCast__Exceeds112Bits();\n    error SafeCast__Exceeds104Bits();\n    error SafeCast__Exceeds96Bits();\n    error SafeCast__Exceeds88Bits();\n    error SafeCast__Exceeds80Bits();\n    error SafeCast__Exceeds72Bits();\n    error SafeCast__Exceeds64Bits();\n    error SafeCast__Exceeds56Bits();\n    error SafeCast__Exceeds48Bits();\n    error SafeCast__Exceeds40Bits();\n    error SafeCast__Exceeds32Bits();\n    error SafeCast__Exceeds24Bits();\n    error SafeCast__Exceeds16Bits();\n    error SafeCast__Exceeds8Bits();\n\n    /**\n     * @dev Returns x on uint248 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint248\n     */\n    function safe248(uint256 x) internal pure returns (uint248 y) {\n        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits();\n    }\n\n    /**\n     * @dev Returns x on uint240 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint240\n     */\n    function safe240(uint256 x) internal pure returns (uint240 y) {\n        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits();\n    }\n\n    /**\n     * @dev Returns x on uint232 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint232\n     */\n    function safe232(uint256 x) internal pure returns (uint232 y) {\n        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits();\n    }\n\n    /**\n     * @dev Returns x on uint224 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint224\n     */\n    function safe224(uint256 x) internal pure returns (uint224 y) {\n        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits();\n    }\n\n    /**\n     * @dev Returns x on uint216 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint216\n     */\n    function safe216(uint256 x) internal pure returns (uint216 y) {\n        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits();\n    }\n\n    /**\n     * @dev Returns x on uint208 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint208\n     */\n    function safe208(uint256 x) internal pure returns (uint208 y) {\n        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits();\n    }\n\n    /**\n     * @dev Returns x on uint200 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint200\n     */\n    function safe200(uint256 x) internal pure returns (uint200 y) {\n        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits();\n    }\n\n    /**\n     * @dev Returns x on uint192 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint192\n     */\n    function safe192(uint256 x) internal pure returns (uint192 y) {\n        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits();\n    }\n\n    /**\n     * @dev Returns x on uint184 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint184\n     */\n    function safe184(uint256 x) internal pure returns (uint184 y) {\n        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits();\n    }\n\n    /**\n     * @dev Returns x on uint176 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint176\n     */\n    function safe176(uint256 x) internal pure returns (uint176 y) {\n        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits();\n    }\n\n    /**\n     * @dev Returns x on uint168 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint168\n     */\n    function safe168(uint256 x) internal pure returns (uint168 y) {\n        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits();\n    }\n\n    /**\n     * @dev Returns x on uint160 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint160\n     */\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits();\n    }\n\n    /**\n     * @dev Returns x on uint152 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint152\n     */\n    function safe152(uint256 x) internal pure returns (uint152 y) {\n        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits();\n    }\n\n    /**\n     * @dev Returns x on uint144 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint144\n     */\n    function safe144(uint256 x) internal pure returns (uint144 y) {\n        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits();\n    }\n\n    /**\n     * @dev Returns x on uint136 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint136\n     */\n    function safe136(uint256 x) internal pure returns (uint136 y) {\n        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits();\n    }\n\n    /**\n     * @dev Returns x on uint128 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint128\n     */\n    function safe128(uint256 x) internal pure returns (uint128 y) {\n        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits();\n    }\n\n    /**\n     * @dev Returns x on uint120 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint120\n     */\n    function safe120(uint256 x) internal pure returns (uint120 y) {\n        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits();\n    }\n\n    /**\n     * @dev Returns x on uint112 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint112\n     */\n    function safe112(uint256 x) internal pure returns (uint112 y) {\n        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits();\n    }\n\n    /**\n     * @dev Returns x on uint104 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint104\n     */\n    function safe104(uint256 x) internal pure returns (uint104 y) {\n        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits();\n    }\n\n    /**\n     * @dev Returns x on uint96 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint96\n     */\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits();\n    }\n\n    /**\n     * @dev Returns x on uint88 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint88\n     */\n    function safe88(uint256 x) internal pure returns (uint88 y) {\n        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits();\n    }\n\n    /**\n     * @dev Returns x on uint80 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint80\n     */\n    function safe80(uint256 x) internal pure returns (uint80 y) {\n        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits();\n    }\n\n    /**\n     * @dev Returns x on uint72 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint72\n     */\n    function safe72(uint256 x) internal pure returns (uint72 y) {\n        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits();\n    }\n\n    /**\n     * @dev Returns x on uint64 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint64\n     */\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits();\n    }\n\n    /**\n     * @dev Returns x on uint56 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint56\n     */\n    function safe56(uint256 x) internal pure returns (uint56 y) {\n        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits();\n    }\n\n    /**\n     * @dev Returns x on uint48 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint48\n     */\n    function safe48(uint256 x) internal pure returns (uint48 y) {\n        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits();\n    }\n\n    /**\n     * @dev Returns x on uint40 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint40\n     */\n    function safe40(uint256 x) internal pure returns (uint40 y) {\n        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits();\n    }\n\n    /**\n     * @dev Returns x on uint32 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint32\n     */\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits();\n    }\n\n    /**\n     * @dev Returns x on uint24 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint24\n     */\n    function safe24(uint256 x) internal pure returns (uint24 y) {\n        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits();\n    }\n\n    /**\n     * @dev Returns x on uint16 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint16\n     */\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits();\n    }\n\n    /**\n     * @dev Returns x on uint8 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint8\n     */\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits();\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/SampleMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Encoded} from \"./Encoded.sol\";\n\n/**\n * @title Liquidity Book Sample Math Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode a sample into a single bytes32\n * and interact with the encoded bytes32\n * The sample is encoded as follows:\n * 0 - 16: oracle length (16 bits)\n * 16 - 80: cumulative id (64 bits)\n * 80 - 144: cumulative volatility accumulator (64 bits)\n * 144 - 208: cumulative bin crossed (64 bits)\n * 208 - 216: sample lifetime (8 bits)\n * 216 - 256: sample creation timestamp (40 bits)\n */\nlibrary SampleMath {\n    using Encoded for bytes32;\n\n    uint256 internal constant OFFSET_ORACLE_LENGTH = 0;\n    uint256 internal constant OFFSET_CUMULATIVE_ID = 16;\n    uint256 internal constant OFFSET_CUMULATIVE_VOLATILITY = 80;\n    uint256 internal constant OFFSET_CUMULATIVE_BIN_CROSSED = 144;\n    uint256 internal constant OFFSET_SAMPLE_LIFETIME = 208;\n    uint256 internal constant OFFSET_SAMPLE_CREATION = 216;\n\n    /**\n     * @dev Encodes a sample\n     * @param oracleLength The oracle length\n     * @param cumulativeId The cumulative id\n     * @param cumulativeVolatility The cumulative volatility\n     * @param cumulativeBinCrossed The cumulative bin crossed\n     * @param sampleLifetime The sample lifetime\n     * @param createdAt The sample creation timestamp\n     * @return sample The encoded sample\n     */\n    function encode(\n        uint16 oracleLength,\n        uint64 cumulativeId,\n        uint64 cumulativeVolatility,\n        uint64 cumulativeBinCrossed,\n        uint8 sampleLifetime,\n        uint40 createdAt\n    ) internal pure returns (bytes32 sample) {\n        sample = sample.set(oracleLength, Encoded.MASK_UINT16, OFFSET_ORACLE_LENGTH);\n        sample = sample.set(cumulativeId, Encoded.MASK_UINT64, OFFSET_CUMULATIVE_ID);\n        sample = sample.set(cumulativeVolatility, Encoded.MASK_UINT64, OFFSET_CUMULATIVE_VOLATILITY);\n        sample = sample.set(cumulativeBinCrossed, Encoded.MASK_UINT64, OFFSET_CUMULATIVE_BIN_CROSSED);\n        sample = sample.set(sampleLifetime, Encoded.MASK_UINT8, OFFSET_SAMPLE_LIFETIME);\n        sample = sample.set(createdAt, Encoded.MASK_UINT40, OFFSET_SAMPLE_CREATION);\n    }\n\n    /**\n     * @dev Gets the oracle length from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 16[: oracle length (16 bits)\n     * [16 - 256[: any (240 bits)\n     * @return length The oracle length\n     */\n    function getOracleLength(bytes32 sample) internal pure returns (uint16 length) {\n        return sample.decodeUint16(0);\n    }\n\n    /**\n     * @dev Gets the cumulative id from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 16[: any (16 bits)\n     * [16 - 80[: cumulative id (64 bits)\n     * [80 - 256[: any (176 bits)\n     * @return id The cumulative id\n     */\n    function getCumulativeId(bytes32 sample) internal pure returns (uint64 id) {\n        return sample.decodeUint64(OFFSET_CUMULATIVE_ID);\n    }\n\n    /**\n     * @dev Gets the cumulative volatility accumulator from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 80[: any (80 bits)\n     * [80 - 144[: cumulative volatility accumulator (64 bits)\n     * [144 - 256[: any (112 bits)\n     * @return volatilityAccumulator The cumulative volatility\n     */\n    function getCumulativeVolatility(bytes32 sample) internal pure returns (uint64 volatilityAccumulator) {\n        return sample.decodeUint64(OFFSET_CUMULATIVE_VOLATILITY);\n    }\n\n    /**\n     * @dev Gets the cumulative bin crossed from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 144[: any (144 bits)\n     * [144 - 208[: cumulative bin crossed (64 bits)\n     * [208 - 256[: any (48 bits)\n     * @return binCrossed The cumulative bin crossed\n     */\n    function getCumulativeBinCrossed(bytes32 sample) internal pure returns (uint64 binCrossed) {\n        return sample.decodeUint64(OFFSET_CUMULATIVE_BIN_CROSSED);\n    }\n\n    /**\n     * @dev Gets the sample lifetime from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 208[: any (208 bits)\n     * [208 - 216[: sample lifetime (8 bits)\n     * [216 - 256[: any (40 bits)\n     * @return lifetime The sample lifetime\n     */\n    function getSampleLifetime(bytes32 sample) internal pure returns (uint8 lifetime) {\n        return sample.decodeUint8(OFFSET_SAMPLE_LIFETIME);\n    }\n\n    /**\n     * @dev Gets the sample creation timestamp from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 216[: any (216 bits)\n     * [216 - 256[: sample creation timestamp (40 bits)\n     * @return creation The sample creation timestamp\n     */\n    function getSampleCreation(bytes32 sample) internal pure returns (uint40 creation) {\n        return sample.decodeUint40(OFFSET_SAMPLE_CREATION);\n    }\n\n    /**\n     * @dev Gets the sample last update timestamp from an encoded sample\n     * @param sample The encoded sample as follows:\n     * [0 - 216[: any (216 bits)\n     * [216 - 256[: sample creation timestamp (40 bits)\n     * @return lastUpdate The sample last update timestamp\n     */\n    function getSampleLastUpdate(bytes32 sample) internal pure returns (uint40 lastUpdate) {\n        lastUpdate = getSampleCreation(sample) + getSampleLifetime(sample);\n    }\n\n    /**\n     * @dev Gets the weighted average of two samples and their respective weights\n     * @param sample1 The first encoded sample\n     * @param sample2 The second encoded sample\n     * @param weight1 The weight of the first sample\n     * @param weight2 The weight of the second sample\n     * @return weightedAverageId The weighted average id\n     * @return weightedAverageVolatility The weighted average volatility\n     * @return weightedAverageBinCrossed The weighted average bin crossed\n     */\n    function getWeightedAverage(bytes32 sample1, bytes32 sample2, uint40 weight1, uint40 weight2)\n        internal\n        pure\n        returns (uint64 weightedAverageId, uint64 weightedAverageVolatility, uint64 weightedAverageBinCrossed)\n    {\n        uint256 cId1 = getCumulativeId(sample1);\n        uint256 cVolatility1 = getCumulativeVolatility(sample1);\n        uint256 cBinCrossed1 = getCumulativeBinCrossed(sample1);\n\n        if (weight2 == 0) return (uint64(cId1), uint64(cVolatility1), uint64(cBinCrossed1));\n\n        uint256 cId2 = getCumulativeId(sample2);\n        uint256 cVolatility2 = getCumulativeVolatility(sample2);\n        uint256 cBinCrossed2 = getCumulativeBinCrossed(sample2);\n\n        if (weight1 == 0) return (uint64(cId2), uint64(cVolatility2), uint64(cBinCrossed2));\n\n        uint256 totalWeight = uint256(weight1) + weight2;\n\n        unchecked {\n            weightedAverageId = uint64((cId1 * weight1 + cId2 * weight2) / totalWeight);\n            weightedAverageVolatility = uint64((cVolatility1 * weight1 + cVolatility2 * weight2) / totalWeight);\n            weightedAverageBinCrossed = uint64((cBinCrossed1 * weight1 + cBinCrossed2 * weight2) / totalWeight);\n        }\n    }\n\n    /**\n     * @dev Updates a sample with the given values\n     * @param sample The encoded sample\n     * @param deltaTime The time elapsed since the last update\n     * @param activeId The active id\n     * @param volatilityAccumulator The volatility accumulator\n     * @param binCrossed The bin crossed\n     * @return cumulativeId The cumulative id\n     * @return cumulativeVolatility The cumulative volatility\n     * @return cumulativeBinCrossed The cumulative bin crossed\n     */\n    function update(bytes32 sample, uint40 deltaTime, uint24 activeId, uint24 volatilityAccumulator, uint24 binCrossed)\n        internal\n        pure\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed)\n    {\n        unchecked {\n            cumulativeId = uint64(activeId) * deltaTime;\n            cumulativeVolatility = uint64(volatilityAccumulator) * deltaTime;\n            cumulativeBinCrossed = uint64(binCrossed) * deltaTime;\n        }\n\n        cumulativeId += getCumulativeId(sample);\n        cumulativeVolatility += getCumulativeVolatility(sample);\n        cumulativeBinCrossed += getCumulativeBinCrossed(sample);\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/TreeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Tree Math Library\n * @author Trader Joe\n * @notice This library contains functions to interact with a tree of TreeUint24.\n */\nlibrary TreeMath {\n    using BitMath for uint256;\n\n    struct TreeUint24 {\n        bytes32 level0;\n        mapping(bytes32 => bytes32) level1;\n        mapping(bytes32 => bytes32) level2;\n    }\n\n    /**\n     * @dev Returns true if the tree contains the id\n     * @param tree The tree\n     * @param id The id\n     * @return True if the tree contains the id\n     */\n    function contains(TreeUint24 storage tree, uint24 id) internal view returns (bool) {\n        bytes32 leaf2 = bytes32(uint256(id) >> 8);\n\n        return tree.level2[leaf2] & bytes32(1 << (id & type(uint8).max)) != 0;\n    }\n\n    /**\n     * @dev Adds the id to the tree and returns true if the id was not already in the tree\n     * It will also propagate the change to the parent levels.\n     * @param tree The tree\n     * @param id The id\n     * @return True if the id was not already in the tree\n     */\n    function add(TreeUint24 storage tree, uint24 id) internal returns (bool) {\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n\n        bytes32 leaves = tree.level2[key2];\n        bytes32 newLeaves = leaves | bytes32(1 << (id & type(uint8).max));\n\n        if (leaves != newLeaves) {\n            tree.level2[key2] = newLeaves;\n\n            if (leaves == 0) {\n                bytes32 key1 = key2 >> 8;\n                leaves = tree.level1[key1];\n\n                tree.level1[key1] = leaves | bytes32(1 << (uint256(key2) & type(uint8).max));\n\n                if (leaves == 0) tree.level0 |= bytes32(1 << (uint256(key1) & type(uint8).max));\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Removes the id from the tree and returns true if the id was in the tree.\n     * It will also propagate the change to the parent levels.\n     * @param tree The tree\n     * @param id The id\n     * @return True if the id was in the tree\n     */\n    function remove(TreeUint24 storage tree, uint24 id) internal returns (bool) {\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n\n        bytes32 leaves = tree.level2[key2];\n        bytes32 newLeaves = leaves & ~bytes32(1 << (id & type(uint8).max));\n\n        if (leaves != newLeaves) {\n            tree.level2[key2] = newLeaves;\n\n            if (newLeaves == 0) {\n                bytes32 key1 = key2 >> 8;\n                newLeaves = tree.level1[key1] & ~bytes32(1 << (uint256(key2) & type(uint8).max));\n\n                tree.level1[key1] = newLeaves;\n\n                if (newLeaves == 0) tree.level0 &= ~bytes32(1 << (uint256(key1) & type(uint8).max));\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * @dev Returns the first id in the tree that is lower than or equal to the given id.\n     * It will return type(uint24).max if there is no such id.\n     * @param tree The tree\n     * @param id The id\n     * @return The first id in the tree that is lower than or equal to the given id\n     */\n    function findFirstRight(TreeUint24 storage tree, uint24 id) internal view returns (uint24) {\n        bytes32 leaves;\n\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n        uint8 bit = uint8(id & type(uint8).max);\n\n        if (bit != 0) {\n            leaves = tree.level2[key2];\n            uint256 closestBit = _closestBitRight(leaves, bit);\n\n            if (closestBit != type(uint256).max) return uint24(uint256(key2) << 8 | closestBit);\n        }\n\n        bytes32 key1 = key2 >> 8;\n        bit = uint8(uint256(key2) & type(uint8).max);\n\n        if (bit != 0) {\n            leaves = tree.level1[key1];\n            uint256 closestBit = _closestBitRight(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key2 = bytes32(uint256(key1) << 8 | closestBit);\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).mostSignificantBit());\n            }\n        }\n\n        bit = uint8(uint256(key1) & type(uint8).max);\n\n        if (bit != 0) {\n            leaves = tree.level0;\n            uint256 closestBit = _closestBitRight(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key1 = bytes32(closestBit);\n                leaves = tree.level1[key1];\n\n                key2 = bytes32(uint256(key1) << 8 | uint256(leaves).mostSignificantBit());\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).mostSignificantBit());\n            }\n        }\n\n        return type(uint24).max;\n    }\n\n    /**\n     * @dev Returns the first id in the tree that is higher than or equal to the given id.\n     * It will return 0 if there is no such id.\n     * @param tree The tree\n     * @param id The id\n     * @return The first id in the tree that is higher than or equal to the given id\n     */\n    function findFirstLeft(TreeUint24 storage tree, uint24 id) internal view returns (uint24) {\n        bytes32 leaves;\n\n        bytes32 key2 = bytes32(uint256(id) >> 8);\n        uint8 bit = uint8(id & type(uint8).max);\n\n        if (bit != type(uint8).max) {\n            leaves = tree.level2[key2];\n            uint256 closestBit = _closestBitLeft(leaves, bit);\n\n            if (closestBit != type(uint256).max) return uint24(uint256(key2) << 8 | closestBit);\n        }\n\n        bytes32 key1 = key2 >> 8;\n        bit = uint8(uint256(key2) & type(uint8).max);\n\n        if (bit != type(uint8).max) {\n            leaves = tree.level1[key1];\n            uint256 closestBit = _closestBitLeft(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key2 = bytes32(uint256(key1) << 8 | closestBit);\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).leastSignificantBit());\n            }\n        }\n\n        bit = uint8(uint256(key1) & type(uint8).max);\n\n        if (bit != type(uint8).max) {\n            leaves = tree.level0;\n            uint256 closestBit = _closestBitLeft(leaves, bit);\n\n            if (closestBit != type(uint256).max) {\n                key1 = bytes32(closestBit);\n                leaves = tree.level1[key1];\n\n                key2 = bytes32(uint256(key1) << 8 | uint256(leaves).leastSignificantBit());\n                leaves = tree.level2[key2];\n\n                return uint24(uint256(key2) << 8 | uint256(leaves).leastSignificantBit());\n            }\n        }\n\n        return 0;\n    }\n\n    /**\n     * @dev Returns the first bit in the given leaves that is strictly lower than the given bit.\n     * It will return type(uint256).max if there is no such bit.\n     * @param leaves The leaves\n     * @param bit The bit\n     * @return The first bit in the given leaves that is strictly lower than the given bit\n     */\n    function _closestBitRight(bytes32 leaves, uint8 bit) private pure returns (uint256) {\n        unchecked {\n            return uint256(leaves).closestBitRight(bit - 1);\n        }\n    }\n\n    /**\n     * @dev Returns the first bit in the given leaves that is strictly higher than the given bit.\n     * It will return type(uint256).max if there is no such bit.\n     * @param leaves The leaves\n     * @param bit The bit\n     * @return The first bit in the given leaves that is strictly higher than the given bit\n     */\n    function _closestBitLeft(bytes32 leaves, uint8 bit) private pure returns (uint256) {\n        unchecked {\n            return uint256(leaves).closestBitLeft(bit + 1);\n        }\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/Uint128x128Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"../Constants.sol\";\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Uint128x128 Math Library\n * @author Trader Joe\n * @notice Helper contract used for power and log calculations\n */\nlibrary Uint128x128Math {\n    using BitMath for uint256;\n\n    error Uint128x128Math__LogUnderflow();\n    error Uint128x128Math__PowUnderflow(uint256 x, int256 y);\n\n    uint256 constant LOG_SCALE_OFFSET = 127;\n    uint256 constant LOG_SCALE = 1 << LOG_SCALE_OFFSET;\n    uint256 constant LOG_SCALE_SQUARED = LOG_SCALE * LOG_SCALE;\n\n    /**\n     * @notice Calculates the binary logarithm of x.\n     * @dev Based on the iterative approximation algorithm.\n     * https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n     * Requirements:\n     * - x must be greater than zero.\n     * Caveats:\n     * - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation\n     * Also because x is converted to an unsigned 129.127-binary fixed-point number during the operation to optimize the multiplication\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the binary logarithm.\n     * @return result The binary logarithm as a signed 128.128-binary fixed-point number.\n     */\n    function log2(uint256 x) internal pure returns (int256 result) {\n        // Convert x to a unsigned 129.127-binary fixed-point number to optimize the multiplication.\n        // If we use an offset of 128 bits, y would need 129 bits and y**2 would would overflow and we would have to\n        // use mulDiv, by reducing x to 129.127-binary fixed-point number we assert that y will use 128 bits, and we\n        // can use the regular multiplication\n\n        if (x == 1) return -128;\n        if (x == 0) revert Uint128x128Math__LogUnderflow();\n\n        x >>= 1;\n\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= LOG_SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas\n                x = LOG_SCALE_SQUARED / x;\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = (x >> LOG_SCALE_OFFSET).mostSignificantBit();\n\n            // The integer part of the logarithm as a signed 129.127-binary fixed-point number. The operation can't overflow\n            // because n is maximum 255, LOG_SCALE_OFFSET is 127 bits and sign is either 1 or -1.\n            result = int256(n) << LOG_SCALE_OFFSET;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y != LOG_SCALE) {\n                // Calculate the fractional part via the iterative approximation.\n                // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {\n                    y = (y * y) >> LOG_SCALE_OFFSET;\n\n                    // Is y^2 > 2 and so in the range [2,4)?\n                    if (y >= 1 << (LOG_SCALE_OFFSET + 1)) {\n                        // Add the 2^(-m) factor to the logarithm.\n                        result += delta;\n\n                        // Corresponds to z/2 on Wikipedia.\n                        y >>= 1;\n                    }\n                }\n            }\n            // Convert x back to unsigned 128.128-binary fixed-point number\n            result = (result * sign) << 1;\n        }\n    }\n\n    /**\n     * @notice Returns the value of x^y. It calculates `1 / x^abs(y)` if x is bigger than 2^128.\n     * At the end of the operations, we invert the result if needed.\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the power\n     * @param y A relative number without any decimals, needs to be between ]2^21; 2^21[\n     */\n    function pow(uint256 x, int256 y) internal pure returns (uint256 result) {\n        bool invert;\n        uint256 absY;\n\n        if (y == 0) return Constants.SCALE;\n\n        assembly {\n            absY := y\n            if slt(absY, 0) {\n                absY := sub(0, absY)\n                invert := iszero(invert)\n            }\n        }\n\n        if (absY < 0x100000) {\n            result = Constants.SCALE;\n            assembly {\n                let squared := x\n                if gt(x, 0xffffffffffffffffffffffffffffffff) {\n                    squared := div(not(0), squared)\n                    invert := iszero(invert)\n                }\n\n                if and(absY, 0x1) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x2) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x4) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x8) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x10) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x20) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x40) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x80) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x100) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x200) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x400) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x800) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x1000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x2000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x4000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x8000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x10000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x20000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x40000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x80000) { result := shr(128, mul(result, squared)) }\n            }\n        }\n\n        // revert if y is too big or if x^y underflowed\n        if (result == 0) revert Uint128x128Math__PowUnderflow(x, y);\n\n        return invert ? type(uint256).max / result : result;\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/Uint256x256Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Uint256x256 Math Library\n * @author Trader Joe\n * @notice Helper contract used for full precision calculations\n */\nlibrary Uint256x256Math {\n    error Uint256x256Math__MulShiftOverflow();\n    error Uint256x256Math__MulDivOverflow();\n\n    /**\n     * @notice Calculates floor(x*y/denominator) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x*y/denominator) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        result = mulDivRoundDown(x, y, denominator);\n        if (mulmod(x, y, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundDown(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        if (prod0 != 0) result = prod0 >> offset;\n        if (prod1 != 0) {\n            // Make sure the result is less than 2^256.\n            if (prod1 >= 1 << offset) revert Uint256x256Math__MulShiftOverflow();\n\n            unchecked {\n                result += prod1 << (256 - offset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundUp(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        result = mulShiftRoundDown(x, y, offset);\n        if (mulmod(x, y, 1 << offset) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x << offset / y) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundDown(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n\n        prod0 = x << offset; // Least significant 256 bits of the product\n        unchecked {\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\n        }\n\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x << offset / y) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundUp(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        result = shiftDivRoundDown(x, offset, denominator);\n        if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y` as 2 uint256\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @return prod0 The least significant 256 bits of the product\n     * @return prod1 The most significant 256 bits of the product\n     */\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y / denominator` with full precision\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @param prod0 The least significant 256 bits of the product\n     * @param prod1 The most significant 256 bits of the product\n     * @return result The result as an uint256\n     */\n    function _getEndOfDivRoundDown(uint256 x, uint256 y, uint256 denominator, uint256 prod0, uint256 prod1)\n        private\n        pure\n        returns (uint256 result)\n    {\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n        } else {\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\n            if (prod1 >= denominator) revert Uint256x256Math__MulDivOverflow();\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\n            // See https://cs.stackexchange.com/q/138556/92363\n            unchecked {\n                // Does not overflow because the denominator cannot be zero at this stage in the function\n                uint256 lpotdod = denominator & (~denominator + 1);\n                assembly {\n                    // Divide denominator by lpotdod.\n                    denominator := div(denominator, lpotdod)\n\n                    // Divide [prod1 prod0] by lpotdod.\n                    prod0 := div(prod0, lpotdod)\n\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n                }\n\n                // Shift in bits from prod1 into prod0\n                prod0 |= prod1 * lpotdod;\n\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n                // four bits. That is, denominator * inv = 1 mod 2^4\n                uint256 inverse = (3 * denominator) ^ 2;\n\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n                // in modular arithmetic, doubling the correct bits in each step\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n                // is no longer required.\n                result = prod0 * inverse;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the square root of x\n     * @dev Credit to OpenZeppelin's Math library under MIT license\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 sqrtX) {\n        if (x == 0) return 0;\n\n        uint256 msb = BitMath.mostSignificantBit(x);\n\n        assembly {\n            sqrtX := shl(shr(1, msb), 1)\n\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n\n            x := div(x, sqrtX)\n        }\n\n        return sqrtX < x ? sqrtX : x;\n    }\n}\n"
    },
    "contracts/lib/joe-v2/PriceHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Uint128x128Math} from \"./math/Uint128x128Math.sol\";\nimport {Uint256x256Math} from \"./math/Uint256x256Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * @title Liquidity Book Price Helper Library\n * @author Trader Joe\n * @notice This library contains functions to calculate prices\n */\nlibrary PriceHelper {\n    using Uint128x128Math for uint256;\n    using Uint256x256Math for uint256;\n    using SafeCast for uint256;\n\n    int256 private constant REAL_ID_SHIFT = 1 << 23;\n\n    /**\n     * @dev Calculates the price from the id and the bin step\n     * @param id The id\n     * @param binStep The bin step\n     * @return price The price as a 128.128-binary fixed-point number\n     */\n    function getPriceFromId(uint24 id, uint16 binStep) internal pure returns (uint256 price) {\n        uint256 base = getBase(binStep);\n        int256 exponent = getExponent(id);\n\n        price = base.pow(exponent);\n    }\n\n    /**\n     * @dev Calculates the id from the price and the bin step\n     * @param price The price as a 128.128-binary fixed-point number\n     * @param binStep The bin step\n     * @return id The id\n     */\n    function getIdFromPrice(uint256 price, uint16 binStep) internal pure returns (uint24 id) {\n        uint256 base = getBase(binStep);\n        int256 realId = price.log2() / base.log2();\n\n        unchecked {\n            id = uint256(REAL_ID_SHIFT + realId).safe24();\n        }\n    }\n\n    /**\n     * @dev Calculates the base from the bin step, which is `1 + binStep / BASIS_POINT_MAX`\n     * @param binStep The bin step\n     * @return base The base\n     */\n    function getBase(uint16 binStep) internal pure returns (uint256) {\n        unchecked {\n            return Constants.SCALE + (uint256(binStep) << Constants.SCALE_OFFSET) / Constants.BASIS_POINT_MAX;\n        }\n    }\n\n    /**\n     * @dev Calculates the exponent from the id, which is `id - REAL_ID_SHIFT`\n     * @param id The id\n     * @return exponent The exponent\n     */\n    function getExponent(uint24 id) internal pure returns (int256) {\n        unchecked {\n            return int256(uint256(id)) - REAL_ID_SHIFT;\n        }\n    }\n\n    /**\n     * @dev Converts a price with 18 decimals to a 128.128-binary fixed-point number\n     * @param price The price with 18 decimals\n     * @return price128x128 The 128.128-binary fixed-point number\n     */\n    function convertDecimalPriceTo128x128(uint256 price) internal pure returns (uint256) {\n        return price.shiftDivRoundDown(Constants.SCALE_OFFSET, Constants.PRECISION);\n    }\n\n    /**\n     * @dev Converts a 128.128-binary fixed-point number to a price with 18 decimals\n     * @param price128x128 The 128.128-binary fixed-point number\n     * @return price The price with 18 decimals\n     */\n    function convert128x128PriceToDecimal(uint256 price128x128) internal pure returns (uint256) {\n        return price128x128.mulShiftRoundDown(Constants.PRECISION, Constants.SCALE_OFFSET);\n    }\n}\n"
    },
    "contracts/lib/local/DeploymentConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\nimport \"../../interfaces/ITokenManager.sol\";\nimport {DiamondStorageLib} from \"../../lib/DiamondStorageLib.sol\";\n\n/**\n * DeploymentConstants\n * These constants are updated during test and prod deployments using JS scripts. Defined as constants\n * to decrease gas costs. Not meant to be updated unless really necessary.\n * BE CAREFUL WHEN UPDATING. CONSTANTS CAN BE USED AMONG MANY FACETS.\n **/\nlibrary DeploymentConstants {\n\n    // Used for LiquidationBonus calculations\n    uint256 private constant _PERCENTAGE_PRECISION = 1000;\n\n    bytes32 private constant _NATIVE_TOKEN_SYMBOL = 'AVAX';\n\n    address private constant _NATIVE_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    address private constant _DIAMOND_BEACON_ADDRESS = 0x5133BBdfCCa3Eb4F739D599ee4eC45cBCD0E16c5;\n\n    address private constant _SMART_LOANS_FACTORY_ADDRESS = 0x12Bcb546bC60fF39F1Adfc7cE4605d5Bd6a6A876;\n\n    address private constant _TOKEN_MANAGER_ADDRESS = 0xf090f16dEc8b6D24082Edd25B1C8D26f2bC86128;\n\n    address private constant _ADDRESS_PROVIDER = 0xe039608E695D21aB11675EBBA00261A0e750526c;\n\n    address private constant _FEES_TREASURY_ADDREESS = 0x764a9756994f4E6cd9358a6FcD924d566fC2e666;\n\n    address private constant _STABILITY_POOL_ADDREESS = 0x6B9836D18978a2e865A935F12F4f958317DA4619;\n\n    address private constant _FEES_REDISTRIBUTION_ADDREESS = 0x8995d790169023Ee4fF67621948EBDFe7383f59e;\n\n    //implementation-specific\n\n    function getPercentagePrecision() internal pure returns (uint256) {\n        return _PERCENTAGE_PRECISION;\n    }\n\n    //blockchain-specific\n\n    function getNativeTokenSymbol() internal pure returns (bytes32 symbol) {\n        return _NATIVE_TOKEN_SYMBOL;\n    }\n\n    function getNativeToken() internal pure returns (address payable) {\n        return payable(_NATIVE_ADDRESS);\n    }\n\n    //deployment-specific\n\n    function getDiamondAddress() internal pure returns (address) {\n        return _DIAMOND_BEACON_ADDRESS;\n    }\n\n    function getSmartLoansFactoryAddress() internal pure returns (address) {\n        return _SMART_LOANS_FACTORY_ADDRESS;\n    }\n\n    function getTokenManager() internal pure returns (ITokenManager) {\n        return ITokenManager(_TOKEN_MANAGER_ADDRESS);\n    }\n\n    function getAddressProvider() internal pure returns (address) {\n        return _ADDRESS_PROVIDER;\n    }\n\n    function getTreasuryAddress() internal pure returns (address) {\n        return _FEES_TREASURY_ADDREESS;\n    }\n\n    function getStabilityPoolAddress() internal pure returns (address) {\n        return _STABILITY_POOL_ADDREESS;\n    }\n\n    function getFeesRedistributionAddress() internal pure returns (address) {\n        return _FEES_REDISTRIBUTION_ADDREESS;\n    }\n\n    /**\n    * Returns all owned assets keys\n    **/\n    function getAllOwnedAssets() internal view returns (bytes32[] memory result) {\n        DiamondStorageLib.SmartLoanStorage storage sls = DiamondStorageLib.smartLoanStorage();\n        return sls.ownedAssets._inner._keys._inner._values;\n    }\n}"
    },
    "contracts/lib/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c;\n    unchecked { c = a + b; }\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        uint256 c;\n    unchecked { c = a + b; }\n        require(c >= a, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction underflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c;\n    unchecked { c = a * b; }\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c;\n    unchecked { c = a * b; }\n        require(c / a == b, errorMessage);\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}"
    },
    "contracts/lib/SmartLoanLib.sol": {
      "content": ""
    },
    "contracts/lib/SolvencyMethods.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\nimport \"../facets/SolvencyFacetProd.sol\";\nimport \"../facets/AssetsExposureController.sol\";\nimport \"../DiamondHelper.sol\";\n\n// TODO Rename to contract instead of lib\ncontract SolvencyMethods is DiamondHelper, ProxyConnector {\n    // This function executes SolvencyFacetProd.getDebt()\n    function _getDebt() internal virtual returns (uint256 debt) {\n        debt = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getDebt.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getDebt.selector)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getDebtPayable()\n    function _getDebtPayable() internal virtual returns (uint256 debt) {\n        debt = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getDebtPayable.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getDebtPayable.selector)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getDebtWithPrices()\n    function _getDebtWithPrices(SolvencyFacetProd.AssetPrice[] memory debtAssetsPrices) internal virtual returns (uint256 debt) {\n        debt = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getDebtWithPrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getDebtWithPrices.selector, debtAssetsPrices)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.isSolventWithPrices()\n    function _isSolventWithPrices(SolvencyFacetProd.CachedPrices memory cachedPrices) internal virtual returns (bool solvent){\n        solvent = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.isSolventWithPrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.isSolventWithPrices.selector, cachedPrices)\n            ),\n            (bool)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.isSolvent()\n    function _isSolvent() internal virtual returns (bool solvent){\n        solvent = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.isSolvent.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.isSolvent.selector)\n            ),\n            (bool)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.isSolventPayable()\n    function _isSolventPayable() internal virtual returns (bool solvent){\n        solvent = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.isSolventPayable.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.isSolventPayable.selector)\n            ),\n            (bool)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.canRepayDebtFully()\n    function _canRepayDebtFully() internal virtual returns (bool solvent){\n        solvent = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.canRepayDebtFully.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.canRepayDebtFully.selector)\n            ),\n            (bool)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getTotalValue()\n    function _getTotalValue() internal virtual returns (uint256 totalValue) {\n        totalValue = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getTotalValue.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getTotalValue.selector)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getTotalAssetsValue()\n    function _getTotalAssetsValue() internal virtual returns (uint256 assetsValue) {\n        assetsValue = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getTotalAssetsValue.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getTotalAssetsValue.selector)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getThresholdWeightedValuePayable()\n    function _getThresholdWeightedValuePayable() public virtual returns (uint256 twv) {\n        twv = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getThresholdWeightedValuePayable.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getThresholdWeightedValuePayable.selector)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getThresholdWeightedValuePayable()\n    function _getThresholdWeightedValue() public virtual returns (uint256 twv) {\n        twv = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getThresholdWeightedValue.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getThresholdWeightedValue.selector)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getHealthRatioWithPrices()\n    function _getHealthRatioWithPrices(SolvencyFacetProd.CachedPrices memory cachedPrices) public virtual returns (uint256 health) {\n        health = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getHealthRatioWithPrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getHealthRatioWithPrices.selector, cachedPrices)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getHealthRatio()\n    function _getHealthRatio() public virtual returns (uint256 health) {\n        health = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getHealthRatio.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getHealthRatio.selector)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getPrices()\n    function getPrices(bytes32[] memory symbols) internal view virtual returns (uint256[] memory prices) {\n        prices = abi.decode(\n            proxyCalldataView(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getPrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getPrices.selector, symbols)\n            ),\n            (uint256[])\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getPrices()\n    function _getAllPricesForLiquidation(bytes32[] memory assetsToRepay) public virtual returns (SolvencyFacetProd.CachedPrices memory result) {\n        result = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getAllPricesForLiquidation.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getAllPricesForLiquidation.selector, assetsToRepay)\n            ),\n            (SolvencyFacetProd.CachedPrices)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getOwnedAssetsWithNativePrices()\n    function _getOwnedAssetsWithNativePrices() internal virtual returns (SolvencyFacetProd.AssetPrice[] memory ownedAssetsPrices) {\n        ownedAssetsPrices = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getOwnedAssetsWithNativePrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getOwnedAssetsWithNativePrices.selector)\n            ),\n            (SolvencyFacetProd.AssetPrice[])\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getDebtAssetsPrices()\n    function _getDebtAssetsPrices() internal virtual returns (SolvencyFacetProd.AssetPrice[] memory debtAssetsPrices) {\n        debtAssetsPrices = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getDebtAssetsPrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getDebtAssetsPrices.selector)\n            ),\n            (SolvencyFacetProd.AssetPrice[])\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getStakedPositionsPrices()\n    function _getStakedPositionsPrices() internal virtual returns (SolvencyFacetProd.AssetPrice[] memory stakedPositionsPrices) {\n        stakedPositionsPrices = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getStakedPositionsPrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getStakedPositionsPrices.selector)\n            ),\n            (SolvencyFacetProd.AssetPrice[])\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getTotalAssetsValueWithPrices()\n    function _getTotalValueWithPrices(SolvencyFacetProd.AssetPrice[] memory ownedAssetsPrices, SolvencyFacetProd.AssetPrice[] memory stakedPositionsPrices) internal virtual returns (uint256 totalValue) {\n        totalValue = abi.decode(\n            proxyDelegateCalldata(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getTotalValueWithPrices.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getTotalValueWithPrices.selector, ownedAssetsPrices, stakedPositionsPrices)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes SolvencyFacetProd.getPrice()\n    function getPrice(bytes32 symbol) public view virtual returns (uint256 price) {\n        price = abi.decode(\n            proxyCalldataView(\n                DiamondHelper._getFacetAddress(SolvencyFacetProd.getPrice.selector),\n                abi.encodeWithSelector(SolvencyFacetProd.getPrice.selector, symbol)\n            ),\n            (uint256)\n        );\n    }\n\n    // This function executes AssetsExposureController.decreaseAssetsExposure()\n    function _resetPrimeAccountAssetsExposure() public {\n        proxyDelegateCalldata(\n            DiamondHelper._getFacetAddress(AssetsExposureController.resetPrimeAccountAssetsExposure.selector),\n            abi.encodeWithSelector(AssetsExposureController.resetPrimeAccountAssetsExposure.selector)\n        );\n    }\n\n    // This function executes AssetsExposureController.increaseAssetsExposure()\n    function _setPrimeAccountAssetsExposure() public {\n        proxyDelegateCalldata(\n            DiamondHelper._getFacetAddress(AssetsExposureController.setPrimeAccountAssetsExposure.selector),\n            abi.encodeWithSelector(AssetsExposureController.setPrimeAccountAssetsExposure.selector)\n        );\n    }\n\n    /**\n     * Returns IERC20Metadata instance of a token\n     * @param _asset the code of an asset\n     **/\n    function getERC20TokenInstance(bytes32 _asset, bool allowInactive) internal view returns (IERC20Metadata) {\n        return IERC20Metadata(DeploymentConstants.getTokenManager().getAssetAddress(_asset, allowInactive));\n    }\n\n    function _decreaseExposure(ITokenManager tokenManager, address _token, uint256 _amount) internal {\n        if(_amount > 0) {\n            tokenManager.decreaseProtocolExposure(\n                tokenManager.tokenAddressToSymbol(_token),\n                _amount * 1e18 / 10**IERC20Metadata(_token).decimals()\n            );\n            if(IERC20Metadata(_token).balanceOf(address(this)) == 0){\n                DiamondStorageLib.removeOwnedAsset(tokenManager.tokenAddressToSymbol(_token));\n            }\n        }\n    }\n\n    function _increaseExposure(ITokenManager tokenManager, address _token, uint256 _amount) internal {\n        if(_amount > 0) {\n            tokenManager.increaseProtocolExposure(\n                tokenManager.tokenAddressToSymbol(_token),\n                _amount * 1e18 / 10**IERC20Metadata(_token).decimals()\n            );\n            if(IERC20Metadata(_token).balanceOf(address(this)) > 0){\n                DiamondStorageLib.addOwnedAsset(tokenManager.tokenAddressToSymbol(_token), _token);\n            }\n        }\n    }\n\n    modifier recalculateAssetsExposure() {\n        _resetPrimeAccountAssetsExposure();\n        _;\n        _setPrimeAccountAssetsExposure();\n    }\n\n    /**\n    * Checks whether account is solvent (health higher than 1)\n    * @dev This modifier uses the redstone-evm-connector\n    **/\n    modifier remainsSolvent() {\n        _;\n\n        require(_isSolvent(), \"The action may cause an account to become insolvent\");\n    }\n\n    modifier canRepayDebtFully() {\n        _;\n        require(_canRepayDebtFully(), \"Insufficient assets to fully repay the debt\");\n    }\n\n    modifier noBorrowInTheSameBlock() {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        require(ds._lastBorrowTimestamp != block.timestamp, \"Borrowing must happen in a standalone transaction\");\n        _;\n    }\n}\n"
    },
    "contracts/lib/Uint256x256Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Uint256x256 Math Library\n * @author Trader Joe\n * @notice Helper contract used for full precision calculations\n */\nlibrary Uint256x256Math {\n    error Uint256x256Math__MulShiftOverflow();\n    error Uint256x256Math__MulDivOverflow();\n\n    /**\n     * @notice Calculates floor(x*y/denominator) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x*y/denominator) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        result = mulDivRoundDown(x, y, denominator);\n        if (mulmod(x, y, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundDown(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        if (prod0 != 0) result = prod0 >> offset;\n        if (prod1 != 0) {\n            // Make sure the result is less than 2^256.\n            if (prod1 >= 1 << offset) revert Uint256x256Math__MulShiftOverflow();\n\n            unchecked {\n                result += prod1 << (256 - offset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundUp(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        result = mulShiftRoundDown(x, y, offset);\n        if (mulmod(x, y, 1 << offset) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x << offset / y) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundDown(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n\n        prod0 = x << offset; // Least significant 256 bits of the product\n        unchecked {\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\n        }\n\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x << offset / y) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundUp(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        result = shiftDivRoundDown(x, offset, denominator);\n        if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y` as 2 uint256\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @return prod0 The least significant 256 bits of the product\n     * @return prod1 The most significant 256 bits of the product\n     */\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y / denominator` with full precision\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @param prod0 The least significant 256 bits of the product\n     * @param prod1 The most significant 256 bits of the product\n     * @return result The result as an uint256\n     */\n    function _getEndOfDivRoundDown(uint256 x, uint256 y, uint256 denominator, uint256 prod0, uint256 prod1)\n        private\n        pure\n        returns (uint256 result)\n    {\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n        } else {\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\n            if (prod1 >= denominator) revert Uint256x256Math__MulDivOverflow();\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\n            // See https://cs.stackexchange.com/q/138556/92363\n            unchecked {\n                // Does not overflow because the denominator cannot be zero at this stage in the function\n                uint256 lpotdod = denominator & (~denominator + 1);\n                assembly {\n                    // Divide denominator by lpotdod.\n                    denominator := div(denominator, lpotdod)\n\n                    // Divide [prod1 prod0] by lpotdod.\n                    prod0 := div(prod0, lpotdod)\n\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n                }\n\n                // Shift in bits from prod1 into prod0\n                prod0 |= prod1 * lpotdod;\n\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n                // four bits. That is, denominator * inv = 1 mod 2^4\n                uint256 inverse = (3 * denominator) ^ 2;\n\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n                // in modular arithmetic, doubling the correct bits in each step\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n                // is no longer required.\n                result = prod0 * inverse;\n            }\n        }\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/lib/uniswap-v3/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.27;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n\n        //TODO: our change\n        //https://ethereum.stackexchange.com/questions/96642/unary-operator-minus-cannot-be-applied-to-type-uint256\n//        uint256 twos = -denominator & denominator;\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {FullMath} from \"./FullMath.sol\";\nimport {FixedPoint96} from \"./FixedPoint96.sol\";\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n    /// @notice Downcasts uint256 to uint128\n    /// @param x The uint258 to be downcasted\n    /// @return y The passed value, downcasted to uint128\n    function toUint128(uint256 x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount0(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n        return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function getLiquidityForAmount1(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param amount0 The amount of token0 being sent in\n    /// @param amount1 The amount of token1 being sent in\n    /// @return liquidity The maximum amount of liquidity received\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint256 amount0,\n        uint256 amount1\n    ) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n        }\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    function getAmount0ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            FullMath.mulDiv(\n                uint256(liquidity) << FixedPoint96.RESOLUTION,\n                sqrtRatioBX96 - sqrtRatioAX96,\n                sqrtRatioBX96\n            ) / sqrtRatioAX96;\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount of token1\n    function getAmount1ForLiquidity(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    /// @param sqrtRatioX96 A sqrt price representing the current pool prices\n    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary\n    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount of token0\n    /// @return amount1 The amount of token1\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n        } else {\n            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        }\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/OracleLibrary.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0 <0.9.0;\n\nimport './FullMath.sol';\nimport './TickMath.sol';\nimport '../../interfaces/uniswap-v3/IUniswapV3Pool.sol';\n\n/// @title Oracle library\n/// @notice Provides functions to integrate with V3 pool oracle\nlibrary OracleLibrary {\n    /// @notice Calculates time-weighted means of tick and liquidity for a given Uniswap V3 pool\n    /// @param pool Address of the pool that we want to observe\n    /// @param secondsAgo Number of seconds in the past from which to calculate the time-weighted means\n    /// @return arithmeticMeanTick The arithmetic mean tick from (block.timestamp - secondsAgo) to block.timestamp\n    /// @return harmonicMeanLiquidity The harmonic mean liquidity from (block.timestamp - secondsAgo) to block.timestamp\n    function consult(address pool, uint32 secondsAgo)\n        internal\n        view\n        returns (int24 arithmeticMeanTick, uint128 harmonicMeanLiquidity)\n    {\n        require(secondsAgo != 0, 'BP');\n\n        uint32[] memory secondsAgos = new uint32[](2);\n        secondsAgos[0] = secondsAgo;\n        secondsAgos[1] = 0;\n\n        (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) = IUniswapV3Pool(pool)\n            .observe(secondsAgos);\n\n        int56 tickCumulativesDelta = tickCumulatives[1] - tickCumulatives[0];\n        uint160 secondsPerLiquidityCumulativesDelta = secondsPerLiquidityCumulativeX128s[1] -\n            secondsPerLiquidityCumulativeX128s[0];\n\n        arithmeticMeanTick = int24(tickCumulativesDelta / int56(uint56(secondsAgo)));\n        // Always round to negative infinity\n        if (tickCumulativesDelta < 0 && (tickCumulativesDelta % int56(uint56(secondsAgo)) != 0)) arithmeticMeanTick--;\n\n        // We are multiplying here instead of shifting to ensure that harmonicMeanLiquidity doesn't overflow uint128\n        uint192 secondsAgoX160 = uint192(secondsAgo) * type(uint160).max;\n        harmonicMeanLiquidity = uint128(secondsAgoX160 / (uint192(secondsPerLiquidityCumulativesDelta) << 32));\n    }\n\n    /// @notice Given a tick and a token amount, calculates the amount of token received in exchange\n    /// @param tick Tick value used to calculate the quote\n    /// @param baseAmount Amount of token to be converted\n    /// @param baseToken Address of an ERC20 token contract used as the baseAmount denomination\n    /// @param quoteToken Address of an ERC20 token contract used as the quoteAmount denomination\n    /// @return quoteAmount Amount of quoteToken received for baseAmount of baseToken\n    function getQuoteAtTick(\n        int24 tick,\n        uint128 baseAmount,\n        address baseToken,\n        address quoteToken\n    ) internal pure returns (uint256 quoteAmount) {\n        uint160 sqrtRatioX96 = TickMath.getSqrtRatioAtTick(tick);\n\n        // Calculate quoteAmount with better precision if it doesn't overflow when multiplied by itself\n        if (sqrtRatioX96 <= type(uint128).max) {\n            uint256 ratioX192 = uint256(sqrtRatioX96) * sqrtRatioX96;\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX192, baseAmount, 1 << 192)\n                : FullMath.mulDiv(1 << 192, baseAmount, ratioX192);\n        } else {\n            uint256 ratioX128 = FullMath.mulDiv(sqrtRatioX96, sqrtRatioX96, 1 << 64);\n            quoteAmount = baseToken < quoteToken\n                ? FullMath.mulDiv(ratioX128, baseAmount, 1 << 128)\n                : FullMath.mulDiv(1 << 128, baseAmount, ratioX128);\n        }\n    }\n\n    /// @notice Given a pool, it returns the number of seconds ago of the oldest stored observation\n    /// @param pool Address of Uniswap V3 pool that we want to observe\n    /// @return secondsAgo The number of seconds ago of the oldest observation stored for the pool\n    function getOldestObservationSecondsAgo(address pool) internal view returns (uint32 secondsAgo) {\n        (, , uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n        require(observationCardinality > 0, 'NI');\n\n        (uint32 observationTimestamp, , , bool initialized) = IUniswapV3Pool(pool).observations(\n            (observationIndex + 1) % observationCardinality\n        );\n\n        // The next index might not be initialized if the cardinality is in the process of increasing\n        // In this case the oldest observation is always in index 0\n        if (!initialized) {\n            (observationTimestamp, , , ) = IUniswapV3Pool(pool).observations(0);\n        }\n\n        unchecked {\n            secondsAgo = uint32(block.timestamp) - observationTimestamp;\n        }\n    }\n\n    /// @notice Given a pool, it returns the tick value as of the start of the current block\n    /// @param pool Address of Uniswap V3 pool\n    /// @return The tick that the pool was in at the start of the current block\n    function getBlockStartingTickAndLiquidity(address pool) internal view returns (int24, uint128) {\n        (, int24 tick, uint16 observationIndex, uint16 observationCardinality, , , ) = IUniswapV3Pool(pool).slot0();\n\n        // 2 observations are needed to reliably calculate the block starting tick\n        require(observationCardinality > 1, 'NEO');\n\n        // If the latest observation occurred in the past, then no tick-changing trades have happened in this block\n        // therefore the tick in `slot0` is the same as at the beginning of the current block.\n        // We don't need to check if this observation is initialized - it is guaranteed to be.\n        (\n            uint32 observationTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n\n        ) = IUniswapV3Pool(pool).observations(observationIndex);\n        if (observationTimestamp != uint32(block.timestamp)) {\n            return (tick, IUniswapV3Pool(pool).liquidity());\n        }\n\n        uint256 prevIndex = (uint256(observationIndex) + observationCardinality - 1) % observationCardinality;\n        (\n            uint32 prevObservationTimestamp,\n            int56 prevTickCumulative,\n            uint160 prevSecondsPerLiquidityCumulativeX128,\n            bool prevInitialized\n        ) = IUniswapV3Pool(pool).observations(prevIndex);\n\n        require(prevInitialized, 'ONI');\n\n        uint32 delta = observationTimestamp - prevObservationTimestamp;\n        tick = int24((tickCumulative - int56(uint56(prevTickCumulative))) / int56(uint56(delta)));\n        uint128 liquidity = uint128(\n            (uint192(delta) * type(uint160).max) /\n                (uint192(secondsPerLiquidityCumulativeX128 - prevSecondsPerLiquidityCumulativeX128) << 32)\n        );\n        return (tick, liquidity);\n    }\n\n    /// @notice Information for calculating a weighted arithmetic mean tick\n    struct WeightedTickData {\n        int24 tick;\n        uint128 weight;\n    }\n\n    /// @notice Given an array of ticks and weights, calculates the weighted arithmetic mean tick\n    /// @param weightedTickData An array of ticks and weights\n    /// @return weightedArithmeticMeanTick The weighted arithmetic mean tick\n    /// @dev Each entry of `weightedTickData` should represents ticks from pools with the same underlying pool tokens. If they do not,\n    /// extreme care must be taken to ensure that ticks are comparable (including decimal differences).\n    /// @dev Note that the weighted arithmetic mean tick corresponds to the weighted geometric mean price.\n    function getWeightedArithmeticMeanTick(WeightedTickData[] memory weightedTickData)\n        internal\n        pure\n        returns (int24 weightedArithmeticMeanTick)\n    {\n        // Accumulates the sum of products between each tick and its weight\n        int256 numerator;\n\n        // Accumulates the sum of the weights\n        uint256 denominator;\n\n        // Products fit in 152 bits, so it would take an array of length ~2**104 to overflow this logic\n        for (uint256 i; i < weightedTickData.length; i++) {\n            numerator += weightedTickData[i].tick * int256(uint256(weightedTickData[i].weight));\n            denominator += weightedTickData[i].weight;\n        }\n\n        weightedArithmeticMeanTick = int24(numerator / int256(denominator));\n        // Always round to negative infinity\n        if (numerator < 0 && (numerator % int256(denominator) != 0)) weightedArithmeticMeanTick--;\n    }\n\n    /// @notice Returns the \"synthetic\" tick which represents the price of the first entry in `tokens` in terms of the last\n    /// @dev Useful for calculating relative prices along routes.\n    /// @dev There must be one tick for each pairwise set of tokens.\n    /// @param tokens The token contract addresses\n    /// @param ticks The ticks, representing the price of each token pair in `tokens`\n    /// @return syntheticTick The synthetic tick, representing the relative price of the outermost tokens in `tokens`\n    function getChainedPrice(address[] memory tokens, int24[] memory ticks)\n        internal\n        pure\n        returns (int256 syntheticTick)\n    {\n        require(tokens.length - 1 == ticks.length, 'DL');\n        for (uint256 i = 1; i <= ticks.length; i++) {\n            // check the tokens for address sort order, then accumulate the\n            // ticks into the running synthetic tick, ensuring that intermediate tokens \"cancel out\"\n            tokens[i - 1] < tokens[i] ? syntheticTick += ticks[i - 1] : syntheticTick -= ticks[i - 1];\n        }\n    }\n}"
    },
    "contracts/lib/uniswap-v3/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\nlibrary PoolAddress {\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\n\n    /// @notice The identifying key of the pool\n    struct PoolKey {\n        address token0;\n        address token1;\n        uint24 fee;\n    }\n\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\n    /// @param tokenA The first token of a pool, unsorted\n    /// @param tokenB The second token of a pool, unsorted\n    /// @param fee The fee level of the pool\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\n    function getPoolKey(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) internal pure returns (PoolKey memory) {\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\n    }\n\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\n    /// @param factory The Uniswap V3 factory contract address\n    /// @param key The PoolKey\n    /// @return pool The contract address of the V3 pool\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\n        require(key.token0 < key.token1);\n        pool = address(\n        //TODO: changed uint256 casting to uint160(uint)\n            uint160(uint(\n                keccak256(\n                    abi.encodePacked(\n                        hex'ff',\n                        factory,\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\n                        POOL_INIT_CODE_HASH\n                    )\n                )\n            ))\n        );\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/PositionKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nlibrary PositionKey {\n    /// @dev Returns the key of the position in the core library\n    function compute(\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/PositionValue.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport '@uniswap/v3-core/contracts/libraries/FixedPoint128.sol';\nimport '../../interfaces/uniswap-v3/IUniswapV3Pool.sol';\nimport './LiquidityAmounts.sol';\nimport './TickMath.sol';\nimport './PoolAddress.sol';\nimport './PositionKey.sol';\nimport '../../interfaces/uniswap-v3-periphery/INonfungiblePositionManager.sol';\n\n/// @title Returns information about the token value held in a Uniswap V3 NFT\nlibrary PositionValue {\n    /// @notice Returns the total amounts of token0 and token1, i.e. the sum of fees and principal\n    /// that a given nonfungible position manager token is worth\n    /// @param positionManager The Uniswap V3 NonfungiblePositionManager\n    /// @param tokenId The tokenId of the token for which to get the total value\n    /// @param sqrtRatioX96 The square root price X96 for which to calculate the principal amounts\n    /// @return amount0 The total amount of token0 including principal and fees\n    /// @return amount1 The total amount of token1 including principal and fees\n    function total(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        (uint256 amount0Principal, uint256 amount1Principal) = principal(positionManager, tokenId, sqrtRatioX96);\n        (uint256 amount0Fee, uint256 amount1Fee) = fees(positionManager, tokenId);\n        return (amount0Principal + amount0Fee, amount1Principal + amount1Fee);\n    }\n\n    /// @notice Calculates the principal (currently acting as liquidity) owed to the token owner in the event\n    /// that the position is burned\n    /// @param positionManager The Uniswap V3 NonfungiblePositionManager\n    /// @param tokenId The tokenId of the token for which to get the total principal owed\n    /// @param sqrtRatioX96 The square root price X96 for which to calculate the principal amounts\n    /// @return amount0 The principal amount of token0\n    /// @return amount1 The principal amount of token1\n    function principal(\n        INonfungiblePositionManager positionManager,\n        uint256 tokenId,\n        uint160 sqrtRatioX96\n    ) internal view returns (uint256 amount0, uint256 amount1) {\n        (, , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , , ) = positionManager.positions(tokenId);\n\n        return\n            LiquidityAmounts.getAmountsForLiquidity(\n                sqrtRatioX96,\n                TickMath.getSqrtRatioAtTick(tickLower),\n                TickMath.getSqrtRatioAtTick(tickUpper),\n                liquidity\n            );\n    }\n\n    struct FeeParams {\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint128 liquidity;\n        uint256 positionFeeGrowthInside0LastX128;\n        uint256 positionFeeGrowthInside1LastX128;\n        uint256 tokensOwed0;\n        uint256 tokensOwed1;\n    }\n\n    /// @notice Calculates the total fees owed to the token owner\n    /// @param positionManager The Uniswap V3 NonfungiblePositionManager\n    /// @param tokenId The tokenId of the token for which to get the total fees owed\n    /// @return amount0 The amount of fees owed in token0\n    /// @return amount1 The amount of fees owed in token1\n    function fees(INonfungiblePositionManager positionManager, uint256 tokenId)\n        internal\n        view\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (\n            ,\n            ,\n            address token0,\n            address token1,\n            uint24 fee,\n            int24 tickLower,\n            int24 tickUpper,\n            uint128 liquidity,\n            uint256 positionFeeGrowthInside0LastX128,\n            uint256 positionFeeGrowthInside1LastX128,\n            uint256 tokensOwed0,\n            uint256 tokensOwed1\n        ) = positionManager.positions(tokenId);\n\n        return\n            _fees(\n                positionManager,\n                FeeParams({\n                    token0: token0,\n                    token1: token1,\n                    fee: fee,\n                    tickLower: tickLower,\n                    tickUpper: tickUpper,\n                    liquidity: liquidity,\n                    positionFeeGrowthInside0LastX128: positionFeeGrowthInside0LastX128,\n                    positionFeeGrowthInside1LastX128: positionFeeGrowthInside1LastX128,\n                    tokensOwed0: tokensOwed0,\n                    tokensOwed1: tokensOwed1\n                })\n            );\n    }\n\n    function _fees(INonfungiblePositionManager positionManager, FeeParams memory feeParams)\n        private\n        view\n        returns (uint256 amount0, uint256 amount1)\n    {\n        (uint256 poolFeeGrowthInside0LastX128, uint256 poolFeeGrowthInside1LastX128) =\n            _getFeeGrowthInside(\n                IUniswapV3Pool(\n                    PoolAddress.computeAddress(\n                        positionManager.factory(),\n                        PoolAddress.PoolKey({token0: feeParams.token0, token1: feeParams.token1, fee: feeParams.fee})\n                    )\n                ),\n                feeParams.tickLower,\n                feeParams.tickUpper\n            );\n\n        amount0 =\n            FullMath.mulDiv(\n                poolFeeGrowthInside0LastX128 - feeParams.positionFeeGrowthInside0LastX128,\n                feeParams.liquidity,\n                FixedPoint128.Q128\n            ) +\n            feeParams.tokensOwed0;\n\n        amount1 =\n            FullMath.mulDiv(\n                poolFeeGrowthInside1LastX128 - feeParams.positionFeeGrowthInside1LastX128,\n                feeParams.liquidity,\n                FixedPoint128.Q128\n            ) +\n            feeParams.tokensOwed1;\n    }\n\n    function _getFeeGrowthInside(\n        IUniswapV3Pool pool,\n        int24 tickLower,\n        int24 tickUpper\n    ) private view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n        (, int24 tickCurrent, , , , , ) = pool.slot0();\n        (, , uint256 lowerFeeGrowthOutside0X128, uint256 lowerFeeGrowthOutside1X128, , , , ) = pool.ticks(tickLower);\n        (, , uint256 upperFeeGrowthOutside0X128, uint256 upperFeeGrowthOutside1X128, , , , ) = pool.ticks(tickUpper);\n\n        if (tickCurrent < tickLower) {\n            feeGrowthInside0X128 = lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else if (tickCurrent < tickUpper) {\n            uint256 feeGrowthGlobal0X128 = pool.feeGrowthGlobal0X128();\n            uint256 feeGrowthGlobal1X128 = pool.feeGrowthGlobal1X128();\n            feeGrowthInside0X128 = feeGrowthGlobal0X128 - lowerFeeGrowthOutside0X128 - upperFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = feeGrowthGlobal1X128 - lowerFeeGrowthOutside1X128 - upperFeeGrowthOutside1X128;\n        } else {\n            feeGrowthInside0X128 = upperFeeGrowthOutside0X128 - lowerFeeGrowthOutside0X128;\n            feeGrowthInside1X128 = upperFeeGrowthOutside1X128 - lowerFeeGrowthOutside1X128;\n        }\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.27;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = -MIN_TICK;\n\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\n        //TODO: conversion int24 -> int256: check\n        require(absTick <= uint256(int256(MAX_TICK)), 'T');\n\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\n\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/UniswapV3IntegrationHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {FullMath} from \"./FullMath.sol\";\n\nlibrary UniswapV3IntegrationHelper {\n    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\n    //TODO: check what happens to signed\n    function sqrt(uint y) internal pure returns (uint z) {\n        if (y > 3) {\n            z = y;\n            uint x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    //source: https://ethereum.stackexchange.com/questions/98685/computing-the-uniswap-v3-pair-price-from-q64-96-number\n    function sqrtPriceX96ToSqrtUint(uint160 sqrtPriceX96, uint8 decimalsToken0)\n    internal\n    pure\n    returns (uint256)\n    {\n        uint256 numerator1 = uint256(sqrtPriceX96);\n        uint256 numerator2 = 10**decimalsToken0;\n        return FullMath.mulDiv(numerator1, numerator2, 2 ** 96);\n    }\n}\n"
    },
    "contracts/lib/WadRayMath.sol": {
      "content": "// SPDX-License-Identifier: AGPL3\npragma solidity 0.8.27;\n\n/******************\n@title WadRayMath library\n@author Aave\n@dev Provides mul and div function for wads (decimal numbers with 18 digits precision) and rays (decimals with 27 digits)\n@dev https://github.com/aave/aave-protocol/blob/master/contracts/libraries/WadRayMath.sol\n */\n\nlibrary WadRayMath {\n    uint256 internal constant WAD = 1e18;\n    uint256 internal constant halfWAD = WAD / 2;\n\n    uint256 internal constant RAY = 1e27;\n    uint256 internal constant halfRAY = RAY / 2;\n\n    uint256 internal constant WAD_RAY_RATIO = 1e9;\n\n    function ray() internal pure returns (uint256) {\n        return RAY;\n    }\n\n    function wad() internal pure returns (uint256) {\n        return WAD;\n    }\n\n    function halfRay() internal pure returns (uint256) {\n        return halfRAY;\n    }\n\n    function halfWad() internal pure returns (uint256) {\n        return halfWAD;\n    }\n\n    function wadMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        //return halfWAD.add(a.mul(b)).div(WAD);\n        return (halfWAD + (a * b)) / WAD;\n    }\n\n    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        //return halfB.add(a.mul(WAD)).div(b);\n        return (halfB + (a * WAD)) / b;\n    }\n\n    function rayMul(uint256 a, uint256 b) internal pure returns (uint256) {\n        //return halfRAY.add(a.mul(b)).div(RAY);\n        return (halfRAY + (a * b)) / RAY;\n    }\n\n    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 halfB = b / 2;\n\n        //return halfB.add(a.mul(RAY)).div(b);\n        return (halfB + (a * RAY)) / b;\n    }\n\n    function rayToWad(uint256 a) internal pure returns (uint256) {\n        uint256 halfRatio = WAD_RAY_RATIO / 2;\n\n        //return halfRatio.add(a).div(WAD_RAY_RATIO);\n        return (halfRatio + a) / WAD_RAY_RATIO;\n    }\n\n    function wadToRay(uint256 a) internal pure returns (uint256) {\n        //return a.mul(WAD_RAY_RATIO);\n        return a * WAD_RAY_RATIO;\n    }\n\n    /**\n     * @dev calculates base^exp. The code uses the ModExp precompile\n     */\n    //solium-disable-next-line\n    function rayPow(uint256 x, uint256 n) internal pure returns (uint256 z) {\n        z = n % 2 != 0 ? x : RAY;\n\n        for (n /= 2; n != 0; n /= 2) {\n            x = rayMul(x, x);\n\n            if (n % 2 != 0) {\n                z = rayMul(z, x);\n            }\n        }\n    }\n}\n"
    },
    "contracts/LinearIndex.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 97d6cc3cb60bfd6feda4ea784b13bf0e7daac710;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./interfaces/IIndex.sol\";\n\n/**\n * LinearIndex\n * The contract contains logic for time-based index recalculation with minimal memory footprint.\n * It could be used as a base building block for any index-based entities like deposits and loans.\n * The index is updated on a linear basis to the compounding happens when a user decide to accumulate the interests\n **/\ncontract LinearIndex is IIndex, OwnableUpgradeable {\n\n    uint256 private constant SECONDS_IN_YEAR = 365 days;\n    uint256 private constant BASE_RATE = 1e18;\n\n    uint256 public index;\n    uint256 public indexUpdateTime;\n\n    mapping(uint256 => uint256) prevIndex;\n    mapping(address => uint256) userUpdateTime;\n\n    uint256 public rate;\n\n    function initialize(address owner_) external initializer {\n        index = BASE_RATE;\n        indexUpdateTime = block.timestamp;\n\n        __Ownable_init();\n        if (address(owner_) != address(0)) {\n            transferOwnership(owner_);\n        }\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * Sets the new rate\n     * Before the new rate is set, the index is updated accumulating interest\n     * @dev _rate the value of updated rate\n   **/\n    function setRate(uint256 _rate) public override onlyOwner {\n        updateIndex();\n        rate = _rate;\n        emit RateUpdated(rate, block.timestamp);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n\n    /**\n     * Updates user index\n     * It persists the update time and the update index time->index mapping\n     * @dev user address of the index owner\n   **/\n    function updateUser(address user) public override onlyOwner {\n        userUpdateTime[user] = block.timestamp;\n        prevIndex[block.timestamp] = getIndex();\n    }\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Gets current value of the linear index\n     * It recalculates the value on-demand without updating the storage\n     **/\n    function getIndex() public view override returns (uint256) {\n        uint256 period = block.timestamp - indexUpdateTime;\n        if (period > 0) {\n            return index * getLinearFactor(period) / 1e27;\n        } else {\n            return index;\n        }\n    }\n\n    /**\n     * Gets the user value recalculated to the current index\n     * It recalculates the value on-demand without updating the storage\n     * Ray operations round up the result, but it is only an issue for very small values (with an order of magnitude\n     * of 1 Wei)\n     **/\n    function getIndexedValue(uint256 value, address user) public view override returns (uint256) {\n        uint256 userTime = userUpdateTime[user];\n        uint256 prevUserIndex = userTime == 0 ? getIndex() : prevIndex[userTime];\n\n        return value * getIndex() / prevUserIndex;\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function updateIndex() internal {\n        prevIndex[indexUpdateTime] = index;\n\n        index = getIndex();\n        indexUpdateTime = block.timestamp;\n    }\n\n    /**\n     * Returns a linear factor in Ray\n     **/\n    function getLinearFactor(uint256 period) virtual internal view returns (uint256) {\n        return rate * period * 1e9 / SECONDS_IN_YEAR + 1e27;\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev Emitted after updating the current rate\n     * @param updatedRate the value of updated rate\n     * @param timestamp of the rate update\n     **/\n    event RateUpdated(uint256 updatedRate, uint256 timestamp);\n}"
    },
    "contracts/mock/AntiReentrantDiamondStorage.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\n\nimport \"../ReentrancyGuardKeccak.sol\";\n\ncontract AntiReentrantDiamondStorage is ReentrancyGuardKeccak {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {}\n\n    function antiReentrant() public nonReentrant {\n        payable(msg.sender).safeTransferETH(100);\n    }\n}\n"
    },
    "contracts/mock/DestructableContract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\n/**\n * @title DestructableContract\n * @dev For tests\n */\ncontract DestructableContract {\n    fallback() external payable {\n        //just receive funds\n    }\n\n    function destruct(address payable receiverOfFunds) public {\n        selfdestruct(receiverOfFunds);\n    }\n}\n"
    },
    "contracts/mock/DoubleBorrowExecInSingleTx.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"../facets/AssetsOperationsFacet.sol\";\nimport \"../facets/avalanche/PangolinDEXFacet.sol\";\nimport \"../SmartLoansFactory.sol\";\n\n\n/**\n * @title DoubleBorrowExecInSingleTx\n * @dev For tests\n */\ncontract DoubleBorrowExecInSingleTx is ProxyConnector {\n\n    function stringToBytes32(string memory source) public pure returns (bytes32 result) {\n        bytes memory tempEmptyStringTest = bytes(source);\n        if (tempEmptyStringTest.length == 0) {\n            return 0x0;\n        }\n\n        assembly {\n            result := mload(add(source, 32))\n        }\n    }\n\n    address constant WAVAX_ADDRESS = 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7;\n\n    function createLoan(address factoryAddress) public {\n        SmartLoansFactory factory = SmartLoansFactory(factoryAddress);\n        factory.createLoan();\n    }\n\n    function execute(address smartLoanAddress) public {\n        IERC20 token = IERC20(WAVAX_ADDRESS);\n        token.approve(smartLoanAddress, 1 ether);\n\n        proxyCalldata(address(smartLoanAddress), abi.encodeWithSelector(AssetsOperationsFacet.fund.selector, stringToBytes32(\"AVAX\"), 1 ether), false);\n\n        proxyCalldata(address(smartLoanAddress), abi.encodeWithSelector(AssetsOperationsFacet.borrow.selector, stringToBytes32(\"AVAX\"), 1 ether), false);\n        // Should fail with: \"Borrowing must happen in a standalone transaction\"\n        proxyCalldata(address(smartLoanAddress), abi.encodeWithSelector(PangolinDEXFacet.swapPangolin.selector, stringToBytes32(\"AVAX\"), stringToBytes32(\"USDC\"), 1 ether, 1 ether), false);\n    }\n}\n"
    },
    "contracts/mock/IMockIntegrationVault.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ninterface IMockIntegrationVault {\n    function add_liquidity() external;\n\n    function remove_liquidity( ) external;\n}\n"
    },
    "contracts/mock/MockBorrowersRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"../interfaces/IBorrowersRegistry.sol\";\n\n/**\n * @title MockBorrowersRegistry\n * Should be used for test purpose only\n */\ncontract MockBorrowersRegistry is IBorrowersRegistry {\n\n    mapping(address => address) public ownersToLoans;\n    mapping(address => address) public loansToOwners;\n\n    address[] loans;\n\n    function updateRegistry(address loan, address owner) public  {\n        ownersToLoans[owner] = loan;\n        loansToOwners[loan] = owner;\n        loans.push(loan);\n    }\n\n    function canBorrow(address _account) external view override returns (bool) {\n        return loansToOwners[_account] != address(0);\n    }\n\n    function getLoanForOwner(address _user) external view override returns (address) {\n        return ownersToLoans[_user];\n    }\n\n    function getOwnerOfLoan(address _loan) external view override returns (address) {\n        return loansToOwners[_loan];\n    }\n}\n"
    },
    "contracts/mock/MockSmartLoanLogicFacetSetValues.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\ncontract MockSolvencyFacetConstantDebt {\n    /**\n    * Always returns 2137 - used in test suits\n    **/\n    function getDebt() public pure returns (uint256) {\n        return 2137;\n    }\n}\n"
    },
    "contracts/mock/MockToken.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken is ERC20 {\n    constructor(address[] memory airdropUsers) ERC20(\"MockToken\", \"USDT\") {\n\n        for (uint256 i = 0; i < airdropUsers.length; i++) {\n            _mint(airdropUsers[i], 10000 * 10 ** decimals());\n        }\n    }\n}\n"
    },
    "contracts/mock/MockToken6Decimals.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockToken6Decimals is ERC20 {\n    constructor(address[] memory airdropUsers) ERC20(\"MockToken\", \"USDT\") {\n\n        for (uint256 i = 0; i < airdropUsers.length; i++) {\n            _mint(airdropUsers[i], 10000 * 10 ** decimals());\n        }\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mock/MockTokenManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"../TokenManager.sol\";\n\ncontract MockTokenManager is TokenManager {\n    address factoryAddress;\n\n    function setFactoryAddress(address _newAddress) external {\n        factoryAddress = _newAddress;\n    }\n\n    function getSmartLoansFactoryAddress() public view override returns (address) {\n        return factoryAddress;\n    }\n}\n"
    },
    "contracts/mock/MockUpgradedPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"../Pool.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n/**\n * @title MockUpgradedPool\n * @dev A mock implementation of a Pool to check if upgrade mechanism correctly update contrac logic\n */\ncontract MockUpgradedPool is Pool {\n    /**\n     * Dummy implementation recording double deposits\n     * used to test upgrade of contract logic\n     **/\n    function deposit(uint256 amount) public override nonReentrant {\n        _accumulateDepositInterest(msg.sender);\n\n        _transferToPool(msg.sender, amount);\n\n        //change to original deposit method\n        _mint(msg.sender, amount * 2);\n        _updateRates();\n\n        emit Deposit(msg.sender, amount, block.timestamp);\n    }\n}\n"
    },
    "contracts/mock/MockUsd.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\ncontract MockUsd is ERC20 {\n    constructor(address[] memory airdropUsers) ERC20(\"MockToken\", \"USD\") {\n\n        for(uint256 i = 0; i < airdropUsers.length; i++) {\n            _mint(airdropUsers[i], 10000 * 10 ** decimals());\n        }\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return 6;\n    }\n}\n"
    },
    "contracts/mock/MockVariableUtilisationRatesCalculator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title MockVariableUtilisationRatesCalculator\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract MockVariableUtilisationRatesCalculator is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0;\n    uint256 public constant OFFSET_1 = 0.03e18;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.45e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.24e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 3.15e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 2.4e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant MAX_RATE = 0.75e18;\n\n    //20% of spread goes to vesting participants\n    uint256 public spread = 2e17;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        }\n    }\n\n    /* ========== SETTERS ========== */\n    /**\n     * Sets the spread between deposit and borrow rate, number between 0 and 1e18\n     * @param _spread spread defined by user\n     **/\n    function setSpread(uint256 _spread) external onlyOwner {\n        require(_spread < 1e18, \"Spread must be smaller than 1e18\");\n        spread = _spread;\n        emit SpreadChanged(msg.sender, _spread, block.timestamp);\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after changing the spread\n     * @param performer an address of wallet setting a new spread\n     * @param newSpread new spread\n     * @param timestamp time of a spread change\n     **/\n    event SpreadChanged(address indexed performer, uint256 newSpread, uint256 timestamp);\n}"
    },
    "contracts/mock/MockVariableUtilisationRatesCalculatorChangedOffset.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 48991ca286a107aedf142ae9fd21b421b08f5025;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"../interfaces/IRatesCalculator.sol\";\n\n/**\n * @title MockVariableUtilisationRatesCalculatorChangedOffset\n * @dev Contract which calculates the interest rates based on pool utilisation.\n * Utilisation is computed as the ratio between funds borrowed and funds deposited to the pool.\n * Borrowing rates are calculated using a piecewise linear function. The first piece is defined by SLOPE_1\n * and OFFSET (shift). Second piece is defined by SLOPE_2 (calculated off-chain), BREAKPOINT (threshold value above\n * which second piece is considered) and MAX_RATE (value at pool utilisation of 1).\n **/\ncontract MockVariableUtilisationRatesCalculatorChangedOffset is IRatesCalculator, Ownable {\n    uint256 public constant SLOPE_1 = 0;\n    uint256 public constant OFFSET_1 = 0.05e18;\n\n    uint256 public constant BREAKPOINT_1 = 0.6e18;\n\n    uint256 public constant SLOPE_2 = 0.45e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_2 = 0.24e18;\n\n    uint256 public constant BREAKPOINT_2 = 0.8e18;\n\n    uint256 public constant SLOPE_3 = 3.15e18;\n    //negative, hence minus in calculations\n    uint256 public constant OFFSET_3 = 2.4e18;\n\n    // BREAKPOINT must be lower than 1e18\n    uint256 public constant MAX_RATE = 0.75e18;\n\n    //20% of spread goes to vesting participants\n    uint256 public spread = 2e17;\n\n    /* ========== VIEW FUNCTIONS ========== */\n\n    /**\n     * Returns the pool utilisation, which is a ratio between loans and deposits\n     * utilisation = value_of_loans / value_of_deposits\n     * @param _totalLoans total value of loans\n     * @param _totalDeposits total value of deposits\n     **/\n    function getPoolUtilisation(uint256 _totalLoans, uint256 _totalDeposits) public pure returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        return (_totalLoans * 1e18) / _totalDeposits;\n    }\n\n    /**\n     * Returns the current deposit rate\n     * The value is based on the current borrowing rate and satisfies the invariant:\n     * value_of_loans * borrowing_rate = value_of_deposits * deposit_rate\n     * @param _totalLoans total value of loans\n     * @param _totalDeposits total value of deposits\n     **/\n    function calculateDepositRate(uint256 _totalLoans, uint256 _totalDeposits) external view override returns (uint256) {\n        if (_totalDeposits == 0) return 0;\n\n        if (_totalLoans >= _totalDeposits) {\n            return MAX_RATE * (1e18 - spread) / 1e18;\n        } else {\n            uint256 rate = this.calculateBorrowingRate(_totalLoans, _totalDeposits) * (1e18 - spread) * _totalLoans / (_totalDeposits * 1e18);\n            return rate;\n        }\n    }\n\n    /**\n     * Returns the current borrowing rate\n     * The value is based on the pool utilisation according to the piecewise linear formula:\n     * 1) for pool utilisation lower than or equal to breakpoint:\n     * borrowing_rate = SLOPE_1 * utilisation + OFFSET\n     * 2) for pool utilisation greater than breakpoint:\n     * borrowing_rate = SLOPE_2 * utilisation + MAX_RATE - SLOPE_2\n     * @param totalLoans total value of loans\n     * @param totalDeposits total value of deposits\n     **/\n    function calculateBorrowingRate(uint256 totalLoans, uint256 totalDeposits) external pure override returns (uint256) {\n        if (totalDeposits == 0) return OFFSET_1;\n\n        uint256 poolUtilisation = getPoolUtilisation(totalLoans, totalDeposits);\n\n        if (poolUtilisation >= 1e18) {\n            return MAX_RATE;\n        } else if (poolUtilisation <= BREAKPOINT_1) {\n            return (poolUtilisation * SLOPE_1) / 1e18 + OFFSET_1;\n        } else if (poolUtilisation <= BREAKPOINT_2) {\n            return (poolUtilisation * SLOPE_2) / 1e18 - OFFSET_2;\n        } else {\n            // full formula derived from piecewise linear function calculation except for SLOPE_2 subtraction (separated for\n            // unsigned integer safety check)\n            return (poolUtilisation * SLOPE_3) / 1e18 - OFFSET_3;\n        }\n    }\n}"
    },
    "contracts/mock/OpenBorrowersRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"../interfaces/IBorrowersRegistry.sol\";\n\n/**\n * @title OpenBorrowersRegistry\n * It the simpled borrowers registry that allows every account\n * Should be used for test purpose only\n */\ncontract OpenBorrowersRegistry is IBorrowersRegistry {\n    function canBorrow(address _account) external pure override returns (bool) {\n        return true;\n    }\n\n    function getLoanForOwner(address _user) external pure override returns (address) {\n        return address(0);\n    }\n\n    function getOwnerOfLoan(address _loan) external pure override returns (address) {\n        return address(0);\n    }\n}\n"
    },
    "contracts/mock/ReentrantAttack.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.27;\n\nimport \"./AntiReentrantDiamondStorage.sol\";\n\ncontract ReentrantAttack {\n\n    uint256 callCounter = 0;\n    uint256 targetCallCount = 1;\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable {\n        if (callCounter < targetCallCount) {\n            callCounter += 1;\n            AntiReentrantDiamondStorage(payable(msg.sender)).antiReentrant();\n        } else {\n            callCounter = 0;\n        }\n    }\n\n    function changeTargetCallCount(uint256 _newCount) public {\n        targetCallCount = _newCount;\n    }\n\n    function callAntiReentrant(address payable _antiReentrant) external {\n        callCounter += 1;\n        AntiReentrantDiamondStorage(_antiReentrant).antiReentrant();\n    }\n}\n"
    },
    "contracts/mock/TestGmxV2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport \"../interfaces/gmx-v2/Deposit.sol\";\nimport \"../interfaces/gmx-v2/Withdrawal.sol\";\nimport \"../interfaces/gmx-v2/Order.sol\";\nimport \"../interfaces/gmx-v2/BasicMulticall.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"../interfaces/gmx-v2/IDepositCallbackReceiver.sol\";\nimport \"../interfaces/gmx-v2/EventUtils.sol\";\nimport \"../interfaces/gmx-v2/IDepositUtils.sol\";\nimport \"../interfaces/gmx-v2/IWithdrawalUtils.sol\";\nimport \"../interfaces/gmx-v2/IGmxV2Router.sol\";\nimport \"../interfaces/gmx-v2/IWithdrawalCallbackReceiver.sol\";\nimport \"../interfaces/gmx-v2/IGasFeeCallbackReceiver.sol\";\n\ncontract TestGmxV2 is IDepositCallbackReceiver, IWithdrawalCallbackReceiver, IGasFeeCallbackReceiver {\n\n    address GMX_V2_ROUTER = 0x7452c558d45f8afC8c83dAe62C3f8A5BE19c71f6;\n    address GMX_V2_EXCHANGE_ROUTER = 0x7C68C7866A64FA2160F78EEaE12217FFbf871fa8;\n    address GMX_V2_DEPOSIT_VAULT = 0xF89e77e8Dc11691C9e8757e84aaFbCD8A67d7A55;\n    address GMX_V2_WITHDRAWAL_VAULT = 0x0628D46b5D145f183AdB6Ef1f2c97eD1C4701C55;\n    address GM_ETH_USDC = 0x70d95587d40A2caf56bd97485aB3Eec10Bee6336;\n    address ETH = 0x82aF49447D8a07e3bd95BD0d56f35241523fBab1;\n    address USDC = 0xaf88d065e77c8cC2239327C5EDb3A432268e5831;\n\n    function getSelector(string memory _func) internal pure returns (bytes4) {\n        return bytes4(keccak256(bytes(_func)));\n    }\n\n    function depositEthUsdcGmxV2(bool isLongToken, uint256 tokenAmount, uint256 minGmAmount, uint256 executionFee) public payable returns (bytes[] memory) {\n        address depositedToken = isLongToken ? ETH : USDC;\n\n        IERC20(depositedToken).approve(GMX_V2_ROUTER, tokenAmount);\n\n        bytes[] memory data = new bytes[](3);\n\n        data[0] = abi.encodeWithSelector(\n            IGmxV2Router.sendWnt.selector,\n            GMX_V2_DEPOSIT_VAULT,\n            executionFee\n        );\n        data[1] = abi.encodeWithSelector(\n            IGmxV2Router.sendTokens.selector,\n            depositedToken,\n            GMX_V2_DEPOSIT_VAULT,\n            tokenAmount\n        );\n        data[2] = abi.encodeWithSelector(\n            IDepositUtils.createDeposit.selector,\n            IDepositUtils.CreateDepositParams({\n                receiver: address(this), //receiver\n                callbackContract: address(this), //callbackContract\n                uiFeeReceiver: address(0), //uiFeeReceiver\n                market: GM_ETH_USDC, //market\n                initialLongToken: ETH, //initialLongToken\n                initialShortToken: USDC, //initialShortToken\n                longTokenSwapPath: new address[](0), //longTokenSwapPath\n                shortTokenSwapPath: new address[](0), //shortTokenSwapPath\n                minMarketTokens: minGmAmount, //minMarketTokens\n                shouldUnwrapNativeToken: false, //shouldUnwrapNativeToken\n                executionFee: executionFee, //executionFee\n                callbackGasLimit: 100000 //callbackGasLimit\n            })\n        );\n\n        bytes[] memory results = BasicMulticall(GMX_V2_EXCHANGE_ROUTER).multicall{ value: msg.value }(data);\n\n        //TODO: pause the Prime Account\n        return results;\n    }\n\n    //TODO: withdrawal guard\n    function withdrawEthUsdcGmxV2(uint256 gmAmount, uint256 minLongTokenAmount, uint256 minShortTokenAmount, uint256 executionFee) public payable returns (bytes[] memory) {\n        bytes[] memory data = new bytes[](3);\n\n        IERC20(GM_ETH_USDC).approve(GMX_V2_ROUTER, gmAmount);\n\n        data[0] = abi.encodeWithSelector(\n            IGmxV2Router.sendWnt.selector,\n            GMX_V2_WITHDRAWAL_VAULT,\n            executionFee\n        );\n\n        data[1] = abi.encodeWithSelector(\n            IGmxV2Router.sendTokens.selector,\n            GM_ETH_USDC,\n            GMX_V2_WITHDRAWAL_VAULT,\n            gmAmount\n        );\n\n        data[2] = abi.encodeWithSelector(\n            IWithdrawalUtils.createWithdrawal.selector,\n            IWithdrawalUtils.CreateWithdrawalParams({\n                receiver: address(this), //receiver\n                callbackContract: address(this), //callbackContract\n                uiFeeReceiver: address(0), //uiFeeReceiver\n                market: GM_ETH_USDC, //market\n                longTokenSwapPath: new address[](0), //longTokenSwapPath\n                shortTokenSwapPath: new address[](0), //shortTokenSwapPath\n                minLongTokenAmount: minLongTokenAmount,\n                minShortTokenAmount: minShortTokenAmount,\n                shouldUnwrapNativeToken: false, //shouldUnwrapNativeToken\n                executionFee: executionFee, //executionFee\n                callbackGasLimit: 100000 //callbackGasLimit\n            })\n        );\n\n        bytes[] memory results = BasicMulticall(GMX_V2_EXCHANGE_ROUTER).multicall{ value: msg.value }(data);\n\n        //TODO: pause the Prime Account\n        return results;\n    }\n\n    function afterDepositExecution(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external override {\n        //TODO: recalculate asset exposure\n        //TODO: add assets\n        emit DepositExecuted();\n    }\n\n    function afterDepositCancellation(bytes32 key, Deposit.Props memory deposit, EventUtils.EventLogData memory eventData) external override {\n        //TODO: add assets (deposited in previous tx)\n        emit DepositCancelled();\n    }\n\n    function afterWithdrawalExecution(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external override {\n        //TODO: recalculate asset exposure\n        //TODO: add assets\n        emit WithdrawalExecuted();\n    }\n\n    function afterWithdrawalCancellation(bytes32 key, Withdrawal.Props memory withdrawal, EventUtils.EventLogData memory eventData) external override {\n        //TODO: add assets (deposited in previous tx)\n        emit WithdrawalCancelled();\n    }\n\n    function refundExecutionFee(bytes32 key, EventUtils.EventLogData memory eventData) external payable {\n        emit GasFeeRefunded();\n    }\n\n    //TODO: remove, these are mock events\n    event DepositExecuted();\n\n    event DepositCancelled();\n\n    event WithdrawalExecuted();\n\n    event WithdrawalCancelled();\n\n    event GasFeeRefunded();\n}\n\n\n\n"
    },
    "contracts/mock/WAVAX.sol": {
      "content": "/**\n *Submitted for verification at snowtrace.io on 2021-10-26\n*/\n\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n// Contract name, token name, and token symbol modified by Ava Labs 2020\n\npragma solidity ^0.8.4;\n\ncontract WAVAX {\n    string public name     = \"Wrapped AVAX\";\n    string public symbol   = \"WAVAX\";\n    uint8  public decimals = 18;\n\n    event  Approval(address indexed src, address indexed guy, uint wad);\n    event  Transfer(address indexed src, address indexed dst, uint wad);\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    mapping (address => uint)                       public  balanceOf;\n    mapping (address => mapping (address => uint))  public  allowance;\n\n    receive() external payable {\n        deposit();\n    }\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(address src, address dst, uint wad)\n    public\n    returns (bool)\n    {\n        require(balanceOf[src] >= wad);\n\n//        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n//        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n\n\n/*\n                    GNU GENERAL PUBLIC LICENSE\n                       Version 3, 29 June 2007\n\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\n Everyone is permitted to copy and distribute verbatim copies\n of this license document, but changing it is not allowed.\n\n                            Preamble\n\n  The GNU General Public License is a free, copyleft license for\nsoftware and other kinds of works.\n\n  The licenses for most software and other practical works are designed\nto take away your freedom to share and change the works.  By contrast,\nthe GNU General Public License is intended to guarantee your freedom to\nshare and change all versions of a program--to make sure it remains free\nsoftware for all its users.  We, the Free Software Foundation, use the\nGNU General Public License for most of our software; it applies also to\nany other work released this way by its authors.  You can apply it to\nyour programs, too.\n\n  When we speak of free software, we are referring to freedom, not\nprice.  Our General Public Licenses are designed to make sure that you\nhave the freedom to distribute copies of free software (and charge for\nthem if you wish), that you receive source code or can get it if you\nwant it, that you can change the software or use pieces of it in new\nfree programs, and that you know you can do these things.\n\n  To protect your rights, we need to prevent others from denying you\nthese rights or asking you to surrender the rights.  Therefore, you have\ncertain responsibilities if you distribute copies of the software, or if\nyou modify it: responsibilities to respect the freedom of others.\n\n  For example, if you distribute copies of such a program, whether\ngratis or for a fee, you must pass on to the recipients the same\nfreedoms that you received.  You must make sure that they, too, receive\nor can get the source code.  And you must show them these terms so they\nknow their rights.\n\n  Developers that use the GNU GPL protect your rights with two steps:\n(1) assert copyright on the software, and (2) offer you this License\ngiving you legal permission to copy, distribute and/or modify it.\n\n  For the developers' and authors' protection, the GPL clearly explains\nthat there is no warranty for this free software.  For both users' and\nauthors' sake, the GPL requires that modified versions be marked as\nchanged, so that their problems will not be attributed erroneously to\nauthors of previous versions.\n\n  Some devices are designed to deny users access to install or run\nmodified versions of the software inside them, although the manufacturer\ncan do so.  This is fundamentally incompatible with the aim of\nprotecting users' freedom to change the software.  The systematic\npattern of such abuse occurs in the area of products for individuals to\nuse, which is precisely where it is most unacceptable.  Therefore, we\nhave designed this version of the GPL to prohibit the practice for those\nproducts.  If such problems arise substantially in other domains, we\nstand ready to extend this provision to those domains in future versions\nof the GPL, as needed to protect the freedom of users.\n\n  Finally, every program is threatened constantly by software patents.\nStates should not allow patents to restrict development and use of\nsoftware on general-purpose computers, but in those that do, we wish to\navoid the special danger that patents applied to a free program could\nmake it effectively proprietary.  To prevent this, the GPL assures that\npatents cannot be used to render the program non-free.\n\n  The precise terms and conditions for copying, distribution and\nmodification follow.\n\n                       TERMS AND CONDITIONS\n\n  0. Definitions.\n\n  \"This License\" refers to version 3 of the GNU General Public License.\n\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\nworks, such as semiconductor masks.\n\n  \"The Program\" refers to any copyrightable work licensed under this\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\n\"recipients\" may be individuals or organizations.\n\n  To \"modify\" a work means to copy from or adapt all or part of the work\nin a fashion requiring copyright permission, other than the making of an\nexact copy.  The resulting work is called a \"modified version\" of the\nearlier work or a work \"based on\" the earlier work.\n\n  A \"covered work\" means either the unmodified Program or a work based\non the Program.\n\n  To \"propagate\" a work means to do anything with it that, without\npermission, would make you directly or secondarily liable for\ninfringement under applicable copyright law, except executing it on a\ncomputer or modifying a private copy.  Propagation includes copying,\ndistribution (with or without modification), making available to the\npublic, and in some countries other activities as well.\n\n  To \"convey\" a work means any kind of propagation that enables other\nparties to make or receive copies.  Mere interaction with a user through\na computer network, with no transfer of a copy, is not conveying.\n\n  An interactive user interface displays \"Appropriate Legal Notices\"\nto the extent that it includes a convenient and prominently visible\nfeature that (1) displays an appropriate copyright notice, and (2)\ntells the user that there is no warranty for the work (except to the\nextent that warranties are provided), that licensees may convey the\nwork under this License, and how to view a copy of this License.  If\nthe interface presents a list of user commands or options, such as a\nmenu, a prominent item in the list meets this criterion.\n\n  1. Source Code.\n\n  The \"source code\" for a work means the preferred form of the work\nfor making modifications to it.  \"Object code\" means any non-source\nform of a work.\n\n  A \"Standard Interface\" means an interface that either is an official\nstandard defined by a recognized standards body, or, in the case of\ninterfaces specified for a particular programming language, one that\nis widely used among developers working in that language.\n\n  The \"System Libraries\" of an executable work include anything, other\nthan the work as a whole, that (a) is included in the normal form of\npackaging a Major Component, but which is not part of that Major\nComponent, and (b) serves only to enable use of the work with that\nMajor Component, or to implement a Standard Interface for which an\nimplementation is available to the public in source code form.  A\n\"Major Component\", in this context, means a major essential component\n(kernel, window system, and so on) of the specific operating system\n(if any) on which the executable work runs, or a compiler used to\nproduce the work, or an object code interpreter used to run it.\n\n  The \"Corresponding Source\" for a work in object code form means all\nthe source code needed to generate, install, and (for an executable\nwork) run the object code and to modify the work, including scripts to\ncontrol those activities.  However, it does not include the work's\nSystem Libraries, or general-purpose tools or generally available free\nprograms which are used unmodified in performing those activities but\nwhich are not part of the work.  For example, Corresponding Source\nincludes interface definition files associated with source files for\nthe work, and the source code for shared libraries and dynamically\nlinked subprograms that the work is specifically designed to require,\nsuch as by intimate data communication or control flow between those\nsubprograms and other parts of the work.\n\n  The Corresponding Source need not include anything that users\ncan regenerate automatically from other parts of the Corresponding\nSource.\n\n  The Corresponding Source for a work in source code form is that\nsame work.\n\n  2. Basic Permissions.\n\n  All rights granted under this License are granted for the term of\ncopyright on the Program, and are irrevocable provided the stated\nconditions are met.  This License explicitly affirms your unlimited\npermission to run the unmodified Program.  The output from running a\ncovered work is covered by this License only if the output, given its\ncontent, constitutes a covered work.  This License acknowledges your\nrights of fair use or other equivalent, as provided by copyright law.\n\n  You may make, run and propagate covered works that you do not\nconvey, without conditions so long as your license otherwise remains\nin force.  You may convey covered works to others for the sole purpose\nof having them make modifications exclusively for you, or provide you\nwith facilities for running those works, provided that you comply with\nthe terms of this License in conveying all material for which you do\nnot control copyright.  Those thus making or running the covered works\nfor you must do so exclusively on your behalf, under your direction\nand control, on terms that prohibit them from making any copies of\nyour copyrighted material outside their relationship with you.\n\n  Conveying under any other circumstances is permitted solely under\nthe conditions stated below.  Sublicensing is not allowed; section 10\nmakes it unnecessary.\n\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\n\n  No covered work shall be deemed part of an effective technological\nmeasure under any applicable law fulfilling obligations under article\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\nsimilar laws prohibiting or restricting circumvention of such\nmeasures.\n\n  When you convey a covered work, you waive any legal power to forbid\ncircumvention of technological measures to the extent such circumvention\nis effected by exercising rights under this License with respect to\nthe covered work, and you disclaim any intention to limit operation or\nmodification of the work as a means of enforcing, against the work's\nusers, your or third parties' legal rights to forbid circumvention of\ntechnological measures.\n\n  4. Conveying Verbatim Copies.\n\n  You may convey verbatim copies of the Program's source code as you\nreceive it, in any medium, provided that you conspicuously and\nappropriately publish on each copy an appropriate copyright notice;\nkeep intact all notices stating that this License and any\nnon-permissive terms added in accord with section 7 apply to the code;\nkeep intact all notices of the absence of any warranty; and give all\nrecipients a copy of this License along with the Program.\n\n  You may charge any price or no price for each copy that you convey,\nand you may offer support or warranty protection for a fee.\n\n  5. Conveying Modified Source Versions.\n\n  You may convey a work based on the Program, or the modifications to\nproduce it from the Program, in the form of source code under the\nterms of section 4, provided that you also meet all of these conditions:\n\n    a) The work must carry prominent notices stating that you modified\n    it, and giving a relevant date.\n\n    b) The work must carry prominent notices stating that it is\n    released under this License and any conditions added under section\n    7.  This requirement modifies the requirement in section 4 to\n    \"keep intact all notices\".\n\n    c) You must license the entire work, as a whole, under this\n    License to anyone who comes into possession of a copy.  This\n    License will therefore apply, along with any applicable section 7\n    additional terms, to the whole of the work, and all its parts,\n    regardless of how they are packaged.  This License gives no\n    permission to license the work in any other way, but it does not\n    invalidate such permission if you have separately received it.\n\n    d) If the work has interactive user interfaces, each must display\n    Appropriate Legal Notices; however, if the Program has interactive\n    interfaces that do not display Appropriate Legal Notices, your\n    work need not make them do so.\n\n  A compilation of a covered work with other separate and independent\nworks, which are not by their nature extensions of the covered work,\nand which are not combined with it such as to form a larger program,\nin or on a volume of a storage or distribution medium, is called an\n\"aggregate\" if the compilation and its resulting copyright are not\nused to limit the access or legal rights of the compilation's users\nbeyond what the individual works permit.  Inclusion of a covered work\nin an aggregate does not cause this License to apply to the other\nparts of the aggregate.\n\n  6. Conveying Non-Source Forms.\n\n  You may convey a covered work in object code form under the terms\nof sections 4 and 5, provided that you also convey the\nmachine-readable Corresponding Source under the terms of this License,\nin one of these ways:\n\n    a) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by the\n    Corresponding Source fixed on a durable physical medium\n    customarily used for software interchange.\n\n    b) Convey the object code in, or embodied in, a physical product\n    (including a physical distribution medium), accompanied by a\n    written offer, valid for at least three years and valid for as\n    long as you offer spare parts or customer support for that product\n    model, to give anyone who possesses the object code either (1) a\n    copy of the Corresponding Source for all the software in the\n    product that is covered by this License, on a durable physical\n    medium customarily used for software interchange, for a price no\n    more than your reasonable cost of physically performing this\n    conveying of source, or (2) access to copy the\n    Corresponding Source from a network server at no charge.\n\n    c) Convey individual copies of the object code with a copy of the\n    written offer to provide the Corresponding Source.  This\n    alternative is allowed only occasionally and noncommercially, and\n    only if you received the object code with such an offer, in accord\n    with subsection 6b.\n\n    d) Convey the object code by offering access from a designated\n    place (gratis or for a charge), and offer equivalent access to the\n    Corresponding Source in the same way through the same place at no\n    further charge.  You need not require recipients to copy the\n    Corresponding Source along with the object code.  If the place to\n    copy the object code is a network server, the Corresponding Source\n    may be on a different server (operated by you or a third party)\n    that supports equivalent copying facilities, provided you maintain\n    clear directions next to the object code saying where to find the\n    Corresponding Source.  Regardless of what server hosts the\n    Corresponding Source, you remain obligated to ensure that it is\n    available for as long as needed to satisfy these requirements.\n\n    e) Convey the object code using peer-to-peer transmission, provided\n    you inform other peers where the object code and Corresponding\n    Source of the work are being offered to the general public at no\n    charge under subsection 6d.\n\n  A separable portion of the object code, whose source code is excluded\nfrom the Corresponding Source as a System Library, need not be\nincluded in conveying the object code work.\n\n  A \"User Product\" is either (1) a \"consumer product\", which means any\ntangible personal property which is normally used for personal, family,\nor household purposes, or (2) anything designed or sold for incorporation\ninto a dwelling.  In determining whether a product is a consumer product,\ndoubtful cases shall be resolved in favor of coverage.  For a particular\nproduct received by a particular user, \"normally used\" refers to a\ntypical or common use of that class of product, regardless of the status\nof the particular user or of the way in which the particular user\nactually uses, or expects or is expected to use, the product.  A product\nis a consumer product regardless of whether the product has substantial\ncommercial, industrial or non-consumer uses, unless such uses represent\nthe only significant mode of use of the product.\n\n  \"Installation Information\" for a User Product means any methods,\nprocedures, authorization keys, or other information required to install\nand execute modified versions of a covered work in that User Product from\na modified version of its Corresponding Source.  The information must\nsuffice to ensure that the continued functioning of the modified object\ncode is in no case prevented or interfered with solely because\nmodification has been made.\n\n  If you convey an object code work under this section in, or with, or\nspecifically for use in, a User Product, and the conveying occurs as\npart of a transaction in which the right of possession and use of the\nUser Product is transferred to the recipient in perpetuity or for a\nfixed term (regardless of how the transaction is characterized), the\nCorresponding Source conveyed under this section must be accompanied\nby the Installation Information.  But this requirement does not apply\nif neither you nor any third party retains the ability to install\nmodified object code on the User Product (for example, the work has\nbeen installed in ROM).\n\n  The requirement to provide Installation Information does not include a\nrequirement to continue to provide support service, warranty, or updates\nfor a work that has been modified or installed by the recipient, or for\nthe User Product in which it has been modified or installed.  Access to a\nnetwork may be denied when the modification itself materially and\nadversely affects the operation of the network or violates the rules and\nprotocols for communication across the network.\n\n  Corresponding Source conveyed, and Installation Information provided,\nin accord with this section must be in a format that is publicly\ndocumented (and with an implementation available to the public in\nsource code form), and must require no special password or key for\nunpacking, reading or copying.\n\n  7. Additional Terms.\n\n  \"Additional permissions\" are terms that supplement the terms of this\nLicense by making exceptions from one or more of its conditions.\nAdditional permissions that are applicable to the entire Program shall\nbe treated as though they were included in this License, to the extent\nthat they are valid under applicable law.  If additional permissions\napply only to part of the Program, that part may be used separately\nunder those permissions, but the entire Program remains governed by\nthis License without regard to the additional permissions.\n\n  When you convey a copy of a covered work, you may at your option\nremove any additional permissions from that copy, or from any part of\nit.  (Additional permissions may be written to require their own\nremoval in certain cases when you modify the work.)  You may place\nadditional permissions on material, added by you to a covered work,\nfor which you have or can give appropriate copyright permission.\n\n  Notwithstanding any other provision of this License, for material you\nadd to a covered work, you may (if authorized by the copyright holders of\nthat material) supplement the terms of this License with terms:\n\n    a) Disclaiming warranty or limiting liability differently from the\n    terms of sections 15 and 16 of this License; or\n\n    b) Requiring preservation of specified reasonable legal notices or\n    author attributions in that material or in the Appropriate Legal\n    Notices displayed by works containing it; or\n\n    c) Prohibiting misrepresentation of the origin of that material, or\n    requiring that modified versions of such material be marked in\n    reasonable ways as different from the original version; or\n\n    d) Limiting the use for publicity purposes of names of licensors or\n    authors of the material; or\n\n    e) Declining to grant rights under trademark law for use of some\n    trade names, trademarks, or service marks; or\n\n    f) Requiring indemnification of licensors and authors of that\n    material by anyone who conveys the material (or modified versions of\n    it) with contractual assumptions of liability to the recipient, for\n    any liability that these contractual assumptions directly impose on\n    those licensors and authors.\n\n  All other non-permissive additional terms are considered \"further\nrestrictions\" within the meaning of section 10.  If the Program as you\nreceived it, or any part of it, contains a notice stating that it is\ngoverned by this License along with a term that is a further\nrestriction, you may remove that term.  If a license document contains\na further restriction but permits relicensing or conveying under this\nLicense, you may add to a covered work material governed by the terms\nof that license document, provided that the further restriction does\nnot survive such relicensing or conveying.\n\n  If you add terms to a covered work in accord with this section, you\nmust place, in the relevant source files, a statement of the\nadditional terms that apply to those files, or a notice indicating\nwhere to find the applicable terms.\n\n  Additional terms, permissive or non-permissive, may be stated in the\nform of a separately written license, or stated as exceptions;\nthe above requirements apply either way.\n\n  8. Termination.\n\n  You may not propagate or modify a covered work except as expressly\nprovided under this License.  Any attempt otherwise to propagate or\nmodify it is void, and will automatically terminate your rights under\nthis License (including any patent licenses granted under the third\nparagraph of section 11).\n\n  However, if you cease all violation of this License, then your\nlicense from a particular copyright holder is reinstated (a)\nprovisionally, unless and until the copyright holder explicitly and\nfinally terminates your license, and (b) permanently, if the copyright\nholder fails to notify you of the violation by some reasonable means\nprior to 60 days after the cessation.\n\n  Moreover, your license from a particular copyright holder is\nreinstated permanently if the copyright holder notifies you of the\nviolation by some reasonable means, this is the first time you have\nreceived notice of violation of this License (for any work) from that\ncopyright holder, and you cure the violation prior to 30 days after\nyour receipt of the notice.\n\n  Termination of your rights under this section does not terminate the\nlicenses of parties who have received copies or rights from you under\nthis License.  If your rights have been terminated and not permanently\nreinstated, you do not qualify to receive new licenses for the same\nmaterial under section 10.\n\n  9. Acceptance Not Required for Having Copies.\n\n  You are not required to accept this License in order to receive or\nrun a copy of the Program.  Ancillary propagation of a covered work\noccurring solely as a consequence of using peer-to-peer transmission\nto receive a copy likewise does not require acceptance.  However,\nnothing other than this License grants you permission to propagate or\nmodify any covered work.  These actions infringe copyright if you do\nnot accept this License.  Therefore, by modifying or propagating a\ncovered work, you indicate your acceptance of this License to do so.\n\n  10. Automatic Licensing of Downstream Recipients.\n\n  Each time you convey a covered work, the recipient automatically\nreceives a license from the original licensors, to run, modify and\npropagate that work, subject to this License.  You are not responsible\nfor enforcing compliance by third parties with this License.\n\n  An \"entity transaction\" is a transaction transferring control of an\norganization, or substantially all assets of one, or subdividing an\norganization, or merging organizations.  If propagation of a covered\nwork results from an entity transaction, each party to that\ntransaction who receives a copy of the work also receives whatever\nlicenses to the work the party's predecessor in interest had or could\ngive under the previous paragraph, plus a right to possession of the\nCorresponding Source of the work from the predecessor in interest, if\nthe predecessor has it or can get it with reasonable efforts.\n\n  You may not impose any further restrictions on the exercise of the\nrights granted or affirmed under this License.  For example, you may\nnot impose a license fee, royalty, or other charge for exercise of\nrights granted under this License, and you may not initiate litigation\n(including a cross-claim or counterclaim in a lawsuit) alleging that\nany patent claim is infringed by making, using, selling, offering for\nsale, or importing the Program or any portion of it.\n\n  11. Patents.\n\n  A \"contributor\" is a copyright holder who authorizes use under this\nLicense of the Program or a work on which the Program is based.  The\nwork thus licensed is called the contributor's \"contributor version\".\n\n  A contributor's \"essential patent claims\" are all patent claims\nowned or controlled by the contributor, whether already acquired or\nhereafter acquired, that would be infringed by some manner, permitted\nby this License, of making, using, or selling its contributor version,\nbut do not include claims that would be infringed only as a\nconsequence of further modification of the contributor version.  For\npurposes of this definition, \"control\" includes the right to grant\npatent sublicenses in a manner consistent with the requirements of\nthis License.\n\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\npatent license under the contributor's essential patent claims, to\nmake, use, sell, offer for sale, import and otherwise run, modify and\npropagate the contents of its contributor version.\n\n  In the following three paragraphs, a \"patent license\" is any express\nagreement or commitment, however denominated, not to enforce a patent\n(such as an express permission to practice a patent or covenant not to\nsue for patent infringement).  To \"grant\" such a patent license to a\nparty means to make such an agreement or commitment not to enforce a\npatent against the party.\n\n  If you convey a covered work, knowingly relying on a patent license,\nand the Corresponding Source of the work is not available for anyone\nto copy, free of charge and under the terms of this License, through a\npublicly available network server or other readily accessible means,\nthen you must either (1) cause the Corresponding Source to be so\navailable, or (2) arrange to deprive yourself of the benefit of the\npatent license for this particular work, or (3) arrange, in a manner\nconsistent with the requirements of this License, to extend the patent\nlicense to downstream recipients.  \"Knowingly relying\" means you have\nactual knowledge that, but for the patent license, your conveying the\ncovered work in a country, or your recipient's use of the covered work\nin a country, would infringe one or more identifiable patents in that\ncountry that you have reason to believe are valid.\n\n  If, pursuant to or in connection with a single transaction or\narrangement, you convey, or propagate by procuring conveyance of, a\ncovered work, and grant a patent license to some of the parties\nreceiving the covered work authorizing them to use, propagate, modify\nor convey a specific copy of the covered work, then the patent license\nyou grant is automatically extended to all recipients of the covered\nwork and works based on it.\n\n  A patent license is \"discriminatory\" if it does not include within\nthe scope of its coverage, prohibits the exercise of, or is\nconditioned on the non-exercise of one or more of the rights that are\nspecifically granted under this License.  You may not convey a covered\nwork if you are a party to an arrangement with a third party that is\nin the business of distributing software, under which you make payment\nto the third party based on the extent of your activity of conveying\nthe work, and under which the third party grants, to any of the\nparties who would receive the covered work from you, a discriminatory\npatent license (a) in connection with copies of the covered work\nconveyed by you (or copies made from those copies), or (b) primarily\nfor and in connection with specific products or compilations that\ncontain the covered work, unless you entered into that arrangement,\nor that patent license was granted, prior to 28 March 2007.\n\n  Nothing in this License shall be construed as excluding or limiting\nany implied license or other defenses to infringement that may\notherwise be available to you under applicable patent law.\n\n  12. No Surrender of Others' Freedom.\n\n  If conditions are imposed on you (whether by court order, agreement or\notherwise) that contradict the conditions of this License, they do not\nexcuse you from the conditions of this License.  If you cannot convey a\ncovered work so as to satisfy simultaneously your obligations under this\nLicense and any other pertinent obligations, then as a consequence you may\nnot convey it at all.  For example, if you agree to terms that obligate you\nto collect a royalty for further conveying from those to whom you convey\nthe Program, the only way you could satisfy both those terms and this\nLicense would be to refrain entirely from conveying the Program.\n\n  13. Use with the GNU Affero General Public License.\n\n  Notwithstanding any other provision of this License, you have\npermission to link or combine any covered work with a work licensed\nunder version 3 of the GNU Affero General Public License into a single\ncombined work, and to convey the resulting work.  The terms of this\nLicense will continue to apply to the part which is the covered work,\nbut the special requirements of the GNU Affero General Public License,\nsection 13, concerning interaction through a network will apply to the\ncombination as such.\n\n  14. Revised Versions of this License.\n\n  The Free Software Foundation may publish revised and/or new versions of\nthe GNU General Public License from time to time.  Such new versions will\nbe similar in spirit to the present version, but may differ in detail to\naddress new problems or concerns.\n\n  Each version is given a distinguishing version number.  If the\nProgram specifies that a certain numbered version of the GNU General\nPublic License \"or any later version\" applies to it, you have the\noption of following the terms and conditions either of that numbered\nversion or of any later version published by the Free Software\nFoundation.  If the Program does not specify a version number of the\nGNU General Public License, you may choose any version ever published\nby the Free Software Foundation.\n\n  If the Program specifies that a proxy can decide which future\nversions of the GNU General Public License can be used, that proxy's\npublic statement of acceptance of a version permanently authorizes you\nto choose that version for the Program.\n\n  Later license versions may give you additional or different\npermissions.  However, no additional obligations are imposed on any\nauthor or copyright holder as a result of your choosing to follow a\nlater version.\n\n  15. Disclaimer of Warranty.\n\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\n\n  16. Limitation of Liability.\n\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\nSUCH DAMAGES.\n\n  17. Interpretation of Sections 15 and 16.\n\n  If the disclaimer of warranty and limitation of liability provided\nabove cannot be given local legal effect according to their terms,\nreviewing courts shall apply local law that most closely approximates\nan absolute waiver of all civil liability in connection with the\nProgram, unless a warranty or assumption of liability accompanies a\ncopy of the Program in return for a fee.\n\n                     END OF TERMS AND CONDITIONS\n\n            How to Apply These Terms to Your New Programs\n\n  If you develop a new program, and you want it to be of the greatest\npossible use to the public, the best way to achieve this is to make it\nfree software which everyone can redistribute and change under these terms.\n\n  To do so, attach the following notices to the program.  It is safest\nto attach them to the start of each source file to most effectively\nstate the exclusion of warranty; and each file should have at least\nthe \"copyright\" line and a pointer to where the full notice is found.\n\n    <one line to give the program's name and a brief idea of what it does.>\n    Copyright (C) <year>  <name of author>\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\nAlso add information on how to contact you by electronic and paper mail.\n\n  If the program does terminal interaction, make it output a short\nnotice like this when it starts in an interactive mode:\n\n    <program>  Copyright (C) <year>  <name of author>\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\n    This is free software, and you are welcome to redistribute it\n    under certain conditions; type `show c' for details.\n\nThe hypothetical commands `show w' and `show c' should show the appropriate\nparts of the General Public License.  Of course, your program's commands\nmight be different; for a GUI interface, you would use an \"about box\".\n\n  You should also get your employer (if you work as a programmer) or school,\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\nFor more information on this, and how to apply and follow the GNU GPL, see\n<http://www.gnu.org/licenses/>.\n\n  The GNU General Public License does not permit incorporating your program\ninto proprietary programs.  If your program is a subroutine library, you\nmay consider it more useful to permit linking proprietary applications with\nthe library.  If this is what you want to do, use the GNU Lesser General\nPublic License instead of this License.  But first, please read\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\n\n*/"
    },
    "contracts/OnlyOwnerOrInsolvent.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Modified version of Openzeppelin (OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)) ReentrancyGuard\n// contract that uses keccak slots instead of the standard storage layout.\n\nimport {DiamondStorageLib} from \"./lib/DiamondStorageLib.sol\";\nimport \"./lib/SolvencyMethods.sol\";\nimport \"./facets/SmartLoanLiquidationFacet.sol\";\n\npragma solidity 0.8.27;\n\n/**\n * @dev Enforces ownership only if there is no liquidation ongoing\n */\nabstract contract OnlyOwnerOrInsolvent is SolvencyMethods {\n\n    /**\n     * @dev Enforces ownership only if there is no liquidation ongoing\n     */\n    modifier onlyOwnerOrInsolvent() {\n        bool isWhitelistedLiquidator = SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender);\n\n        if (isWhitelistedLiquidator) {\n            require(!_isSolvent(), \"Account is solvent\");\n        } else{\n            DiamondStorageLib.enforceIsContractOwner();\n        }\n\n        _;\n\n        if (!isWhitelistedLiquidator) {\n            require(_isSolvent(), \"Must stay solvent\");\n        }\n    }\n\n    modifier onlyOwnerNoStaySolventOrInsolventPayable() {\n        bool isWhitelistedLiquidator = SmartLoanLiquidationFacet(DeploymentConstants.getDiamondAddress()).isLiquidatorWhitelisted(msg.sender);\n\n        if (isWhitelistedLiquidator) {\n            require(!_isSolventPayable(), \"Account is solvent\");\n        } else{\n            DiamondStorageLib.enforceIsContractOwner();\n        }\n\n        _;\n    }\n}\n"
    },
    "contracts/Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c2bfee98a59745a565435d8d8abe7a9391c35493;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./abstract/PendingOwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"./lib/hexagate/GatorClient.sol\";\nimport \"./interfaces/IIndex.sol\";\nimport \"./interfaces/ITokenManager.sol\";\nimport \"./interfaces/IVPrimeController.sol\";\nimport \"./interfaces/IRatesCalculator.sol\";\nimport \"./interfaces/IBorrowersRegistry.sol\";\nimport \"./interfaces/IPoolRewarder.sol\";\nimport \"./VestingDistributor.sol\";\n\n/**\n * @title Pool\n * @dev Contract allowing user to deposit to and borrow from a dedicated user account\n * Depositors are rewarded with the interest rates collected from borrowers.\n * The interest rates calculation is delegated to an external calculator contract.\n */\ncontract Pool is PendingOwnableUpgradeable, ReentrancyGuardUpgradeable, IERC20, ProxyConnector, GatorClient {\n    using TransferHelper for address payable;\n    using Math for uint256;\n\n    uint256 public totalSupplyCap;\n\n    mapping(address => mapping(address => uint256)) private _allowed;\n    mapping(address => uint256) internal _deposited;\n\n    mapping(address => uint256) public borrowed;\n\n    IRatesCalculator public ratesCalculator;\n    IBorrowersRegistry public borrowersRegistry;\n    IPoolRewarder public poolRewarder;\n\n    IIndex public depositIndex;\n    IIndex public borrowIndex;\n\n    address payable public tokenAddress;\n\n    VestingDistributor public vestingDistributor; // Needs to stay here in order to preserve the storage layout\n\n    uint8 internal _decimals;\n\n    struct LockDetails {\n        uint256 lockTime;\n        uint256 amount;\n        uint256 unlockTime;\n    }\n    mapping(address => LockDetails[]) public locks;\n    uint256 public constant MAX_LOCK_TIME = 3 * 365 days;\n\n    ITokenManager public tokenManager;\n\n\n    /* ========== METHODS ========== */\n\n    /**\n     * Sets new Gator address.\n     * Only the owner of the Contract can execute this function.\n     * @dev gator new gator address\n     **/\n    function setGator(address gator) external onlyOwner {\n        _setGator(gator);\n    }\n\n    function getLockedBalance(address account) public view returns (uint256) {\n        uint256 lockedBalance = 0;\n        for (uint i = 0; i < locks[account].length; i++) {\n            if (locks[account][i].unlockTime > block.timestamp) {\n                lockedBalance += locks[account][i].amount;\n            }\n        }\n        return lockedBalance;\n    }\n\n    function getNotLockedBalance(address account) public view returns (uint256 notLockedBalance) {\n        uint256 lockedBalance = getLockedBalance(account);\n        uint256 balance = balanceOf(account);\n        if(balance < lockedBalance) {\n            notLockedBalance = 0;\n        } else {\n            return balance - lockedBalance;\n        }\n    }\n\n\n    function lockDeposit(uint256 amount, uint256 lockTime) external gated {\n        if (getNotLockedBalance(msg.sender) < amount) {\n            revert InsufficientBalanceToLock();\n        }\n        if (lockTime > MAX_LOCK_TIME) {\n            revert LockTimeExceedsMax();\n        }\n        locks[msg.sender].push(LockDetails(lockTime, amount, block.timestamp + lockTime));\n\n        emit DepositLocked(msg.sender, amount, lockTime, block.timestamp + lockTime);\n\n        notifyVPrimeController(msg.sender);\n    }\n\n\n    /**\n     * @notice Calculates and returns the fully vested locked balance for a given account.\n     * @dev The fully vested locked balance is used in the governance mechanism of the system, specifically for the allocation of vPrime tokens.\n     * The method calculates the fully vested locked balance by iterating over all the locks of the account and summing up the amounts of those locks that are still active (i.e., their `unlockTime` is greater than the current block timestamp). However, the amount of each lock is scaled by the ratio of its `lockTime` to the `MAX_LOCK_TIME` (3 years). This means that the longer the lock time, the larger the contribution of the lock to the fully vested locked balance.\n     * The fully vested locked balance is used to calculate the maximum vPrime allocation for a user. Users accrue vPrime over a period of 3 years, from 0 to the maximum vPrime based on their 10-1 pairs of pool-deposit and sPrime. Locking pool deposits and sPrime immediately vests the vPrime.\n     * @param account The address of the account for which to calculate the fully vested locked balance.\n     * @return fullyVestedBalance The fully vested locked balance of the provided account.\n     */\n    function getFullyVestedLockedBalance(address account) public view returns (uint256 fullyVestedBalance) {\n        fullyVestedBalance = 0;\n        for (uint i = 0; i < locks[account].length; i++) {\n            if (locks[account][i].unlockTime > block.timestamp) { // Lock is still active\n                fullyVestedBalance += locks[account][i].amount * locks[account][i].lockTime / MAX_LOCK_TIME;\n            }\n        }\n    }\n\n    function setTokenManager(ITokenManager _tokenManager) external onlyOwner gated {\n        tokenManager = _tokenManager;\n    }\n\n    function getVPrimeControllerAddress() public view returns (address) {\n        if(address(tokenManager) != address(0)) {\n            return tokenManager.getVPrimeControllerAddress();\n        }\n        return address(0);\n    }\n\n    function initialize(\n        IRatesCalculator ratesCalculator_,\n        IBorrowersRegistry borrowersRegistry_,\n        IIndex depositIndex_,\n        IIndex borrowIndex_,\n        address payable tokenAddress_,\n        IPoolRewarder poolRewarder_,\n        uint256 totalSupplyCap_\n    ) public initializer {\n        if (\n            !(\n            AddressUpgradeable.isContract(address(ratesCalculator_)) &&\n            AddressUpgradeable.isContract(address(borrowersRegistry_)) &&\n            AddressUpgradeable.isContract(address(depositIndex_)) &&\n            AddressUpgradeable.isContract(address(borrowIndex_)) &&\n            (AddressUpgradeable.isContract(address(poolRewarder_)) || address(poolRewarder_) == address(0))\n        )\n        ) {\n            revert WrongInitArguments();\n        }\n        borrowersRegistry = borrowersRegistry_;\n        ratesCalculator = ratesCalculator_;\n        depositIndex = depositIndex_;\n        borrowIndex = borrowIndex_;\n        poolRewarder = poolRewarder_;\n        tokenAddress = tokenAddress_;\n        totalSupplyCap = totalSupplyCap_;\n        _decimals = IERC20Metadata(tokenAddress_).decimals();\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _updateRates();\n    }\n\n    /* ========== SETTERS ========== */\n\n    /**\n     * Sets new totalSupplyCap limiting how much in total can be deposited to the Pool.\n     * Only the owner of the Contract can execute this function.\n     * @dev _newTotalSupplyCap new deposit cap\n     **/\n    function setTotalSupplyCap(uint256 _newTotalSupplyCap) external onlyOwner gated {\n        totalSupplyCap = _newTotalSupplyCap;\n    }\n\n    /**\n     * Sets the new Pool Rewarder.\n     * The IPoolRewarder that distributes additional token rewards to people having a stake in this pool proportionally to their stake and time of participance.\n     * Only the owner of the Contract can execute this function.\n     * @dev _poolRewarder the address of PoolRewarder\n     **/\n    function setPoolRewarder(IPoolRewarder _poolRewarder) external onlyOwner gated{\n        if (\n            !AddressUpgradeable.isContract(address(_poolRewarder)) &&\n            address(_poolRewarder) != address(0)\n        ) revert NotAContract(address(_poolRewarder));\n        poolRewarder = _poolRewarder;\n\n        emit PoolRewarderChanged(address(_poolRewarder), block.timestamp);\n    }\n\n    /**\n     * Sets the new rate calculator.\n     * The calculator is an external contract that contains the logic for calculating deposit and borrowing rates.\n     * Only the owner of the Contract can execute this function.\n     * @dev ratesCalculator the address of rates calculator\n     **/\n    function setRatesCalculator(\n        IRatesCalculator ratesCalculator_\n    ) external onlyOwner gated {\n        // setting address(0) ratesCalculator_ freezes the pool\n        if (\n            !AddressUpgradeable.isContract(address(ratesCalculator_)) &&\n            address(ratesCalculator_) != address(0)\n        ) revert NotAContract(address(ratesCalculator_));\n        ratesCalculator = ratesCalculator_;\n        if (address(ratesCalculator_) != address(0)) {\n            _updateRates();\n        }\n\n        emit RatesCalculatorChanged(address(ratesCalculator_), block.timestamp);\n    }\n\n    /**\n     * Sets the new borrowers registry contract.\n     * The borrowers registry decides if an account can borrow funds.\n     * Only the owner of the Contract can execute this function.\n     * @dev borrowersRegistry the address of borrowers registry\n     **/\n    function setBorrowersRegistry(\n        IBorrowersRegistry borrowersRegistry_\n    ) external onlyOwner gated {\n        if (!AddressUpgradeable.isContract(address(borrowersRegistry_)))\n            revert NotAContract(address(borrowersRegistry_));\n\n        borrowersRegistry = borrowersRegistry_;\n        emit BorrowersRegistryChanged(address(borrowersRegistry_), block.timestamp);\n    }\n\n    /**\n     * Sets the new Vesting Distributor.\n     * Only the owner of the Contract can execute this function.\n     * @dev _distributor the address of vestingDistributor\n     **/\n    function setVestingDistributor(address _distributor) external onlyOwner gated {\n        if (\n            !AddressUpgradeable.isContract(_distributor) && _distributor != address(0)\n        ) revert NotAContract(_distributor);\n        vestingDistributor = VestingDistributor(_distributor);\n\n        emit VestingDistributorChanged(_distributor, block.timestamp);\n    }\n\n    /* ========== MUTATIVE FUNCTIONS ========== */\n    function transfer(\n        address recipient,\n        uint256 amount\n    ) external override nonReentrant gated returns (bool) {\n        if (recipient == address(0)) revert TransferToZeroAddress();\n\n        if (recipient == address(this)) revert TransferToPoolAddress();\n\n        address account = msg.sender;\n        _accumulateDepositInterest(account);\n\n        (uint256 lockedAmount, uint256 transferrableAmount) = _getAmounts(account);\n        if (amount > transferrableAmount)\n            revert TransferAmountExceedsBalance(amount, transferrableAmount);\n\n        _updateWithdrawn(account, amount, lockedAmount);\n\n        // (this is verified in \"require\" above)\n        unchecked {\n            _deposited[account] -= amount;\n        }\n\n        _accumulateDepositInterest(recipient);\n        _deposited[recipient] += amount;\n\n        // Handle rewards\n        if (\n            address(poolRewarder) != address(0) &&\n            amount != 0 &&\n            !isDepositorExcludedFromRewarder(account) &&\n            !isDepositorExcludedFromRewarder(recipient)\n        ) {\n            uint256 unstaked = poolRewarder.withdrawFor(amount, account);\n            if (unstaked > 0) {\n                poolRewarder.stakeFor(unstaked, recipient);\n            }\n        }\n\n        emit Transfer(account, recipient, amount);\n\n        notifyVPrimeController(msg.sender);\n        notifyVPrimeController(recipient);\n\n        return true;\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view override returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function increaseAllowance(\n        address spender,\n        uint256 addedValue\n    ) external returns (bool) {\n        if (spender == address(0)) revert SpenderZeroAddress();\n        uint256 newAllowance = _allowed[msg.sender][spender] + addedValue;\n        _allowed[msg.sender][spender] = newAllowance;\n\n        emit Approval(msg.sender, spender, newAllowance);\n        return true;\n    }\n\n    function decreaseAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) external gated returns (bool) {\n        if (spender == address(0)) revert SpenderZeroAddress();\n        uint256 currentAllowance = _allowed[msg.sender][spender];\n        if (currentAllowance < subtractedValue)\n            revert InsufficientAllowance(subtractedValue, currentAllowance);\n\n        uint256 newAllowance = currentAllowance - subtractedValue;\n        _allowed[msg.sender][spender] = newAllowance;\n\n        emit Approval(msg.sender, spender, newAllowance);\n        return true;\n    }\n\n    function approve(\n        address spender,\n        uint256 amount\n    ) external gated override returns (bool) {\n        if (spender == address(0)) revert SpenderZeroAddress();\n        _allowed[msg.sender][spender] = amount;\n\n        emit Approval(msg.sender, spender, amount);\n\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external override gated nonReentrant returns (bool) {\n        if (_allowed[sender][msg.sender] < amount)\n            revert InsufficientAllowance(amount, _allowed[sender][msg.sender]);\n\n        if (recipient == address(0)) revert TransferToZeroAddress();\n\n        if (recipient == address(this)) revert TransferToPoolAddress();\n\n        _accumulateDepositInterest(sender);\n\n        (uint256 lockedAmount, uint256 transferrableAmount) = _getAmounts(sender);\n        if (amount > transferrableAmount)\n            revert TransferAmountExceedsBalance(amount, transferrableAmount);\n\n        _updateWithdrawn(sender, amount, lockedAmount);\n\n        _deposited[sender] -= amount;\n        _allowed[sender][msg.sender] -= amount;\n\n        _accumulateDepositInterest(recipient);\n        _deposited[recipient] += amount;\n\n        // Handle rewards\n        if (\n            address(poolRewarder) != address(0) &&\n            amount != 0 &&\n            !isDepositorExcludedFromRewarder(sender) &&\n            !isDepositorExcludedFromRewarder(recipient)\n        ) {\n            uint256 unstaked = poolRewarder.withdrawFor(amount, sender);\n            if (unstaked > 0) {\n                poolRewarder.stakeFor(unstaked, recipient);\n            }\n        }\n\n        emit Transfer(sender, recipient, amount);\n\n        notifyVPrimeController(sender);\n        notifyVPrimeController(recipient);\n\n        return true;\n    }\n\n    /**\n     * Deposits the amount\n     * It updates user deposited balance, total deposited and rates\n     **/\n    function deposit(uint256 _amount) external gated nonReentrant virtual {\n        _depositOnBehalf(_amount, msg.sender);\n    }\n\n    function depositOnBehalf(\n        uint256 _amount,\n        address _of\n    ) external gated nonReentrant virtual {\n        _depositOnBehalf(_amount, _of);\n    }\n\n    /**\n     * Deposits the amount on behalf of `_of` user.\n     * It updates `_of` user deposited balance, total deposited and rates\n     **/\n    function _depositOnBehalf(\n        uint256 _amount,\n        address _of\n    ) internal {\n        if (_amount == 0) revert ZeroDepositAmount();\n        if (_of == address(0)) {\n            revert AddressZero();\n        }\n        if (_of == address(this)) {\n            revert CannotDepositOnBehalfOfPool();\n        }\n\n        _amount = Math.min(_amount, IERC20(tokenAddress).balanceOf(msg.sender));\n\n        _accumulateDepositInterest(_of);\n\n        if (totalSupplyCap != 0) {\n            if (_deposited[address(this)] + _amount > totalSupplyCap)\n                revert TotalSupplyCapBreached();\n        }\n\n        _transferToPool(msg.sender, _amount);\n\n        _mint(_of, _amount);\n        _deposited[address(this)] += _amount;\n        _updateRates();\n\n        if (address(poolRewarder) != address(0) && !isDepositorExcludedFromRewarder(_of)) {\n            poolRewarder.stakeFor(_amount, _of);\n        }\n\n        emit DepositOnBehalfOf(msg.sender, _of, _amount, block.timestamp);\n\n        notifyVPrimeController(_of);\n    }\n\n    function _transferToPool(address from, uint256 amount) internal virtual {\n        tokenAddress.safeTransferFrom(from, address(this), amount);\n    }\n\n    function _transferFromPool(address to, uint256 amount) internal virtual {\n        tokenAddress.safeTransfer(to, amount);\n    }\n\n    function isWithdrawalAmountAvailable(address account, uint256 amount) public view returns (bool) {\n        return amount <= getNotLockedBalance(account);\n    }\n\n    /**\n     * Withdraws selected amount from the user deposits\n     * @dev _amount the amount to be withdrawn\n     **/\n    function withdraw(uint256 _amount) external nonReentrant gated {\n        if (!isWithdrawalAmountAvailable(msg.sender, _amount)) {\n            revert BalanceLocked();\n        }\n\n        _accumulateDepositInterest(msg.sender);\n        _amount = Math.min(_amount, _deposited[msg.sender]);\n\n        if (_amount > IERC20(tokenAddress).balanceOf(address(this)))\n            revert InsufficientPoolFunds();\n\n        if (_amount > _deposited[address(this)]) revert BurnAmountExceedsBalance();\n        // verified in \"require\" above\n        unchecked {\n            _deposited[address(this)] -= _amount;\n        }\n        _burn(msg.sender, _amount);\n\n        _updateRates();\n\n        _transferFromPool(msg.sender, _amount);\n\n        if (address(poolRewarder) != address(0) && !isDepositorExcludedFromRewarder(msg.sender)) {\n            poolRewarder.withdrawFor(_amount, msg.sender);\n        }\n\n        emit Withdrawal(msg.sender, _amount, block.timestamp);\n\n        notifyVPrimeController(msg.sender);\n    }\n\n    /**\n     * Borrows the specified amount\n     * It updates user borrowed balance, total borrowed amount and rates\n     * @dev _amount the amount to be borrowed\n     * @dev It is only meant to be used by a SmartLoanDiamondProxy\n     **/\n    function borrow(uint256 _amount) external virtual canBorrow nonReentrant gated {\n        if (_amount > IERC20(tokenAddress).balanceOf(address(this)))\n            revert InsufficientPoolFunds();\n\n        _accumulateBorrowingInterest(msg.sender);\n\n        borrowed[msg.sender] += _amount;\n        borrowed[address(this)] += _amount;\n\n        _transferFromPool(msg.sender, _amount);\n\n        _updateRates();\n\n        emit Borrowing(msg.sender, _amount, block.timestamp);\n    }\n\n    /**\n     * Repays the amount\n     * It updates user borrowed balance, total borrowed amount and rates\n     * @dev It is only meant to be used by a SmartLoanDiamondProxy\n     **/\n    function repay(uint256 amount) external nonReentrant gated {\n        _accumulateBorrowingInterest(msg.sender);\n\n        if (amount > borrowed[msg.sender]) revert RepayingMoreThanWasBorrowed();\n        _transferToPool(msg.sender, amount);\n\n        borrowed[msg.sender] -= amount;\n        borrowed[address(this)] -= amount;\n\n        _updateRates();\n\n        emit Repayment(msg.sender, amount, block.timestamp);\n    }\n\n    function notifyVPrimeController(address account) internal {\n        address vPrimeControllerAddress = getVPrimeControllerAddress();\n        if(vPrimeControllerAddress != address(0)){\n            if(containsOracleCalldata()) {\n                proxyCalldata(\n                    vPrimeControllerAddress,\n                    abi.encodeWithSignature\n                    (\"updateVPrimeSnapshot(address)\", account),\n                    false\n                );\n            } else {\n                IVPrimeController(vPrimeControllerAddress).setUserNeedsUpdate(account);\n            }\n        }\n    }\n\n    /* =========\n\n\n    /**\n     * Returns the current borrowed amount for the given user\n     * The value includes the interest rates owned at the current moment\n     * @dev _user the address of queried borrower\n    **/\n    function getBorrowed(address _user) public view returns (uint256) {\n        return borrowIndex.getIndexedValue(borrowed[_user], _user);\n    }\n\n    function name() public pure virtual returns (string memory _name) {\n        _name = \"\";\n    }\n\n    function symbol() public pure virtual returns (string memory _symbol) {\n        _symbol = \"\";\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return balanceOf(address(this));\n    }\n\n    function totalBorrowed() public view returns (uint256) {\n        return getBorrowed(address(this));\n    }\n\n    // Calls the IPoolRewarder.getRewardsFor() that sends pending rewards to msg.sender\n    function getRewards() external {\n        poolRewarder.getRewardsFor(msg.sender);\n    }\n\n    // Returns number of pending rewards for msg.sender\n    function checkRewards() external view returns (uint256) {\n        return poolRewarder.earned(msg.sender);\n    }\n\n    // Returns max. acceptable pool utilisation after borrow action\n    function getMaxPoolUtilisationForBorrowing()\n        public\n        view\n        virtual\n        returns (uint256)\n    {\n        return 0.925e18;\n    }\n\n    /**\n     * Returns the current deposited amount for the given user\n     * The value includes the interest rates earned at the current moment\n     * @dev _user the address of queried depositor\n     **/\n    function balanceOf(address user) public view override returns (uint256) {\n        return depositIndex.getIndexedValue(_deposited[user], user);\n    }\n\n    /**\n     * Returns the current interest rate for deposits\n     **/\n    function getDepositRate() public view returns (uint256) {\n        return ratesCalculator.calculateDepositRate(totalBorrowed(), totalSupply());\n    }\n\n    /**\n     * Returns the current interest rate for borrowings\n     **/\n    function getBorrowingRate() public view returns (uint256) {\n        return\n            ratesCalculator.calculateBorrowingRate(totalBorrowed(), totalSupply());\n    }\n\n    /**\n     * Returns full pool status\n     */\n    function getFullPoolStatus() public view returns (uint256[5] memory) {\n        return [\n            totalSupply(),\n            getDepositRate(),\n            getBorrowingRate(),\n            totalBorrowed(),\n            getMaxPoolUtilisationForBorrowing()\n        ];\n    }\n\n    function isDepositorExcludedFromRewarder(address _depositor) internal view returns (bool) {\n        if(\n            _depositor == 0x1d3b1350026195670F8b228711977561Fe3E6001 ||\n            _depositor == 0xf03E2984e549ddc747bc709E6c6eF4791882A502 ||\n            _depositor == 0x6edBA4a5dbB3aEc671f2E1b16a67FA3A076a2ed8 ||\n            _depositor == 0x114989e03993EDc97a5946bBb7Be885EF0aEe9Eb\n        ) {\n            return true;\n        }\n        return false;\n    }\n\n    function containsOracleCalldata() public view returns (bool) {\n        // Checking if the calldata ends with the RedStone marker\n        bool hasValidRedstoneMarker;\n        assembly {\n            let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n            hasValidRedstoneMarker := eq(\n                REDSTONE_MARKER_MASK,\n                and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n            )\n        }\n        return hasValidRedstoneMarker;\n    }\n\n    /**\n     * Recovers the surplus funds resultant from difference between deposit and borrowing rates\n     **/\n    function recoverSurplus(\n        uint256 amount,\n        address account\n    ) external onlyOwner nonReentrant gated {\n        uint256 balance = IERC20(tokenAddress).balanceOf(address(this));\n        uint256 surplus = balance + totalBorrowed() - totalSupply();\n\n        if (amount > balance) revert InsufficientPoolFunds();\n        if (surplus < amount) revert InsufficientSurplus();\n\n        _transferFromPool(account, amount);\n    }\n\n    /* ========== INTERNAL FUNCTIONS ========== */\n\n    function _mint(address to, uint256 amount) internal {\n        if (to == address(0)) revert MintToAddressZero();\n\n        _deposited[to] += amount;\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal {\n        if (amount > _deposited[account]) revert BurnAmountExceedsBalance();\n        (uint256 lockedAmount, uint256 transferrableAmount) = _getAmounts(account);\n        if (amount > transferrableAmount)\n            revert BurnAmountExceedsAvailableForUser();\n\n        _updateWithdrawn(account, amount, lockedAmount);\n\n        // verified in \"require\" above\n        unchecked {\n            _deposited[account] -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _getAmounts(\n        address account\n    ) internal view returns (uint256 lockedAmount, uint256 transferrableAmount) {\n        if (address(vestingDistributor) != address(0)) {\n            lockedAmount = vestingDistributor.locked(account);\n            if (lockedAmount > 0) {\n                transferrableAmount =\n                    _deposited[account] -\n                    (lockedAmount - vestingDistributor.availableToWithdraw(account));\n            } else {\n                transferrableAmount = _deposited[account];\n            }\n        } else {\n            transferrableAmount = _deposited[account];\n        }\n    }\n\n    function _updateWithdrawn(\n        address account,\n        uint256 amount,\n        uint256 lockedAmount\n    ) internal {\n        uint256 availableUnvested = _deposited[account] - lockedAmount;\n        if (\n            amount > availableUnvested && address(vestingDistributor) != address(0)\n        ) {\n            vestingDistributor.updateWithdrawn(account, amount - availableUnvested);\n        }\n    }\n\n    function _updateRates() internal {\n        uint256 _totalBorrowed = totalBorrowed();\n        uint256 _totalSupply = totalSupply();\n        if (address(ratesCalculator) == address(0)) revert PoolFrozen();\n        depositIndex.setRate(\n            ratesCalculator.calculateDepositRate(_totalBorrowed, _totalSupply)\n        );\n        borrowIndex.setRate(\n            ratesCalculator.calculateBorrowingRate(_totalBorrowed, _totalSupply)\n        );\n    }\n\n    function _accumulateDepositInterest(address user) internal {\n        uint256 interest = balanceOf(user) - _deposited[user];\n\n        _mint(user, interest);\n        _deposited[address(this)] = balanceOf(address(this));\n\n        emit InterestCollected(user, interest, block.timestamp);\n\n        depositIndex.updateUser(user);\n        depositIndex.updateUser(address(this));\n    }\n\n    function _accumulateBorrowingInterest(address user) internal {\n        borrowed[user] = getBorrowed(user);\n        borrowed[address(this)] = getBorrowed(address(this));\n\n        borrowIndex.updateUser(user);\n        borrowIndex.updateUser(address(this));\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== MODIFIERS ========== */\n\n    modifier canBorrow() {\n        if (address(borrowersRegistry) == address(0))\n            revert BorrowersRegistryNotConfigured();\n        if (!borrowersRegistry.canBorrow(msg.sender))\n            revert NotAuthorizedToBorrow();\n        if (totalSupply() == 0) revert InsufficientPoolFunds();\n        _;\n        if (\n            (totalBorrowed() * 1e18) / totalSupply() >\n            getMaxPoolUtilisationForBorrowing()\n        ) revert MaxPoolUtilisationBreached();\n    }\n\n    /* ========== EVENTS ========== */\n\n    /**\n     * @dev emitted after the user deposits funds\n     * @param user the address performing the deposit\n     * @param value the amount deposited\n     * @param timestamp of the deposit\n     **/\n    event Deposit(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after the user deposits funds on behalf of other user\n     * @param user the address performing the deposit\n     * @param _of the address on behalf of which the deposit is being performed\n     * @param value the amount deposited\n     * @param timestamp of the deposit\n     **/\n    event DepositOnBehalfOf(\n        address indexed user,\n        address indexed _of,\n        uint256 value,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted after the user withdraws funds\n     * @param user the address performing the withdrawal\n     * @param value the amount withdrawn\n     * @param timestamp of the withdrawal\n     **/\n    event Withdrawal(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after the user borrows funds\n     * @param user the address that borrows\n     * @param value the amount borrowed\n     * @param timestamp time of the borrowing\n     **/\n    event Borrowing(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after the user repays debt\n     * @param user the address that repays debt\n     * @param value the amount repaid\n     * @param timestamp of the repayment\n     **/\n    event Repayment(address indexed user, uint256 value, uint256 timestamp);\n\n    /**\n     * @dev emitted after accumulating deposit interest\n     * @param user the address that the deposit interest is accumulated for\n     * @param value the amount that interest is calculated from\n     * @param timestamp of the interest accumulation\n     **/\n    event InterestCollected(\n        address indexed user,\n        uint256 value,\n        uint256 timestamp\n    );\n\n    /**\n     * @dev emitted after changing borrowers registry\n     * @param registry an address of the newly set borrowers registry\n     * @param timestamp of the borrowers registry change\n     **/\n    event BorrowersRegistryChanged(address indexed registry, uint256 timestamp);\n\n    /**\n     * @dev emitted after changing rates calculator\n     * @param calculator an address of the newly set rates calculator\n     * @param timestamp of the borrowers registry change\n     **/\n    event RatesCalculatorChanged(address indexed calculator, uint256 timestamp);\n\n    /**\n     * @dev emitted after changing pool rewarder\n     * @param poolRewarder an address of the newly set pool rewarder\n     * @param timestamp of the pool rewarder change\n     **/\n    event PoolRewarderChanged(address indexed poolRewarder, uint256 timestamp);\n\n\n    /**\n     * @dev emitted after the user locks deposit\n     * @param user the address that locks the deposit\n     * @param amount the amount locked\n     * @param lockTime the time for which the deposit is locked\n     * @param unlockTime the time when the deposit will be unlocked\n     **/\n    event DepositLocked(address indexed user, uint256 amount, uint256 lockTime, uint256 unlockTime);\n    \n    /**\n     * @dev emitted after changing vesting distributor\n     * @param distributor an address of the newly set distributor\n     * @param timestamp of the distributor change\n     **/\n    event VestingDistributorChanged(\n        address indexed distributor,\n        uint256 timestamp\n    );\n\n\n    /* ========== ERRORS ========== */\n\n    // Only authorized accounts may borrow\n    error NotAuthorizedToBorrow();\n\n    // Borrowers registry is not configured\n    error BorrowersRegistryNotConfigured();\n\n    // Pool is frozen\n    error PoolFrozen();\n\n    // Not enough funds in the pool.\n    error InsufficientPoolFunds();\n\n    // Insufficient pool surplus to cover the requested recover amount\n    error InsufficientSurplus();\n\n    // Address (`target`) must be a contract\n    // @param target target address that must be a contract\n    error NotAContract(address target);\n\n    // ERC20: Spender cannot be a zero address\n    error SpenderZeroAddress();\n\n    // ERC20: Insufficient balance to lock\n    error InsufficientBalanceToLock();\n\n    // ERC20: Lock time exceeds max\n    error LockTimeExceedsMax();\n\n    // ERC20: cannot transfer to the zero address\n    error TransferToZeroAddress();\n\n    // ERC20: cannot transfer to the zero address\n    error AddressZero();\n\n    // ERC20: cannot deposit on behalf of the pool\n    error CannotDepositOnBehalfOfPool();\n\n    // ERC20: cannot transfer to the pool address\n    error TransferToPoolAddress();\n\n    // ERC20: balance is locked\n    error BalanceLocked();\n\n    // ERC20: transfer amount (`amount`) exceeds balance (`balance`)\n    /// @param amount transfer amount\n    /// @param balance available balance\n    error TransferAmountExceedsBalance(uint256 amount, uint256 balance);\n\n    // ERC20: requested transfer amount (`requested`) exceeds current allowance (`allowance`)\n    /// @param requested requested transfer amount\n    /// @param allowance current allowance\n    error InsufficientAllowance(uint256 requested, uint256 allowance);\n\n    // This deposit operation would result in a breach of the totalSupplyCap\n    error TotalSupplyCapBreached();\n\n    // The deposit amount must be > 0\n    error ZeroDepositAmount();\n\n    // Wrong init arguments\n    error WrongInitArguments();\n\n    // ERC20: cannot mint to the zero address\n    error MintToAddressZero();\n\n    // ERC20: burn amount exceeds current pool indexed balance\n    error BurnAmountExceedsBalance();\n\n    // ERC20: burn amount exceeds current amount available (including vesting)\n    error BurnAmountExceedsAvailableForUser();\n\n    // Trying to repay more than was borrowed\n    error RepayingMoreThanWasBorrowed();\n\n    // getMaxPoolUtilisationForBorrowing was breached\n    error MaxPoolUtilisationBreached();\n}\n"
    },
    "contracts/PoolRewarder.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"./interfaces/IPoolRewarder.sol\";\n\ncontract PoolRewarder is IPoolRewarder {\n    using SafeERC20 for IERC20;\n\n    // IERC20 public immutable stakingToken;\n    IERC20 public immutable rewardsToken;\n\n    address public owner;\n    address public pool;\n\n    // Duration of rewards to be paid out (in seconds)\n    uint public duration;\n    // Timestamp of when the rewards finish\n    uint public finishAt;\n    // Minimum of last updated time and reward finish time\n    uint public updatedAt;\n    // Reward to be paid out per second\n    uint public rewardRate;\n    // Sum of (reward rate * dt * 1e18 / total supply)\n    uint public rewardPerTokenStored;\n    // User address => rewardPerTokenStored\n    mapping(address => uint) public userRewardPerTokenPaid;\n    // User address => rewards to be claimed\n    mapping(address => uint) public rewards;\n\n    // Total staked\n    uint public totalSupply;\n    // User address => staked amount\n    mapping(address => uint) public balanceOf;\n\n//    constructor(address _stakingToken, address _rewardToken) {\n    constructor(address _rewardToken, address _pool) {\n        owner = msg.sender;\n        pool = _pool;\n//        stakingToken = IERC20(_stakingToken);\n        rewardsToken = IERC20(_rewardToken);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Unauthorized: onlyOwner\");\n        _;\n    }\n\n    modifier onlyPool() {\n        require(msg.sender == pool, \"Unauthorized: onlyPool\");\n        _;\n    }\n\n    modifier updateReward(address _account) {\n        rewardPerTokenStored = rewardPerToken();\n        updatedAt = lastTimeRewardApplicable();\n\n        if (_account != address(0)) {\n            rewards[_account] = earned(_account);\n            userRewardPerTokenPaid[_account] = rewardPerTokenStored;\n        }\n\n        _;\n    }\n\n    function lastTimeRewardApplicable() public view returns (uint) {\n        return _min(finishAt, block.timestamp);\n    }\n\n    function rewardPerToken() public view returns (uint) {\n        if (totalSupply == 0) {\n            return rewardPerTokenStored;\n        }\n\n        return\n        rewardPerTokenStored +\n        (rewardRate * (lastTimeRewardApplicable() - updatedAt) * 1e18) /\n        totalSupply;\n    }\n\n    function stakeFor(uint _amount, address _stakeFor) external updateReward(_stakeFor) onlyPool {\n        require(_amount > 0, \"amount = 0\");\n//        stakingToken.transferFrom(msg.sender, address(this), _amount);\n        balanceOf[_stakeFor] += _amount;\n        totalSupply += _amount;\n        emit Staked(_stakeFor, _amount, block.timestamp);\n    }\n\n    function withdrawFor(uint _amount, address _unstakeFor) external updateReward(_unstakeFor) onlyPool returns (uint256){\n        require(_amount > 0, \"amount = 0\");\n        if(balanceOf[_unstakeFor] > 0) {\n            uint256 amountToUnstake = _amount > balanceOf[_unstakeFor] ? balanceOf[_unstakeFor] : _amount;\n            balanceOf[_unstakeFor] -= amountToUnstake;\n            totalSupply -= amountToUnstake;\n            //        stakingToken.transfer(msg.sender, _amount);\n            emit Unstaked(_unstakeFor, amountToUnstake, block.timestamp);\n            return amountToUnstake;\n        }\n        return 0;\n    }\n\n    function earned(address _account) public view returns (uint) {\n        return\n        ((balanceOf[_account] *\n        (rewardPerToken() - userRewardPerTokenPaid[_account])) / 1e18) +\n        rewards[_account];\n    }\n\n    function getRewardsFor(address _user) external updateReward(_user) {\n        uint reward = rewards[_user];\n        if (reward > 0) {\n            rewards[_user] = 0;\n            rewardsToken.safeTransfer(_user, reward);\n        }\n    }\n\n    function setRewardsDuration(uint _duration) external onlyOwner {\n        require(finishAt < block.timestamp, \"reward duration not finished\");\n        duration = _duration;\n    }\n\n    function notifyRewardAmount(uint _amount)\n    external\n    onlyOwner\n    updateReward(address(0))\n    {\n        if (block.timestamp >= finishAt) {\n            rewardRate = _amount / duration;\n        } else {\n            uint remainingRewards = (finishAt - block.timestamp) * rewardRate;\n            rewardRate = (_amount + remainingRewards) / duration;\n        }\n\n        require(rewardRate > 0, \"reward rate = 0\");\n        require(\n            rewardRate * duration <= rewardsToken.balanceOf(address(this)),\n            \"reward amount > balance\"\n        );\n\n        finishAt = block.timestamp + duration;\n        updatedAt = block.timestamp;\n    }\n\n    function _min(uint x, uint y) private pure returns (uint) {\n        return x <= y ? x : y;\n    }\n\n    /**\n      * @dev emitted after staking in the pool\n      * @param user the address that staked\n      * @param timestamp of the staking\n    **/\n    event Staked(address user, uint256 indexed amount, uint256 timestamp);\n\n    /**\n      * @dev emitted after staking in the pool\n      * @param user the address that unstaked\n      * @param timestamp of the unstaking\n    **/\n    event Unstaked(address user, uint256 indexed amount, uint256 timestamp);\n}\n"
    },
    "contracts/PrimeVesting.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f5befa18a7b2a78efc746df4a7feaaf7856b8ac;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\n/**\n * @title PRIME vesting contract\n * @dev Contract distributing PRIME among vesting participants.\n */\ncontract PrimeVesting is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct VestingInfo {\n        uint32 cliffPeriod;\n        uint32 vestingPeriod;\n        address grantClaimRightTo;\n        uint256 totalAmount;\n    }\n\n    struct UserInfo {\n        VestingInfo info;\n        uint256 claimed;\n    }\n\n    IERC20 public immutable primeToken;\n\n    uint256 public immutable startTime;\n\n    uint256 public totalAmount;\n\n    bool public vestingInitialized;\n\n    mapping(address => UserInfo) public userInfos;\n\n    /// Errors\n\n    /// @dev Trying to claim from unautorized account\n    error Unauthorized();\n\n    /// @dev Input array lengths do not match\n    error InputLengthMismatch();\n\n    /// @dev Invalid vesting start time\n    error InvalidStartTime();\n\n    /// @dev Invalid address\n    error InvalidAddress();\n\n    /// @dev Invalid vesting period\n    error InvalidVestingPeriod();\n\n    /// @dev No claim available\n    error NothingToClaim();\n\n    /// @dev Trying to claim 0 amount\n    error ZeroClaimAmount();\n\n    /// @dev Vesting already initialized\n    error AlreadyInitialized();\n\n    /// @dev User already exists\n    error UserExists();\n\n    /// @dev Vesting not initialized\n    error NotInitialized();\n\n    /// @dev Vesting already started\n    error VestingAlreadyStarted();\n\n    /// @dev Insufficient allowance\n    error InsufficientAllowance();\n\n    /// @dev Insufficient balance\n    error InsufficientBalance();\n\n    /// Events\n\n    event Claimed(\n        address indexed user,\n        address indexed claimant,\n        uint256 indexed amount,\n        uint256 timestamp\n    );\n\n    event VestingUserAdded(\n        address indexed user,\n        uint256 indexed totalAmount,\n        uint256 cliffPeriod,\n        uint256 vestingPeriod,\n        uint256 timestamp\n    );\n\n    /// Constructor\n\n    constructor(\n        address primeToken_,\n        uint256 startTime_\n    ) {\n        if (startTime_ < block.timestamp) {\n            revert InvalidStartTime();\n        }\n        if (primeToken_ == address(0)) {\n            revert InvalidAddress();\n        }\n\n        primeToken = IERC20(primeToken_);\n        startTime = startTime_;\n    }\n\n    function initializeVesting(\n        address[] memory users_,\n        VestingInfo[] memory vestingInfos_,\n        bool isLastBatch\n    ) external onlyOwner {\n        if(vestingInitialized){\n            revert AlreadyInitialized();\n        }\n        if (users_.length != vestingInfos_.length) {\n            revert InputLengthMismatch();\n        }\n        uint256 _totalAmount;\n\n        uint256 len = users_.length;\n        for (uint256 i; i != len; ++i) {\n            address user = users_[i];\n            if (user == address(0)) {\n                revert InvalidAddress();\n            }\n            if(vestingInfos_[i].vestingPeriod == 0){\n                revert InvalidVestingPeriod();\n            }\n\n            UserInfo storage userInfo = userInfos[user];\n\n            if(userInfo.info.totalAmount != 0){\n                revert UserExists();\n            }\n\n            userInfo.info = vestingInfos_[i];\n            _totalAmount += userInfo.info.totalAmount;\n\n            emit VestingUserAdded(\n                user,\n                userInfo.info.totalAmount,\n                userInfo.info.cliffPeriod,\n                userInfo.info.vestingPeriod,\n                block.timestamp\n            );\n        }\n        totalAmount += _totalAmount;\n\n        if (isLastBatch) {\n            vestingInitialized = true;\n        }\n    }\n\n    /// Public functions\n\n    function claim() external nonReentrant {\n        _claimFor(msg.sender, msg.sender, _claimable(msg.sender));\n    }\n\n    function claimWithAmount(uint256 amount) nonReentrant external {\n        _claimFor(msg.sender, msg.sender, amount);\n    }\n\n    function claimFor(address user) nonReentrant external {\n        _claimFor(user, msg.sender, _claimable(user));\n    }\n\n    function claimForWithAmount(address user, uint256 amount) nonReentrant external {\n        _claimFor(user, msg.sender, amount);\n    }\n\n    function claimable(address user) public view returns (uint256) {\n        return _claimable(user);\n    }\n\n    function sendTokensToVesting() external nonReentrant onlyOwner {\n        if(!vestingInitialized){\n            revert NotInitialized();\n        }\n        if(primeToken.balanceOf(owner()) < totalAmount){\n            revert InsufficientBalance();\n        }\n        if(primeToken.allowance(owner(), address(this)) < totalAmount){\n            revert InsufficientAllowance();\n        }\n        if(block.timestamp >= startTime){\n            revert VestingAlreadyStarted();\n        }\n\n        primeToken.safeTransferFrom(owner(), address(this), totalAmount);\n    }\n\n    /// Internal functions\n\n    function _claimFor(address user, address claimant, uint256 amount) internal {\n        UserInfo storage userInfo = userInfos[user];\n\n        if (user != claimant && userInfo.info.grantClaimRightTo != claimant) {\n            revert Unauthorized();\n        }\n\n        uint256 claimableAmount = _claimable(user);\n        if (claimableAmount == 0) {\n            revert NothingToClaim();\n        }\n        amount = Math.min(amount, claimableAmount);\n        if (amount == 0) {\n            revert ZeroClaimAmount();\n        }\n\n        userInfo.claimed += amount;\n\n        primeToken.safeTransfer(user, amount);\n\n        emit Claimed(user, claimant, amount, block.timestamp);\n    }\n\n    function _claimable(address user) internal view returns (uint256) {\n        UserInfo storage userInfo = userInfos[user];\n\n        if(userInfo.info.totalAmount == 0){\n            return 0;\n        }\n\n        uint256 cliffEnd = startTime + userInfo.info.cliffPeriod;\n        if (cliffEnd >= block.timestamp) {\n            return 0;\n        }\n\n        uint256 duration = Math.min(\n            block.timestamp - cliffEnd,\n            userInfo.info.vestingPeriod\n        );\n\n        return\n            (userInfo.info.totalAmount * duration) /\n            userInfo.info.vestingPeriod -\n            userInfo.claimed;\n    }\n}\n"
    },
    "contracts/proxies/openzeppelinVirtual/BeaconProxyVirtual.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/BeaconProxy.sol)\n\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/Proxy.sol\";\nimport \"@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol\";\nimport \"./ERC1967UpgradeVirtual.sol\";\nimport \"../../interfaces/IDiamondBeacon.sol\";\n\n/**\n * @dev This is a copy of OpenZeppelin BeaconProxy (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol) contract.\n * The only difference is usage of ERC1967UpgradeVirtual contract that allows overriding the ERC1967Upgrade._upgradeBeaconToAndCall method and removing the obsolete BeaconProxy._setBeacon() method.\n */\ncontract BeaconProxyVirtual is Proxy, ERC1967UpgradeVirtual {\n    /**\n     * @dev Initializes the proxy with `beacon`.\n     *\n     * If `data` is nonempty, it's used as data in a delegate call to the implementation returned by the beacon. This\n     * will typically be an encoded function call, and allows initializating the storage of the proxy like a Solidity\n     * constructor.\n     *\n     * Requirements:\n     *\n     * - `beacon` must be a contract with the interface {IDiamondBeacon}.\n     */\n    constructor(address beacon, bytes memory data) payable {\n        assert(_BEACON_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.beacon\")) - 1));\n        _upgradeBeaconToAndCall(beacon, data, false);\n    }\n\n    /**\n     * @dev Returns the current beacon address.\n     */\n    function _beacon() internal view virtual returns (address) {\n        return _getBeacon();\n    }\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IDiamondBeacon(_getBeacon()).implementation();\n    }\n}"
    },
    "contracts/proxies/openzeppelinVirtual/ERC1967UpgradeVirtual.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/interfaces/draft-IERC1822.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../interfaces/IDiamondBeacon.sol\";\n\n/**\n * @dev This is a copy of OpenZeppelin ERC1967Upgrade (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/ERC1967/ERC1967Upgrade.sol) contract.\n * The only difference is the possibility of overriding the ERC1967Upgrade._upgradeBeaconToAndCall method.\n */\nabstract contract ERC1967UpgradeVirtual {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) internal {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IDiamondBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal virtual {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            // 0xe1c7392a = init()\n            Address.functionDelegateCall(IDiamondBeacon(newBeacon).implementation(0xe1c7392a), data);\n        }\n    }\n}"
    },
    "contracts/proxies/SmartLoanDiamondProxy.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"./openzeppelinVirtual/BeaconProxyVirtual.sol\";\n\n/**\n * @dev This is a copy of OpenZeppelin BeaconProxy (https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/proxy/beacon/BeaconProxy.sol) contract.\n * The only difference is usage of overriding the ERC1967Upgrade._upgradeBeaconToAndCall and BeaconProxy._implementation() methods.\n */\n\ncontract SmartLoanDiamondProxy is BeaconProxyVirtual {\n    constructor(address beacon, bytes memory data) payable BeaconProxyVirtual(beacon, data) {}\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    receive() external payable override {}\n\n    /**\n     * @dev Returns the current implementation address of the associated beacon.\n     */\n    function _implementation() internal view virtual override returns (address) {\n        return IDiamondBeacon(_getBeacon()).implementation(msg.sig);\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal override {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            // 0xc4d66de8 = initialize(address owner)\n            Address.functionDelegateCall(IDiamondBeacon(newBeacon).implementation(0xc4d66de8), data);\n        }\n    }\n}"
    },
    "contracts/proxies/tup/AddressProviderTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract AddressProviderTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/ArbBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract ArbBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/ArbDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract ArbDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/ArbPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract ArbPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/BtcBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract BtcBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/BtcDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract BtcDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/BtcPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: de0a4e9ee653d2aade275c436805bb3217a8979d;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract BtcPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/DaiBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract DaiBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/DaiDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract DaiDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/DaiPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract DaiPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/DepositSwapArbitrumTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract DepositSwapArbitrumTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/FraxBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract FraxBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/FraxDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract FraxDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/FraxPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract FraxPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/LinkBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract LinkBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/LinkDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract LinkDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/LinkPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract LinkPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/PangolinIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract PangolinIntermediaryTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/SPrimeUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract SPrimeUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/SushiSwapIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 48601850463d2b56407c5b1e6a596b5a87c4e428;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract SushiSwapIntermediaryTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/TraderJoeIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TraderJoeIntermediaryTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UniBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UniBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UniDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UniDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UniPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 67471c167ea4dcee4590ca5d8289a47373be90e3;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UniPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UsdcBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdcBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UsdcDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdcDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UsdcPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdcPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UsdtBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdtBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UsdtDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdtDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/UsdtPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ac51526ea73cc486f4527cf20f228688d343110b;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdtPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/vPrimeControllerUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract vPrimeControllerUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/vPrimeUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract vPrimeUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/WethBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract WethBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/WethDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract WethDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/arbitrum/WethPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract WethPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/BtcBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract BtcBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/BtcDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract BtcDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/BtcPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract BtcPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/EthBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract EthBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/EthDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract EthDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/EthPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract EthPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/PangolinIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract PangolinIntermediaryTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/TraderJoeIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TraderJoeIntermediaryTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/UsdcBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdcBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/UsdcDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdcDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/UsdcPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 2f6b0fb53889a8741a3d7f78a2d5d05ad7a0c76d;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdcPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/UsdtBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdtBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/UsdtDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdtDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/UsdtPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f1e1bba11316303810f35a4440e20bc5ad0ef86;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UsdtPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/WavaxBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract WavaxBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/WavaxDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract WavaxDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/avalanche/WavaxPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract WavaxPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/celo/CeloBorrowIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract CeloBorrowIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/celo/CeloDepositIndexTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract CeloDepositIndexTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/celo/CeloPoolTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 97d6cc3cb60bfd6feda4ea784b13bf0e7daac710;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract CeloPoolTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/celo/UbeswapIntermediaryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract UbeswapIntermediaryTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/SmartLoansFactoryTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract SmartLoansFactoryTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/proxies/tup/TokenManagerTUP.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c5c938a0524b45376dd482cd5c8fb83fa94c2fcc;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TokenManagerTUP is TransparentUpgradeableProxy {\n    constructor(address _logic, address admin_, bytes memory _data) TransparentUpgradeableProxy(_logic, admin_, _data) {}\n}\n"
    },
    "contracts/RandomTokenRewarder.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.27;\n\nimport {ConfirmedOwner} from \"@chainlink/contracts/src/v0.8/shared/access/ConfirmedOwner.sol\";\nimport {VRFV2WrapperConsumerBase} from \"@chainlink/contracts/src/v0.8/vrf/VRFV2WrapperConsumerBase.sol\";\nimport {LinkTokenInterface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/LinkTokenInterface.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./BtcEligibleUsersList.sol\";\n\n\ncontract RandomTokenRewarder is VRFV2WrapperConsumerBase, ConfirmedOwner {\n    event RequestSent(uint256 requestId, uint32 numWords);\n\n    // event for transferring reward to winner\n    event RewardTransferred(address indexed winner, address indexed rewardToken, uint256 amount, uint256 blockNumber);\n\n    // Depends on the number of requested values that you want sent to the\n    // fulfillRandomWords() function. Test and adjust\n    // this limit based on the network that you select, the size of the request,\n    // and the processing of the callback request in the fulfillRandomWords()\n    // function.\n    uint32 callbackGasLimit = 1000000;\n\n    // The default is 3, but you can set this higher.\n    uint16 requestConfirmations = 3;\n\n    // For this example, retrieve 2 random values in one request.\n    // Cannot exceed VRFV2Wrapper.getConfig().maxNumWords.\n    uint32 numWords = 1;\n    address public rewardToken = 0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E;\n    BtcEligibleUsersList public btcEligibleUsersList;\n\n    function setRewardToken(address _rewardToken) external onlyOwner {\n        rewardToken = _rewardToken;\n    }\n\n    // ERC20 withdraw owner only\n    function withdrawERC20(address _token, address _to, uint256 _amount) external onlyOwner {\n        IERC20(_token).transfer(_to, _amount);\n    }\n\n    // Address LINK\n    address public linkAddress = 0x5947BB275c521040051D82396192181b413227A3;\n    // Address WRAPPER\n    address public wrapperAddress = 0x721DFbc5Cfe53d32ab00A9bdFa605d3b8E1f3f42;\n\n    constructor(address _btcEligibleUsersList)\n    ConfirmedOwner(msg.sender)\n    VRFV2WrapperConsumerBase(linkAddress, wrapperAddress)\n    {\n        btcEligibleUsersList = BtcEligibleUsersList(_btcEligibleUsersList);\n    }\n\n    function requestRewardDistributionWithRandomWords()\n    external\n    onlyOwner\n    returns (uint256 requestId)\n    {\n        requestId = requestRandomness(\n            callbackGasLimit,\n            requestConfirmations,\n            numWords\n        );\n        emit RequestSent(requestId, numWords);\n        return requestId;\n    }\n\n\n    function fulfillRandomWords(\n        uint256 _requestId,\n        uint256[] memory _randomWords\n    ) internal override {\n        uint256 randomWord = _randomWords[0];\n\n        uint256 primeAccountCount = btcEligibleUsersList.getEligibleUsersCount();\n        address primeAccountAddress = btcEligibleUsersList.eligibleUsersList(randomWord % primeAccountCount);\n\n        uint256 rewardBalance = IERC20(rewardToken).balanceOf(address(this));\n        IERC20(rewardToken).transfer(primeAccountAddress, rewardBalance);\n        emit RewardTransferred(primeAccountAddress, rewardToken, rewardBalance, block.number);\n    }\n}\n\n"
    },
    "contracts/RecoveryManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\nimport \"./interfaces/facets/avalanche/IRecoveryFacet.sol\";\n\n/// @title DeltaPrime Recovery Manager\ncontract RecoveryManager is Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct RecoverData {\n        bytes32 asset;\n        address underlying;\n        address[] accounts;\n        address token0;\n        address token1;\n        uint256 minAmount0;\n        uint256 minAmount1;\n    }\n\n    struct Helper {\n        address helper;\n        bytes4 selector;\n    }\n\n    mapping(bytes32 => Helper) public helpers;\n\n    function addHelper(\n        bytes32 _asset,\n        address _helper,\n        bytes4 _selector\n    ) external onlyOwner {\n        helpers[_asset] = Helper({helper: _helper, selector: _selector});\n\n        emit HelperAdded(_asset, _helper, _selector);\n    }\n\n    function recoverAssets(\n        RecoverData[] memory _data\n    ) external nonReentrant onlyOwner {\n        uint256 length = _data.length;\n        require(length > 0, \"empty array\");\n\n        for (uint256 i; i != length; ++i) {\n            RecoverData memory data = _data[i];\n            Helper memory helper = helpers[data.asset];\n            require(helper.helper != address(0), \"Helper not found\");\n\n            uint256 userLength = data.accounts.length;\n            uint256[] memory recovered = new uint256[](userLength);\n            uint256 totalRecovered;\n\n            for (uint256 j; j != userLength; ++j) {\n                recovered[j] = IRecoveryFacet(data.accounts[j]).emergencyWithdraw(\n                    data.asset\n                );\n                totalRecovered += recovered[j];\n            }\n\n            require(totalRecovered > 0, \"Nothing to recover\");\n\n            uint256 beforeBalance = IERC20(data.underlying).balanceOf(address(this));\n\n            (bool success, ) = helper.helper.delegatecall(\n                abi.encodeWithSelector(\n                    helper.selector,\n                    data.token0,\n                    data.token1,\n                    totalRecovered,\n                    data.minAmount0,\n                    data.minAmount1\n                )\n            );\n            require(success, \"failed to unstake\");\n\n            uint256 recoveredBalance = IERC20(data.underlying).balanceOf(\n                address(this)\n            ) - beforeBalance;\n\n            for (uint256 j; j != userLength; ++j) {\n                address account = data.accounts[j];\n                uint256 refundAmount = (recoveredBalance * recovered[j]) /\n                    totalRecovered;\n                IERC20(data.underlying).safeApprove(account, 0);\n                IERC20(data.underlying).safeApprove(account, refundAmount);\n                IRecoveryFacet(account).notifyRefund(data.underlying, refundAmount);\n            }\n\n            emit AssetRecovered(\n                data.asset,\n                totalRecovered,\n                data.underlying,\n                recoveredBalance\n            );\n        }\n    }\n\n    event HelperAdded(bytes32 asset, address helper, bytes4 selector);\n\n    event AssetRecovered(\n        bytes32 asset,\n        uint256 assetRecovered,\n        address underlying,\n        uint256 underlyingRecovered\n    );\n}\n"
    },
    "contracts/ReentrancyGuardKeccak.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Modified version of Openzeppelin (OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)) ReentrancyGuard\n// contract that uses keccak slots instead of the standard storage layout.\n\nimport {DiamondStorageLib} from \"./lib/DiamondStorageLib.sol\";\n\npragma solidity 0.8.27;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n */\nabstract contract ReentrancyGuardKeccak {\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        DiamondStorageLib.ReentrancyGuardStorage storage rgs = DiamondStorageLib.reentrancyGuardStorage();\n        // On the first call to nonReentrant, _notEntered will be true\n        require(rgs._status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        rgs._status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        rgs._status = _NOT_ENTERED;\n    }\n}\n"
    },
    "contracts/SmartLoanDiamondBeacon.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 8c36e18a206b9e6649c00da51c54b92171ce3413;\npragma solidity 0.8.27;\n\nimport {DiamondStorageLib} from \"./lib/DiamondStorageLib.sol\";\nimport {IDiamondCut} from \"./interfaces/IDiamondCut.sol\";\n\n/**\n * @title SmartLoanDiamondBeacon\n * A contract that is authorised to borrow funds using delegated credit.\n * It maintains solvency calculating the current value of assets and borrowings.\n * In case the value of assets held drops below certain level, part of the funds may be forcibly repaid.\n * It permits only a limited and safe token transfer.\n *\n */\n\ncontract SmartLoanDiamondBeacon {\n    constructor(address _contractOwner, address _diamondCutFacet) payable {\n        DiamondStorageLib.setContractOwner(_contractOwner);\n        DiamondStorageLib.setContractPauseAdmin(_contractOwner);\n\n        // Add the diamondCut external function from the diamondCutFacet\n        IDiamondCut.FacetCut[] memory cut = new IDiamondCut.FacetCut[](1);\n        bytes4[] memory functionSelectors = new bytes4[](3);\n        functionSelectors[0] = IDiamondCut.diamondCut.selector;\n        functionSelectors[1] = IDiamondCut.pause.selector;\n        functionSelectors[2] = IDiamondCut.unpause.selector;\n        cut[0] = IDiamondCut.FacetCut({\n        facetAddress : _diamondCutFacet,\n        action : IDiamondCut.FacetCutAction.Add,\n        functionSelectors : functionSelectors\n        });\n        DiamondStorageLib.diamondCut(cut, address(0), \"\");\n\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        // diamondCut(); unpause()\n        ds.canBeExecutedWhenPaused[0x1f931c1c] = true;\n        ds.canBeExecutedWhenPaused[0x3f4ba83a] = true;\n    }\n\n    function implementation() public view returns (address) {\n        return address(this);\n    }\n\n    function canBeExecutedWhenPaused(bytes4 methodSig) external view returns (bool) {\n        return DiamondStorageLib.getPausedMethodExemption(methodSig);\n    }\n\n    function setPausedMethodExemptions(bytes4[] memory methodSigs, bool[] memory values) public {\n        DiamondStorageLib.enforceIsContractOwner();\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n\n        for(uint i; i<methodSigs.length; i++){\n            require(!(methodSigs[i] == 0x3f4ba83a && values[i] == false), \"The unpause() method must be available during the paused state.\");\n            ds.canBeExecutedWhenPaused[methodSigs[i]] = values[i];\n        }\n    }\n\n    function getStatus() public view returns(bool) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        return ds._active;\n    }\n\n    function implementation(bytes4 funcSignature) public view notPausedOrUpgrading(funcSignature) returns (address) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        // get facet from function selector\n        address facet = ds.selectorToFacetAndPosition[funcSignature].facetAddress;\n        require(facet != address(0), \"Diamond: Function does not exist\");\n        // Execute external function from facet using delegatecall and return any value.\n        return facet;\n    }\n\n\n    // Find facet for function that is called and execute the\n    // function if a facet is found and return any value.\n    fallback() external payable {\n        address facet = implementation(msg.sig);\n        // Execute external function from facet using delegatecall and return any value.\n        assembly {\n        // copy function selector and any arguments\n            calldatacopy(0, 0, calldatasize())\n        // execute function call using the facet\n            let result := delegatecall(gas(), facet, 0, calldatasize(), 0, 0)\n        // get any return value\n            returndatacopy(0, 0, returndatasize())\n        // return any return value or error back to the caller\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return (0, returndatasize())\n            }\n        }\n    }\n\n    function proposeBeaconOwnershipTransfer(address _newOwner) external {\n        DiamondStorageLib.enforceIsContractOwner();\n        require(_newOwner != msg.sender, \"Can't propose oneself as a contract owner\");\n        DiamondStorageLib.setProposedOwner(_newOwner);\n\n        emit OwnershipProposalCreated(msg.sender, _newOwner);\n    }\n\n    function proposeBeaconPauseAdminOwnershipTransfer(address _newPauseAdmin) external {\n        DiamondStorageLib.enforceIsPauseAdmin();\n        require(_newPauseAdmin != msg.sender, \"Can't propose oneself as a contract pauseAdmin\");\n        DiamondStorageLib.setProposedPauseAdmin(_newPauseAdmin);\n\n        emit PauseAdminOwnershipProposalCreated(msg.sender, _newPauseAdmin);\n    }\n\n    function acceptBeaconOwnership() external {\n        require(DiamondStorageLib.proposedOwner() == msg.sender, \"Only a proposed user can accept ownership\");\n        DiamondStorageLib.setContractOwner(msg.sender);\n        DiamondStorageLib.setProposedOwner(address(0));\n\n        emit OwnershipProposalAccepted(msg.sender);\n    }\n\n    function acceptBeaconPauseAdminOwnership() external {\n        require(DiamondStorageLib.proposedPauseAdmin() == msg.sender, \"Only a proposed user can accept ownership\");\n        DiamondStorageLib.setContractPauseAdmin(msg.sender);\n        DiamondStorageLib.setProposedPauseAdmin(address(0));\n\n        emit PauseAdminOwnershipProposalAccepted(msg.sender);\n    }\n\n    modifier notPausedOrUpgrading(bytes4 funcSignature) {\n        DiamondStorageLib.DiamondStorage storage ds = DiamondStorageLib.diamondStorage();\n        if(!ds._active){\n            if(!ds.canBeExecutedWhenPaused[funcSignature]){\n                revert(\"ProtocolUpgrade: paused.\");\n            }\n        }\n        _;\n    }\n\n    /**\n     * @dev emitted after creating a pauseAdmin transfer proposal by the pauseAdmin\n     * @param pauseAdmin address of the current pauseAdmin\n     * @param proposed address of the proposed pauseAdmin\n     **/\n    event PauseAdminOwnershipProposalCreated(address indexed pauseAdmin, address indexed proposed);\n\n    /**\n     * @dev emitted after accepting a pauseAdmin transfer proposal by the new pauseAdmin\n     * @param newPauseAdmin address of the new pauseAdmin\n     **/\n    event PauseAdminOwnershipProposalAccepted(address indexed newPauseAdmin);\n\n    /**\n     * @dev emitted after creating a ownership transfer proposal by the owner\n     * @param owner address of the current owner\n     * @param proposed address of the proposed owner\n     **/\n    event OwnershipProposalCreated(address indexed owner, address indexed proposed);\n\n    /**\n     * @dev emitted after accepting a ownership transfer proposal by the new owner\n     * @param newOwner address of the new owner\n     **/\n    event OwnershipProposalAccepted(address indexed newOwner);\n}"
    },
    "contracts/SmartLoansFactory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 33842ab4d1a332ccd47fb1cd2bb991e771922080;\npragma solidity 0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\nimport \"@openzeppelin/contracts/proxy/beacon/BeaconProxy.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@uniswap/lib/contracts/libraries/TransferHelper.sol\";\nimport \"./SmartLoanDiamondBeacon.sol\";\nimport \"./proxies/SmartLoanDiamondProxy.sol\";\nimport \"./facets/AssetsOperationsFacet.sol\";\nimport \"./facets/OwnershipFacet.sol\";\nimport \"./facets/SmartLoanViewFacet.sol\";\nimport \"./interfaces/ITokenManager.sol\";\n\n/**\n * @title SmartLoansFactory\n * @dev Contract responsible for creating new instances of SmartLoans (SmartLoanDiamondBeacon).\n * It's possible to either simply create a new loan or create and fund it with an ERC20 asset as well as borrow in a single transaction.\n * At the time of creating a loan, SmartLoansFactory contract is the owner for the sake of being able to perform the fund() and borrow() operations.\n * At the end of the createAndFundLoan the ownership is transferred to the msg.sender.\n * It's also responsible for keeping track of the loans, ensuring one loan per wallet rule, ownership transfers proposals/execution and\n * authorizes registered loans to borrow from lending pools.\n */\ncontract SmartLoansFactory is OwnableUpgradeable, IBorrowersRegistry, ProxyConnector {\n    using TransferHelper for address;\n    using TransferHelper for address payable;\n\n    modifier hasNoLoan() {\n        require(!_hasLoan(msg.sender), \"Only one loan per owner is allowed\");\n        _;\n    }\n\n\n    SmartLoanDiamondBeacon public smartLoanDiamond;\n\n    mapping(address => address) public ownersToLoans;\n    mapping(address => address) public loansToOwners;\n\n    address[] loans;\n\n    ITokenManager public tokenManager;\n\n    function _hasLoan(address user) internal view returns (bool) {\n        return ownersToLoans[user] != address(0);\n    }\n\n    function changeOwnership(address _newOwner) public {\n        address loan = msg.sender;\n        address oldOwner = loansToOwners[loan];\n\n        require(oldOwner != address(0), \"Only a SmartLoan can change it's owner\");\n        require(!_hasLoan(_newOwner), \"New owner already has a loan\");\n\n        ownersToLoans[oldOwner] = address(0);\n        ownersToLoans[_newOwner] = loan;\n        loansToOwners[loan] = _newOwner;\n    }\n\n    function initialize(address payable _smartLoanDiamond, address _tokenManager) external initializer {\n        smartLoanDiamond = SmartLoanDiamondBeacon(_smartLoanDiamond);\n        tokenManager = ITokenManager(_tokenManager);\n        __Ownable_init();\n    }\n\n    function setTokenManager(address _tokenManager) external onlyOwner {\n        tokenManager = ITokenManager(_tokenManager);\n    }\n\n    function createLoan() public virtual hasNoLoan returns (SmartLoanDiamondBeacon) {\n        SmartLoanDiamondProxy beaconProxy = new SmartLoanDiamondProxy(\n            payable(address(smartLoanDiamond)),\n        // Setting SLFactory as the initial owner and then using .transferOwnership to change the owner to msg.sender\n        // It is possible to set msg.sender as the initial owner if our loan-creation flow would change\n            abi.encodeWithSelector(SmartLoanViewFacet.initialize.selector, msg.sender)\n        );\n        SmartLoanDiamondBeacon smartLoan = SmartLoanDiamondBeacon(payable(address(beaconProxy)));\n\n        //Update registry and emit event\n        updateRegistry(address(smartLoan), msg.sender);\n\n        emit SmartLoanCreated(address(smartLoan), msg.sender, \"\", 0);\n        return smartLoan;\n    }\n\n    function createAndFundLoan(bytes32 _fundedAsset, uint256 _amount) public virtual hasNoLoan returns (SmartLoanDiamondBeacon) {\n        address asset = tokenManager.getAssetAddress(_fundedAsset, false);\n        SmartLoanDiamondProxy beaconProxy = new SmartLoanDiamondProxy(payable(address(smartLoanDiamond)),\n            abi.encodeWithSelector(SmartLoanViewFacet.initialize.selector, msg.sender)\n        );\n        SmartLoanDiamondBeacon smartLoan = SmartLoanDiamondBeacon(payable(address(beaconProxy)));\n\n        //Fund account with own funds and credit\n        IERC20Metadata token = IERC20Metadata(asset);\n        address(token).safeTransferFrom(msg.sender, address(this), _amount);\n        address(token).safeApprove(address(smartLoan), _amount);\n\n        //Update registry and emit event\n        updateRegistry(address(smartLoan), msg.sender);\n\n        (bool success, bytes memory result) = address(smartLoan).call(abi.encodeWithSelector(AssetsOperationsFacet.fund.selector, _fundedAsset, _amount));\n        ProxyConnector._prepareReturnValue(success, result);\n\n        emit SmartLoanCreated(address(smartLoan), msg.sender, _fundedAsset, _amount);\n\n        return smartLoan;\n    }\n\n    function updateRegistry(address loan, address owner) internal {\n        ownersToLoans[owner] = loan;\n        loansToOwners[loan] = owner;\n        loans.push(loan);\n    }\n\n    function canBorrow(address _account) external view override returns (bool) {\n        return loansToOwners[_account] != address(0);\n    }\n\n    function getLoanForOwner(address _user) external view override returns (address) {\n        return ownersToLoans[_user];\n    }\n\n    function getOwnerOfLoan(address _loan) external view override returns (address) {\n        return loansToOwners[_loan];\n    }\n\n    function getAllLoans() public view returns (address[] memory) {\n        return loans;\n    }\n\n    function getLoans(uint256 _from, uint256 _count) public view returns (address[] memory _loans) {\n        uint256 length = loans.length;\n        if (_from >= length) {\n            _loans = new address[](0);\n            return _loans;\n        }\n\n        if (_count > length - _from) {\n            _count = length - _from;\n        }\n        _loans = new address[](_count);\n        for (uint256 i; i != _count; ++i) {\n            _loans[i] = loans[_from + i];\n        }\n    }\n\n    function getLoansLength() external view returns (uint256) {\n        return loans.length;\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /**\n     * @dev emitted after creating a loan by the owner\n     * @param accountAddress address of a new SmartLoanDiamondBeacon\n     * @param creator account creating a SmartLoanDiamondBeacon\n     * @param collateralAsset asset used as initial collateral\n     * @param collateralAmount amount of asset used as initial collateral\n     **/\n    event SmartLoanCreated(address indexed accountAddress, address indexed creator, bytes32 collateralAsset, uint256 collateralAmount);\n}"
    },
    "contracts/SmartLoansFactoryRestrictedAccess.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: da3db6d98ac8305a3d43391d37f1b9a30e456c4e;\npragma solidity 0.8.27;\n\nimport \"./SmartLoansFactory.sol\";\n\ncontract SmartLoansFactoryRestrictedAccess is SmartLoansFactory {\n    bytes32 internal constant ACCESS_NFT_SLOT = bytes32(uint256(keccak256('WHITELIST_SLOT_1670605213')) - 1);\n\n    function getWhitelistingMapping() internal view returns(mapping(address=>bool) storage result){\n        bytes32 slot = ACCESS_NFT_SLOT;\n        assembly{\n            result.slot := sload(slot)\n        }\n    }\n    \n    function whitelistBorrowers(address[] memory _borrowers) external onlyOwner {\n\n        for(uint i; i<_borrowers.length; i++){\n            getWhitelistingMapping()[_borrowers[i]] = true;\n            emit BorrowerWhitelisted(_borrowers[i], msg.sender, block.timestamp);\n        }\n    }\n\n    function delistBorrowers(address[] memory _borrowers) external onlyOwner {\n        for(uint i; i<_borrowers.length; i++){\n            getWhitelistingMapping()[_borrowers[i]] = false;\n            emit BorrowerDelisted(_borrowers[i], msg.sender, block.timestamp);\n        }\n    }\n\n    function isBorrowerWhitelisted(address _borrower) public view returns(bool){\n        return getWhitelistingMapping()[_borrower];\n    }\n\n    function createLoan() public virtual override hasNoLoan canCreatePrimeAccount(msg.sender) returns (SmartLoanDiamondBeacon) {\n        return super.createLoan();\n    }\n\n    function createAndFundLoan(bytes32 _fundedAsset, uint256 _amount) public virtual override hasNoLoan canCreatePrimeAccount(msg.sender) returns (SmartLoanDiamondBeacon) {\n        return super.createAndFundLoan(_fundedAsset, _amount);\n    }\n\n    /**\n     * @dev emitted when a new borrower gets whitelisted\n     * @param borrower the address being whitelisted\n     * @param performer the address initiating whitelisting\n     * @param timestamp of the whitelisting\n     **/\n    event BorrowerWhitelisted(address indexed borrower, address performer, uint256 timestamp);\n    \n    /**\n     * @dev emitted when a borrower gets delisted\n     * @param borrower the address being delisted\n     * @param performer the address initiating delisting\n     * @param timestamp of the delisting\n     **/\n    event BorrowerDelisted(address indexed borrower, address performer, uint256 timestamp);\n\n    modifier canCreatePrimeAccount(address _borrower) {\n        require(isBorrowerWhitelisted(_borrower), \"Only whitelisted borrowers can create a Prime Account.\");\n        _;\n    }\n}\n"
    },
    "contracts/TimeLock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./lib/SafeMath.sol\";\n\ncontract Timelock {\n    using SafeMath for uint;\n\n    event NewAdmin(address indexed newAdmin);\n    event NewPendingAdmin(address indexed newPendingAdmin);\n    event NewDelay(uint indexed newDelay);\n    event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature,  bytes data, uint eta);\n    event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n    uint public constant GRACE_PERIOD = 7 days;\n    uint public constant MINIMUM_DELAY = 1 days;\n    uint public constant MAXIMUM_DELAY = 1 days;\n\n    address public admin;\n    address public pendingAdmin;\n    uint public delay;\n\n    mapping (bytes32 => bool) public queuedTransactions;\n\n\n    constructor(address admin_, uint delay_) public {\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n        admin = admin_;\n        delay = delay_;\n    }\n\n    fallback() external payable { }\n\n    function setDelay(uint delay_) public {\n        require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n        require(delay_ >= delay, \"Timelock::setDelay: New Delay must be higher than current delay.\");\n        require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n        require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n        delay = delay_;\n\n        emit NewDelay(delay);\n    }\n\n    function acceptAdmin() public {\n        require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n        admin = msg.sender;\n        pendingAdmin = address(0);\n\n        emit NewAdmin(admin);\n    }\n\n    function setPendingAdmin(address pendingAdmin_) public {\n        require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n        pendingAdmin = pendingAdmin_;\n\n        emit NewPendingAdmin(pendingAdmin);\n    }\n\n    function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n        require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n        require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = true;\n\n        emit QueueTransaction(txHash, target, value, signature, data, eta);\n        return txHash;\n    }\n\n    function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n        require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        queuedTransactions[txHash] = false;\n\n        emit CancelTransaction(txHash, target, value, signature, data, eta);\n    }\n\n    function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n        require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n        bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n        require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n        require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n        require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n        queuedTransactions[txHash] = false;\n\n        bytes memory callData;\n\n        if (bytes(signature).length == 0) {\n            callData = data;\n        } else {\n            callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n        }\n\n        // solium-disable-next-line security/no-call-value\n        (bool success, bytes memory returnData) = target.call{value: value}(callData);\n        require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n        emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n        return returnData;\n    }\n\n    function getBlockTimestamp() internal view returns (uint) {\n        // solium-disable-next-line security/no-block-members\n        return block.timestamp;\n    }\n}"
    },
    "contracts/token/mock/sPrimeMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\nimport {SolvencyFacetProd} from \"../../facets/SolvencyFacetProd.sol\";\nimport \"../../lib/uniswap-v3/FullMath.sol\";\nimport \"../vPrimeController.sol\";\n\ncontract SPrimeMock is ERC20, Ownable, ProxyConnector {\n    struct LockDetails {\n        uint256 lockTime;\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    vPrimeController public vPrimeControllerContract;\n    uint256 public constant MAX_LOCK_TIME = 3 * 365 days;\n    uint256 public immutable DOLLAR_VALUE_MULTIPLIER;\n\n    mapping(address => LockDetails[]) public locks;\n\n    // TODO: _DOLLAR_VALUE_MULTIPLIER is only for mocking of dollar value calculation, we need to replace it with actual calculation in the final implementation\n    constructor(string memory name, string memory symbol, uint256 _DOLLAR_VALUE_MULTIPLIER) ERC20(name, symbol) {\n        DOLLAR_VALUE_MULTIPLIER = _DOLLAR_VALUE_MULTIPLIER;\n    }\n\n    function increaseBalance(address account, uint256 amount) public onlyOwner {\n        _mint(account, amount);\n        proxyCalldata(\n            address(vPrimeControllerContract),\n            abi.encodeWithSignature(\"updateVPrimeSnapshot(address)\", account),\n            false\n        );\n    }\n\n    function getFullyVestedLockedBalance(address account) public view returns (uint256 fullyVestedBalance) {\n        fullyVestedBalance = 0;\n        for (uint i = 0; i < locks[account].length; i++) {\n            if (locks[account][i].unlockTime > block.timestamp) {\n                fullyVestedBalance += FullMath.mulDiv(locks[account][i].amount, locks[account][i].lockTime, MAX_LOCK_TIME);\n            }\n        }\n    }\n\n    function setVPrimeControllerContract(address _vPrimeControllerContract) public onlyOwner {\n        vPrimeControllerContract = vPrimeController(_vPrimeControllerContract);\n    }\n\n    function decreaseBalance(address account, uint256 amount) public onlyOwner {\n        _burn(account, amount);\n        proxyCalldata(\n            address(vPrimeControllerContract),\n            abi.encodeWithSignature(\"updateVPrimeSnapshot(address)\", account),\n            false\n        );\n    }\n\n    function getLockedBalance(address account) public view returns (uint256) {\n        uint256 lockedBalance = 0;\n        for (uint i = 0; i < locks[account].length; i++) {\n            if (locks[account][i].unlockTime > block.timestamp) {\n                lockedBalance += locks[account][i].amount;\n            }\n        }\n        return lockedBalance;\n    }\n\n    function lockBalance(uint256 amount, uint256 lockTime) public {\n        uint256 lockedBalance = getLockedBalance(msg.sender);\n        require(balanceOf(msg.sender) - lockedBalance >= amount, \"Insufficient balance to lock\");\n        require(lockTime <= MAX_LOCK_TIME, \"Cannot lock for more than 3 years\");\n        locks[msg.sender].push(LockDetails({\n            lockTime: lockTime,\n            amount: amount,\n            unlockTime: block.timestamp + lockTime\n        }));\n        // TODO: Add event\n        proxyCalldata(\n            address(vPrimeControllerContract),\n            abi.encodeWithSignature(\"updateVPrimeSnapshot(address)\", msg.sender),\n            false\n        );\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        if(from != address(0)) {\n            uint256 lockedBalance = getLockedBalance(msg.sender);\n            require(amount <= balanceOf(from) - lockedBalance, \"Balance is locked\");\n        }\n    }\n\n    function getTokenY() public view returns (address) {\n        return 0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7; // WAVAX 18 decimals\n    }\n\n    function getUserValueInTokenY(address userAddress) public view returns (uint256) {\n        return balanceOf(userAddress) * DOLLAR_VALUE_MULTIPLIER;\n    }\n}"
    },
    "contracts/token/mock/vPrimeControllerArbitrumMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport {vPrimeControllerArbitrum} from \"../vPrimeControllerArbitrum.sol\";\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\n\ncontract vPrimeControllerArbitrumMock is vPrimeControllerArbitrum, AuthorisedMockSignersBase {\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n        // Always pass\n    }\n}"
    },
    "contracts/token/mock/vPrimeControllerAvalancheMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport {vPrimeControllerAvalanche} from \"../vPrimeControllerAvalanche.sol\";\nimport \"@redstone-finance/evm-connector/contracts/mocks/AuthorisedMockSignersBase.sol\";\n\ncontract vPrimeControllerAvalancheMock is vPrimeControllerAvalanche, AuthorisedMockSignersBase {\n    uint256 constant DEFAULT_MAX_DATA_TIMESTAMP_DELAY_SECONDS = 15 minutes; // Test sometimes be slow\n\n    uint256 internal constant MIN_TIMESTAMP_MILLISECONDS = 1654353400000;\n\n    function getAuthorisedSignerIndex(address signerAddress)\n    public\n    view\n    virtual\n    override\n    returns (uint8)\n    {\n        return getAuthorisedMockSignerIndex(signerAddress);\n    }\n\n    function validateTimestamp(uint256 receivedTimestampMilliseconds) public view virtual override {\n        // Always pass\n    }\n}"
    },
    "contracts/token/mock/vPrimeMock.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.27;\n\nimport \"../vPrime.sol\";\n\n\ncontract vPrimeMock is vPrime {\n    /* ========== MODIFIERS ========== */\n    modifier onlyVPrimeController() override {\n        _;\n    }\n}\n"
    },
    "contracts/token/NonfungibleNFT/PositionManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 7791f4c6f965248c1000f6642d53e9701e04a22d;\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport '@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol';\n\nimport \"../../interfaces/IPositionManager.sol\";\n\n/// @title NFT positions\ncontract PositionManager is\n    ERC721Enumerable,\n    IPositionManager,\n    Ownable\n{   \n    // token id => Position Information\n    mapping(uint256 => Position) private _positions;\n    // bin id => Bin Information\n    mapping(uint256 => DepositConfig) private _binInfo;\n    uint176 private _nextId = 1;\n    ISPrimeTraderJoe public sPrime;\n\n    // Nothing to initialize from the constructor. \n    // Only had to call the contructor for ERC721\n    constructor() ERC721('SPrime Position NFT', 'SPRIME-POS') {}\n\n    modifier onlySPrime() {\n        require(address(sPrime) == _msgSender(), \"Not sPrime\");\n        _;\n    }\n\n    function setSPrime(ISPrimeTraderJoe sPrime_) external onlyOwner {\n        sPrime = sPrime_;\n        emit SPrimeUpdated(sPrime_);\n    }\n\n    function getDepositConfig(uint256 centerId) external view returns(DepositConfig memory) {\n        return _binInfo[centerId];\n    }\n\n    function getDepositConfigFromTokenId(uint256 tokenId) external view returns(DepositConfig memory) {\n        uint256 centerId = _positions[tokenId].centerId;\n        return _binInfo[centerId];\n    }\n\n    function positions(uint256 tokenId)\n        external\n        view\n        override\n        returns (\n            IERC20 token0,\n            IERC20 token1,\n            ILBPair pairAddr,\n            uint256 totalShare,\n            uint256 centerId,\n            uint256[] memory liquidityMinted\n        )\n    {\n        Position memory position = _positions[tokenId];\n\n        return (\n            sPrime.getTokenX(),\n            sPrime.getTokenY(),\n            sPrime.getLBPair(),\n            position.totalShare,\n            position.centerId,\n            position.liquidityMinted\n        );\n    }\n\n    function mint(MintParams calldata params)\n        external\n        override\n        onlySPrime\n        returns (\n            uint256 tokenId\n        )\n    {\n        _mint(params.recipient, tokenId = _nextId++);\n\n        _positions[tokenId] = Position({\n            totalShare: params.totalShare,\n            centerId: params.centerId,\n            liquidityMinted: params.liquidityMinted\n        });\n        \n        DepositConfig storage binInfo = _binInfo[params.centerId];\n        if(binInfo.depositIds.length == 0) {\n            binInfo.depositIds = params.depositIds;\n            binInfo.liquidityConfigs = params.liquidityConfigs;\n        }\n    }\n\n    function update(UpdateParams calldata params)\n        external\n        override\n        onlySPrime\n    {\n        Position storage position = _positions[params.tokenId];\n        require(position.liquidityMinted.length == params.liquidityAmounts.length, \"Length Dismatch\");\n        if(params.isAdd) {\n            position.totalShare += params.share;\n            for(uint i = 0 ; i < params.liquidityAmounts.length ; i ++) {\n                position.liquidityMinted[i] += params.liquidityAmounts[i];\n            }\n        } else {\n            position.totalShare -= params.share;\n            for(uint i = 0 ; i < params.liquidityAmounts.length ; i ++) {\n                position.liquidityMinted[i] -= params.liquidityAmounts[i];\n            }\n        }\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        require(_exists(tokenId));\n        return \"\";\n    }\n\n    function forceTransfer(address from, address to, uint256 tokenId) external override {\n        _transfer(from, to, tokenId);\n    }\n\n    function burn(uint256 tokenId) external override {        \n        _burn(tokenId);\n        delete _positions[tokenId];\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 firstTokenId,\n        uint256 batchSize\n    ) internal virtual override onlySPrime{\n        super._beforeTokenTransfer(from, to, firstTokenId, batchSize);\n    }\n}"
    },
    "contracts/token/Prime_L2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: fdbe5a41cfc30a8d7f63abcbfeae5f77df7368a1;\n\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@layerzerolabs/solidity-examples/contracts/token/oft/v2/BaseOFTV2.sol\";\n\ncontract Prime_L2 is BaseOFTV2, ERC20 {\n    /// @notice long decimals to short decimals rate.\n    uint internal immutable ld2sdRate;\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        uint8 _sharedDecimals,\n        address _lzEndpoint\n    ) ERC20(_name, _symbol) BaseOFTV2(_sharedDecimals, _lzEndpoint) {\n        uint8 decimals = decimals();\n        require(\n            _sharedDecimals <= decimals,\n            \"OFT: sharedDecimals must be <= decimals\"\n        );\n        ld2sdRate = 10 ** (decimals - _sharedDecimals);\n    }\n\n    /************************************************************************\n     * public functions\n     ************************************************************************/\n    function circulatingSupply() public view virtual override returns (uint) {\n        return totalSupply();\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(this);\n    }\n\n    /************************************************************************\n     * internal functions\n     ************************************************************************/\n    function _debitFrom(\n        address _from,\n        uint16,\n        bytes32,\n        uint _amount\n    ) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        if (_from != spender) _spendAllowance(_from, spender, _amount);\n        _burn(_from, _amount);\n        return _amount;\n    }\n\n    function _creditTo(\n        uint16,\n        address _toAddress,\n        uint _amount\n    ) internal virtual override returns (uint) {\n        _mint(_toAddress, _amount);\n        return _amount;\n    }\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _amount\n    ) internal virtual override returns (uint) {\n        address spender = _msgSender();\n        // if transfer from this contract, no need to check allowance\n        if (_from != address(this) && _from != spender)\n            _spendAllowance(_from, spender, _amount);\n        _transfer(_from, _to, _amount);\n        return _amount;\n    }\n\n    function _ld2sdRate() internal view virtual override returns (uint) {\n        return ld2sdRate;\n    }\n}\n"
    },
    "contracts/token/Prime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: fdbe5a41cfc30a8d7f63abcbfeae5f77df7368a1;\n\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\n\ncontract Prime is ERC20, ERC20Permit {\n    constructor(uint256 supply) ERC20(\"DeltaPrime\", \"PRIME\") ERC20Permit(\"DeltaPrime\") {\n        _mint(_msgSender(), supply);\n    }\n}"
    },
    "contracts/token/PrimeBridge.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: fdbe5a41cfc30a8d7f63abcbfeae5f77df7368a1;\npragma solidity ^0.8.27;\n\nimport \"@layerzerolabs/solidity-examples/contracts/token/oft/v2/BaseOFTV2.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\ncontract PrimeBridge is BaseOFTV2 {\n    using SafeERC20 for IERC20;\n\n    IERC20 internal immutable innerToken;\n\n    /// @notice long decimals to short decimals rate.\n    uint256 internal immutable ld2sdRate;\n\n    // total amount is transferred from this chain to other chains, ensuring the total is less than uint64.max in sd\n    uint256 public outboundAmount;\n\n    constructor(\n        IERC20 _token,\n        uint8 _sharedDecimals,\n        address _lzEndpoint\n    ) BaseOFTV2(_sharedDecimals, _lzEndpoint) {\n        innerToken = _token;\n\n        (bool success, bytes memory data) = address(_token).staticcall(\n            abi.encodeWithSignature(\"decimals()\")\n        );\n        require(success, \"ProxyOFT: failed to get token decimals\");\n        uint8 decimals = abi.decode(data, (uint8));\n\n        require(\n            _sharedDecimals <= decimals,\n            \"ProxyOFT: sharedDecimals must be <= decimals\"\n        );\n        ld2sdRate = 10 ** (decimals - _sharedDecimals);\n    }\n\n    /************************************************************************\n     * public functions\n     ************************************************************************/\n    function circulatingSupply() public view virtual override returns (uint256) {\n        return innerToken.totalSupply() - outboundAmount;\n    }\n\n    function token() public view virtual override returns (address) {\n        return address(innerToken);\n    }\n\n    /************************************************************************\n     * internal functions\n     ************************************************************************/\n    function _debitFrom(\n        address _from,\n        uint16,\n        bytes32,\n        uint256 _amount\n    ) internal virtual override returns (uint256) {\n        require(_from == _msgSender(), \"ProxyOFT: owner is not send caller\");\n\n        _amount = _transferFrom(_from, address(this), _amount);\n\n        // _amount still may have dust if the token has transfer fee, then give the dust back to the sender\n        (uint256 amount, uint256 dust) = _removeDust(_amount);\n        if (dust > 0) innerToken.safeTransfer(_from, dust);\n\n        // check total outbound amount\n        outboundAmount += amount;\n        uint256 cap = _sd2ld(type(uint64).max);\n        require(cap >= outboundAmount, \"ProxyOFT: outboundAmount overflow\");\n\n        return amount;\n    }\n\n    function _creditTo(\n        uint16,\n        address _toAddress,\n        uint256 _amount\n    ) internal virtual override returns (uint256) {\n        outboundAmount -= _amount;\n\n        // tokens are already in this contract, so no need to transfer\n        if (_toAddress == address(this)) {\n            return _amount;\n        } else {\n            return _transferFrom(address(this), _toAddress, _amount);\n        }\n    }\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal virtual override returns (uint256) {\n        uint256 before = innerToken.balanceOf(_to);\n        if (_from == address(this)) {\n            innerToken.safeTransfer(_to, _amount);\n        } else {\n            innerToken.safeTransferFrom(_from, _to, _amount);\n        }\n        return innerToken.balanceOf(_to) - before;\n    }\n\n    function _ld2sdRate() internal view virtual override returns (uint256) {\n        return ld2sdRate;\n    }\n}\n"
    },
    "contracts/token/sPrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: aca0d66772607a851d7017b5cb3e6f38ee11f918;\n\npragma solidity ^0.8.27;\n\n// Importing necessary libraries and interfaces\nimport \"../interfaces/joe-v2/ILBRouter.sol\";\nimport \"../interfaces/joe-v2/ILBHooksBaseRewarder.sol\";\nimport \"../interfaces/ISPrimeTraderJoe.sol\";\nimport \"../interfaces/IVPrimeController.sol\";\nimport \"../lib/uniswap-v3/FullMath.sol\";\nimport \"../lib/joe-v2/math/LiquidityConfigurations.sol\";\nimport \"../lib/joe-v2/PriceHelper.sol\";\nimport \"../abstract/PendingOwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\n\n// SPrime contract declaration\ncontract SPrime is ISPrimeTraderJoe, ReentrancyGuardUpgradeable, PendingOwnableUpgradeable, ERC20Upgradeable, ProxyConnector {\n    using SafeERC20 for IERC20Metadata; // Using SafeERC20 for IERC20Metadata for safe token transfers\n    using PackedUint128Math for bytes32;\n\n    // Constants declaration\n    uint256 private constant _REBALANCE_MARGIN = 500;\n    uint256 private constant _DENOMINATOR = 10000;\n    uint256 private constant _MAX_SLIPPAGE = 500;\n    uint16 internal constant DEFAULT_BIN_STEP = 50;\n    uint256 public constant MAX_LOCK_TIME = 3 * 365 days;\n\n    // Mapping for storing pair information and user shares\n    mapping(address => LockDetails[]) public locks;\n\n    // Immutable variables for storing token and pair information\n    IERC20Metadata public tokenX;\n    IERC20Metadata public tokenY;\n    uint8 public tokenXDecimals;\n    uint8 public tokenYDecimals;\n    ILBPair public lbPair;\n    IPositionManager public positionManager;\n    IVPrimeController public vPrimeController;\n    address public traderJoeV2Router;\n\n    // Arrays for storing deltaIds and distributions\n    DepositForm[] private depositForm;\n\n    address public operator;\n    ILBHooksBaseRewarder public baseRewarder;\n\n    address private implementation;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n    * @dev initialize of the contract.\n    * @param tokenX_ The address of the token X.\n    * @param tokenY_ The address of the token Y.\n    * @param name_ The name of the SPrime token. ex: PRIME-USDC LP\n    * @param depositForm_ Pre-defined distributions and delta ids\n    * @param positionManager_ Position Manager contract for sPrime\n    * @param traderJoeV2Router_ Trader Joe V2 Router Address\n    */\n    function initialize(address tokenX_, address tokenY_, string memory name_, DepositForm[] calldata depositForm_, IPositionManager positionManager_, address traderJoeV2Router_) external initializer {\n        __PendingOwnable_init();\n        __ReentrancyGuard_init();\n        __ERC20_init(name_, \"sPrime\");\n\n        traderJoeV2Router = traderJoeV2Router_;\n        ILBFactory lbFactory = ILBRouter(traderJoeV2Router).getFactory();\n        ILBFactory.LBPairInformation memory pairInfo = lbFactory.getLBPairInformation(IERC20(tokenX_), IERC20(tokenY_), DEFAULT_BIN_STEP);\n\n        lbPair = pairInfo.LBPair;\n        tokenX = IERC20Metadata(address(lbPair.getTokenX()));\n        tokenY = IERC20Metadata(address(lbPair.getTokenY()));\n\n        tokenXDecimals = tokenX.decimals();\n        tokenYDecimals = tokenY.decimals();\n\n        for(uint256 i = 0 ; i < depositForm_.length ; i ++) {\n            depositForm.push(depositForm_[i]);\n        }\n\n        positionManager = positionManager_;\n    }\n\n    modifier onlyOperator() {\n        if (_msgSender() != operator) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    function setVPrimeControllerAddress(IVPrimeController _vPrimeController) public onlyOwner {\n        vPrimeController = _vPrimeController;\n    }\n\n    function setOperator(\n        address _operator\n    ) public onlyOwner {\n        operator = _operator;\n    }\n\n    function setBaseRewarder(\n        ILBHooksBaseRewarder _baseRewarder\n    ) public onlyOwner {\n        baseRewarder = _baseRewarder;\n    }\n\n    function setImplementation(\n        address _implementation\n    ) public onlyOwner {\n        implementation = _implementation;\n    }\n\n    /** Public View Functions */\n\n    function getLBPair() public view returns (ILBPair) {\n        return lbPair;\n    }\n\n    function getTokenX() public view returns (IERC20) {\n        return tokenX;\n    }\n\n    function getTokenY() public view returns (IERC20) {\n        return tokenY;\n    }\n\n    /**\n     * @dev Check if the active id is in the user position range\n     * @param user User Address.\n     * @return status bin status\n     */\n    function binInRange(address user) public view returns(bool status) {\n        uint256 tokenId = getUserTokenId(user);\n        if (tokenId == 0) {\n            revert NoPosition();\n        }\n        (bool success, bytes memory result) = implementation.staticcall(abi.encodeWithSignature(\"binInRange(uint256)\", tokenId));\n        if (!success)  {\n            revert ProxyCallFailed();\n        }\n        status = abi.decode(result, (bool));\n    }\n\n    /**\n     * @dev Returns the estimated USD value of the user position\n     * @param user User Address\n     * @param poolPrice Pool Price or oracle price for calculating proper token amount\n     * @return Total Value in tokenY amount for the user's position.\n     */\n    function getUserValueInTokenY(address user, uint256 poolPrice) public view returns (uint256) {\n        (,,,,uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(getUserTokenId(user));\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n        \n        if (depositConfig.depositIds.length != liquidityMinted.length) {\n            revert LengthMismatch();\n        }\n\n        uint256 amountX = 0;\n        uint256 amountY = 0;\n        (bool success, bytes memory result) = implementation.staticcall(abi.encodeWithSignature(\"getLiquidityTokenAmounts(uint256[],uint256[],uint256)\", depositConfig.depositIds, liquidityMinted, poolPrice));\n        \n        if (!success)  {\n            revert ProxyCallFailed();\n        }\n\n        (amountX, amountY) = abi.decode(result, (uint256, uint256));\n\n        amountY = amountY + FullMath.mulDiv(amountX, poolPrice * 10 ** tokenYDecimals, 10 ** (8 + tokenXDecimals));\n\n        return amountY;\n    }\n    \n    /**\n     * @dev Returns the estimated USD value of the user position\n     * @param user User Address\n     * @return Total Value in tokenY amount for the user's position.\n     */\n    function getUserValueInTokenY(address user) external view returns (uint256) {\n        uint256 poolPrice = getPoolPrice();\n        return getUserValueInTokenY(user, poolPrice);\n    }\n\n    \n    /**\n    * @dev Returns the fully vested locked balance for an account.\n    * @dev Full business logic description can be found in Pool::getFullyVestedLockedBalance() docstring\n    * @param account The address of the account.\n    * @return fullyVestedBalance Fully vested locked balance\n    */\n    function getFullyVestedLockedBalance(address account) public view returns (uint256 fullyVestedBalance) {\n        uint256 length = locks[account].length;\n        for (uint256 i; i != length; ++i) {\n            LockDetails memory lock = locks[account][i];\n            if (lock.unlockTime > block.timestamp) {\n                fullyVestedBalance += FullMath.mulDiv(lock.amount, lock.lockPeriod, MAX_LOCK_TIME);\n            }\n        }\n    }\n\n    /**\n    * @dev Returns the total locked balance of an account.\n    * @param account The address of the account.\n    * @return The total locked balance of the account.\n    */\n    function getLockedBalance(address account) public view returns (uint256) {\n        uint256 lockedBalance;\n        uint256 length = locks[account].length;\n        for (uint256 i; i != length; ++i) {\n            LockDetails memory lock = locks[account][i];\n            if (lock.unlockTime > block.timestamp) {\n                lockedBalance += lock.amount;\n            }\n        }\n        return lockedBalance;\n    }\n\n    /**\n    * @dev Returns the token id for the user\n    * @param user The user address\n    * @return tokenId token id owned by the user\n    */\n    function getUserTokenId(address user) public view returns(uint256 tokenId){\n        if(positionManager.balanceOf(user) > 0) {\n            tokenId = positionManager.tokenOfOwnerByIndex(user, 0);\n        }\n    }\n\n    /** Internal Functions */\n\n    /**\n     * @dev Returns the total weight of tokens in a liquidity pair.\n     * @param amountX Token X Amount.\n     * @param amountY Token Y Amount.\n     * @return weight The total weight of the tokens.\n     */\n    function _getTotalInTokenY(uint256 amountX, uint256 amountY) internal view returns(uint256 weight) {\n        uint256 amountXToY = _getTokenYFromTokenX(amountX);\n        weight = amountY + amountXToY;\n    }\n\n    function getPoolPrice() public view returns(uint256) {\n        uint256 price = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(lbPair.getActiveId()));\n        // price * 1e8 * 1edx / 1edy / 1e18\n        if (tokenXDecimals >= 10 + tokenYDecimals) {\n            price = price * 10 ** (tokenXDecimals - 10 - tokenYDecimals);\n        } else {\n            price = price / 10 ** (10 + tokenYDecimals - tokenXDecimals);\n        }\n        return price;\n    }\n\n    /**\n     * @dev Returns the estimated token Y amount from token X.\n     * @param amountX Token X Amount.\n     * @return amountY Token Y Amount to return.\n     */\n    function _getTokenYFromTokenX(uint256 amountX) internal view returns(uint256 amountY) {\n        (uint128 reserveA, uint128 reserveB) = lbPair.getReserves();\n        if(reserveA > 0 || reserveB > 0) {\n            uint256 price = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(lbPair.getActiveId()));\n            // Swap For Y : Convert token X to token Y\n            amountY = amountX * price / 1e18;\n        } else {\n            amountY = 0;\n        }\n    }\n\n    /**\n    * @dev Returns the updated amounts of tokens.\n    * @return amountX The updated amount of token X.\n    * @return amountY The updated amount of token Y.\n    */\n    function _swapForEqualValues(uint256 amountX, uint256 amountY, uint256 swapSlippage) internal returns(uint256, uint256) {\n        uint256 amountXToY = _getTokenYFromTokenX(amountX);\n        bool swapTokenX = amountY < amountXToY;\n        uint256 diff = swapTokenX ? amountXToY - amountY : amountY - amountXToY;\n        // (amountXToY != 0 || amountX == 0) for excluding the initial LP deposit\n        if(FullMath.mulDiv(amountY, _REBALANCE_MARGIN, _DENOMINATOR) < diff && (amountXToY > 0 || amountX == 0)) {\n            uint256 amountIn;\n            {\n                uint256 price = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(lbPair.getActiveId()));\n                // Swap For X : Convert token Y to token X\n                amountIn = FullMath.mulDiv(diff / 2, 1e18, price);\n            }\n\n            uint256 amountOut = diff / 2; \n\n            (amountIn, amountOut) = swapTokenX ? (amountIn, amountOut) : (amountOut, amountIn);\n            IERC20[] memory tokenPathDynamic = new IERC20[](2);\n            if (swapTokenX) {\n                tokenPathDynamic[0] = tokenX;\n                tokenPathDynamic[1] = tokenY;\n                tokenX.safeApprove(traderJoeV2Router, 0);\n                tokenX.safeApprove(traderJoeV2Router, amountIn);\n            } else {\n                tokenPathDynamic[0] = tokenY;\n                tokenPathDynamic[1] = tokenX;\n                tokenY.safeApprove(traderJoeV2Router, 0);\n                tokenY.safeApprove(traderJoeV2Router, amountIn);\n            }\n\n            ILBRouter.Version[] memory versionsDynamic = new ILBRouter.Version[](1);\n            versionsDynamic[0] = ILBRouter.Version.V2_2;\n\n            uint256[] memory binStepsDynamic = new uint256[](1);\n            binStepsDynamic[0] = DEFAULT_BIN_STEP;\n\n            ILBRouter.Path memory path = ILBRouter.Path({\n                pairBinSteps: binStepsDynamic,\n                versions: versionsDynamic,\n                tokenPath: tokenPathDynamic\n            });\n            amountOut = ILBRouter(traderJoeV2Router).swapExactTokensForTokens(amountIn, amountOut * (_DENOMINATOR - swapSlippage) / _DENOMINATOR, path, address(this), block.timestamp);\n            (amountX, amountY) = swapTokenX ? (amountX - amountIn,amountY + amountOut) : (amountX + amountOut, amountY - amountIn);\n        }\n        return (amountX, amountY);\n    }\n\n    /**\n    * @dev Returns the liquidity configurations for the given range.\n    * @param centerId The active id of the pair.\n    * @return liquidityConfigs The liquidity configurations for the given range.\n    * @return depositIds Deposit ID list.\n    */\n    function _encodeDepositConfigs(uint256 centerId) internal view returns (bytes32[] memory liquidityConfigs, uint256[] memory depositIds) {\n        uint256 length = depositForm.length;\n        liquidityConfigs = new bytes32[](length);\n        depositIds = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            DepositForm memory config = depositForm[i];\n            int256 _id = int256(centerId) + config.deltaId;\n            if (!(_id >= 0 && uint256(_id) <= type(uint24).max)) {\n                revert Overflow();\n            }\n            depositIds[i] = uint256(_id);\n            liquidityConfigs[i] = LiquidityConfigurations.encodeParams(config.distributionX, config.distributionY, uint24(uint256(_id)));\n        }\n    }\n\n    /**\n    * @dev Withdraws tokens from the Liquidity Book Pair.\n    * @param user User address to withdraw\n    * @param depositIds Deposit ID list.\n    * @param liquidityMinted The amount of ids to withdraw.\n    * @param share sPrime amount to withdraw.\n    * @return balanceX The amount of token X received.\n    * @return balanceY The amount of token Y received.\n    */\n    function _withdrawFromLB(address user, uint256[] memory depositIds, uint256[] memory liquidityMinted, uint256 share) internal returns (uint256 balanceX, uint256 balanceY, uint256[] memory liquidityAmounts) {\n        if (depositIds.length != liquidityMinted.length) {\n            revert LengthMismatch();\n        }\n\n        uint256 length;\n        uint256 totalShare = balanceOf(user);\n        // Get the lbPair address and the delta between the upper and lower range.\n        uint256 delta = depositIds.length;\n\n        uint256[] memory ids = new uint256[](delta);\n        uint256[] memory amounts = new uint256[](delta);\n        liquidityAmounts  = new uint256[](delta);\n\n        // Get the ids and amounts of the tokens to withdraw.\n        for (uint256 i; i < delta;) {\n            uint256 id = depositIds[i];\n            liquidityAmounts[i] = FullMath.mulDiv(liquidityMinted[i], share, totalShare);\n            if (liquidityAmounts[i] != 0) {\n                ids[length] = id;\n                amounts[length] = liquidityAmounts[i];\n\n                unchecked {\n                    ++length;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 balanceXBefore = tokenX.balanceOf(address(this));\n        uint256 balanceYBefore = tokenY.balanceOf(address(this));\n\n        // If the range is not empty, burn the tokens from the lbPair.\n        if (length > 0) {\n            // If the length is different than the delta, update the arrays, this allows to avoid the zero share error.\n            if (length != delta) {\n                assembly {\n                    mstore(ids, length)\n                    mstore(amounts, length)\n                }\n            }\n\n            lbPair.burn(address(this), address(this), ids, amounts);\n        }\n\n        // Get the amount of tokens in the sPrime contract.\n        balanceX = tokenX.balanceOf(address(this)) - balanceXBefore;\n        balanceY = tokenY.balanceOf(address(this)) - balanceYBefore;\n    }\n\n    /**\n     * @dev Deposits tokens into the lbPair.\n     * @param user The user address to receive sPrime.\n     * @param centerId The active Id.\n     */\n    function _depositToLB(address user, uint256 centerId) internal {\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n        if(depositConfig.depositIds.length == 0) {\n            (depositConfig.liquidityConfigs, depositConfig.depositIds) = _encodeDepositConfigs(centerId);\n        }\n\n        // Mint the liquidity tokens.\n        (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted) = lbPair.mint(address(this), depositConfig.liquidityConfigs, user);\n        \n        uint256 share = _getTotalInTokenY(amountsReceived.decodeX() - amountsLeft.decodeX(), amountsReceived.decodeY() - amountsLeft.decodeY());\n        uint256 tokenId = getUserTokenId(user);\n        if(tokenId == 0) {\n            tokenId = positionManager.mint(IPositionManager.MintParams({\n                recipient: user,\n                totalShare: share,\n                centerId: centerId,\n                liquidityMinted: liquidityMinted,\n                liquidityConfigs: depositConfig.liquidityConfigs,\n                depositIds: depositConfig.depositIds\n            }));\n        } else  {\n            positionManager.update(IPositionManager.UpdateParams({\n                tokenId: tokenId,\n                share: share,\n                liquidityAmounts: liquidityMinted,\n                isAdd: true\n            }));\n        }\n        _mint(user, share);\n    }\n\n    /**\n    * @dev Internal function to transfer tokens between addresses.\n    * @param from The address from which tokens are being transferred.\n    * @param to The address to which tokens are being transferred.\n    * @param amountX The amount of token X to transfer.\n    * @param amountY The amount of token Y to transfer.\n    */\n    function _transferTokens(address from, address to, uint256 amountX, uint256 amountY) internal {\n        if(from == address(this)) {\n            if(amountX > 0) tokenX.safeTransfer(to, amountX);\n            if(amountY > 0) tokenY.safeTransfer(to, amountY);\n        } else {\n            if(amountX > 0) tokenX.safeTransferFrom(from, to, amountX);\n            if(amountY > 0) tokenY.safeTransferFrom(from, to, amountY);\n        }\n    }\n\n\n    /** Public And External Functions */\n\n    /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param activeIdDesired The active id that user wants to add liquidity from\n    * @param idSlippage The number of id that are allowed to slip\n    * @param amountX The amount of token X to deposit.\n    * @param amountY The amount of token Y to deposit.\n    * @param isRebalance Rebalance the existing position with deposit.\n    * @param swapSlippage Slippage for the rebalance.\n    */\n    function deposit(uint256 activeIdDesired, uint256 idSlippage, uint256 amountX, uint256 amountY, bool isRebalance, uint256 swapSlippage) public nonReentrant {\n        _transferTokens(_msgSender(), address(this), amountX, amountY);\n\n        _deposit(_msgSender(), activeIdDesired, idSlippage, amountX, amountY, isRebalance, swapSlippage);\n\n        notifyVPrimeController(_msgSender());\n    }\n\n\n    function _deposit(address user, uint256 activeIdDesired, uint256 idSlippage, uint256 amountX, uint256 amountY, bool isRebalance, uint256 swapSlippage) internal {\n\n        if (swapSlippage > _MAX_SLIPPAGE) {\n            revert SlippageTooHigh();\n        }\n\n        uint256 tokenId = getUserTokenId(user);\n        uint256 activeId = lbPair.getActiveId();\n        if(tokenId > 0) {\n            (,,, uint256 share, uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(tokenId);\n            activeId = centerId;\n            if(isRebalance) { // Withdraw Position For Rebalance\n                IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n                (uint256 amountXBefore, uint256 amountYBefore, ) = _withdrawFromLB(user, depositConfig.depositIds, liquidityMinted, share);\n                \n                positionManager.burn(tokenId);   \n                _burn(user, share);\n\n                (amountX, amountY) = (amountX + amountXBefore, amountY + amountYBefore);\n                tokenId = 0;\n            }\n        }\n        (amountX, amountY) = _swapForEqualValues(amountX, amountY, swapSlippage);\n        \n        // Revert if active id moved without rebalancing\n        if (!(activeId == lbPair.getActiveId() || tokenId == 0)) {\n            revert BinIdChanged();\n        }\n        activeId = lbPair.getActiveId();\n\n        if (!(activeIdDesired + idSlippage >= activeId && activeId + idSlippage >= activeIdDesired)) {\n            revert SlippageTooHigh();\n        }\n\n        _transferTokens(address(this), address(lbPair), amountX, amountY);\n        _depositToLB(user, activeId);\n    }\n\n    /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param user The active id that user wants to add liquidity from\n    * @param percentForLocks sPrime amount % to lock\n    * @param lockPeriods Lock period to Lock for each amount\n    * @param amountX The amount of token X to deposit.\n    * @param amountY The amount of token Y to deposit.\n    * @param activeIdDesired Desired bin id.\n    * @param idSlippage Bin id slippage from the active id.\n    */\n    function mintForUserAndLock(address user, uint256[] calldata percentForLocks, uint256[] calldata lockPeriods, uint256 amountX, uint256 amountY, uint256 activeIdDesired, uint256 idSlippage) public onlyOperator nonReentrant {\n        if (percentForLocks.length != lockPeriods.length) {\n            revert LengthMismatch();\n        }\n        \n        uint256 oldBalance = balanceOf(user);\n        _transferTokens(_msgSender(), address(this), amountX, amountY);\n        _deposit(user, activeIdDesired, idSlippage, amountX, amountY, true, _MAX_SLIPPAGE);\n        if (balanceOf(user) < oldBalance) {\n            revert NegativeMint();\n        }\n\n        uint256 totalLock;\n        for(uint8 i = 0 ; i < lockPeriods.length ; i ++) {\n            totalLock += percentForLocks[i];\n        }\n        if (totalLock != 100) {\n            revert ShouldLock100Percent();\n        }\n        \n        uint256 balance = balanceOf(user) - oldBalance;\n        totalLock = 0;\n        for(uint8 i = 0 ; i < lockPeriods.length ; i ++) {\n            if (lockPeriods[i] > MAX_LOCK_TIME) {\n                revert MaxLockTimeExceeded();\n            }\n            // Should minus from total balance to avoid the round issue\n            uint256 amount = i == lockPeriods.length - 1 ? balance - totalLock : balance * percentForLocks[i] / 100;\n            locks[user].push(LockDetails({\n                lockPeriod: lockPeriods[i],\n                amount: amount,\n                unlockTime: block.timestamp + lockPeriods[i]\n            }));\n            totalLock += amount;\n        }\n\n        notifyVPrimeController(user);\n    }\n\n    /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param ids Depoisit Ids from TraderJoe\n    * @param amounts Minted LBT amount for each deposit id\n    * @param activeIdDesired The active id that user wants to add liquidity from\n    * @param idSlippage The number of id that are allowed to slip\n    * @param swapSlippage Slippage for the rebalance.\n    */\n    function migrateLiquidity(uint256[] calldata ids, uint256[] calldata amounts, uint256 activeIdDesired, uint256 idSlippage, uint256 swapSlippage) public nonReentrant {\n        uint256 balanceXBefore = tokenX.balanceOf(address(this));\n        uint256 balanceYBefore = tokenY.balanceOf(address(this));\n\n        lbPair.burn(_msgSender(), address(this), ids, amounts);\n\n        _deposit(_msgSender(), activeIdDesired, idSlippage, tokenX.balanceOf(address(this)) - balanceXBefore, tokenY.balanceOf(address(this)) - balanceYBefore, true, swapSlippage);\n\n        notifyVPrimeController(_msgSender());\n    }\n\n    /**\n    * @dev Users can use withdraw function for withdrawing their share.\n    * @param share Amount to withdraw\n    */\n    function withdraw(uint256 share, uint256 amountXMin, uint256 amountYMin) external nonReentrant {\n        uint256 tokenId = getUserTokenId(_msgSender());\n        if (tokenId == 0) {\n            revert NoPosition();\n        }\n\n        (,,,, uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(tokenId);\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n\n        uint256 lockedBalance = getLockedBalance(_msgSender());\n        if (balanceOf(_msgSender()) < share + lockedBalance) {\n            revert BalanceIsLocked();\n        }\n\n        (uint256 amountX, uint256 amountY, uint256[] memory liquidityAmounts) = _withdrawFromLB(_msgSender(), depositConfig.depositIds, liquidityMinted, share);\n        if(amountX < amountXMin || amountY < amountYMin) {\n            revert SlippageTooHigh();\n        }\n        positionManager.update(IPositionManager.UpdateParams({\n            tokenId: tokenId,\n            share: share,\n            liquidityAmounts: liquidityAmounts,\n            isAdd: false\n        }));\n\n        // Burn Position NFT\n        if(balanceOf(_msgSender()) == share) {\n            positionManager.burn(tokenId);\n        }\n\n        // Send the tokens to the user.\n        _transferTokens(address(this), _msgSender(), amountX, amountY);\n\n        _burn(_msgSender(), share);\n\n        notifyVPrimeController(_msgSender());\n    }\n\n    /**\n    * @dev Locks a specified amount of balance for a specified lock period.\n    * @param amount The amount of balance to be locked.\n    * @param lockPeriod The duration for which the balance will be locked.\n    */\n    function lockBalance(uint256 amount, uint256 lockPeriod) public nonReentrant {\n        uint256 lockedBalance = getLockedBalance(_msgSender());\n        if (balanceOf(_msgSender()) < amount + lockedBalance) {\n            revert InsufficientBalance();\n        }\n        if (lockPeriod > MAX_LOCK_TIME) {\n            revert MaxLockTimeExceeded();\n        }\n        locks[_msgSender()].push(LockDetails({\n            lockPeriod: lockPeriod,\n            amount: amount,\n            unlockTime: block.timestamp + lockPeriod\n        }));\n\n        notifyVPrimeController(_msgSender());\n    }\n\n    /**\n    * @dev Claims the reward from TraderJoe v2.2 Base Reward Pool\n    * @param receiver User address that will receive the collected reward.\n    * @param ids Bin Id list to claim.\n    */\n    function claim(address receiver, uint256[] calldata ids) public onlyOwner nonReentrant {\n        baseRewarder.claim(address(this), ids);\n        IERC20Metadata rewardToken = IERC20Metadata(address(baseRewarder.getRewardToken()));\n        uint256 reward = rewardToken.balanceOf(address(this));\n        if(reward > 0) {\n            rewardToken.safeTransfer(receiver, reward);\n        }\n    }\n\n    /** Overrided Functions */\n\n    /**\n    * @dev The hook that happens before token transfer.\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param amount The amount to transfer.\n    */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if(from != address(0) && to != address(0)) {\n            uint256 lockedBalance = getLockedBalance(from);\n            uint256 fromBalance = balanceOf(from);\n            if (fromBalance < amount + lockedBalance) {\n                revert InsufficientBalance();\n            }\n            if (getUserTokenId(to) != 0) {\n                revert UserAlreadyHasPosition();\n            }\n            \n            uint256 tokenId = getUserTokenId(from);\n\n            if(fromBalance == amount) {\n                positionManager.forceTransfer(from, to, tokenId);\n            } else {\n                (,,,,uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(tokenId);\n                IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n                for(uint256 i = 0 ; i < liquidityMinted.length ; i ++) {\n                    liquidityMinted[i] = FullMath.mulDiv(liquidityMinted[i], amount, fromBalance);\n                }\n\n                positionManager.update(IPositionManager.UpdateParams({\n                    tokenId: tokenId,\n                    share: amount,\n                    liquidityAmounts: liquidityMinted,\n                    isAdd: false\n                }));\n\n                positionManager.mint(IPositionManager.MintParams({\n                    recipient: to,\n                    totalShare: amount,\n                    centerId: centerId,\n                    liquidityMinted: liquidityMinted,\n                    liquidityConfigs: depositConfig.liquidityConfigs,\n                    depositIds: depositConfig.depositIds\n                }));\n            }\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0) && to != address(0)) {\n            notifyVPrimeController(from);\n            notifyVPrimeController(to);\n        }\n    }\n\n    function containsOracleCalldata() public pure returns (bool) {\n        // Checking if the calldata ends with the RedStone marker\n        bool hasValidRedstoneMarker;\n        assembly {\n            let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n            hasValidRedstoneMarker := eq(\n                REDSTONE_MARKER_MASK,\n                and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n            )\n        }\n        return hasValidRedstoneMarker;\n    }\n\n    function notifyVPrimeController(address account) internal {\n        if(address(vPrimeController) != address(0)){\n            if(containsOracleCalldata()) {\n                proxyCalldata(\n                    address(vPrimeController),\n                    abi.encodeWithSignature\n                    (\"updateVPrimeSnapshot(address)\", account),\n                    false\n                );\n            } else {\n                vPrimeController.setUserNeedsUpdate(account);\n            }\n        }\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return tokenYDecimals;\n    }\n\n    // CUSTOM ERRORS\n    error InsufficientBalance();\n    error BalanceIsLocked();\n    error NoPosition();\n    error LengthMismatch();\n    error MaxLockTimeExceeded();\n    error SlippageTooHigh();\n    error BinIdChanged();\n    error UserAlreadyHasPosition();\n    error NegativeMint();\n    error ShouldLock100Percent();\n    error Unauthorized();\n    error Overflow();\n    error ProxyCallFailed();\n}"
    },
    "contracts/token/sPrimeImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: aca0d66772607a851d7017b5cb3e6f38ee11f918;\n\npragma solidity ^0.8.27;\n\n// Importing necessary libraries and interfaces\nimport \"../interfaces/ISPrimeTraderJoe.sol\";\nimport \"../interfaces/IPositionManager.sol\";\nimport \"../lib/joe-v2/math/SafeCast.sol\";\nimport \"../lib/uniswap-v3/FullMath.sol\";\nimport \"../lib/joe-v2/math/Uint256x256Math.sol\";\nimport \"../lib/joe-v2/PriceHelper.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// SPrime contract declaration\ncontract SPrimeImpl {\n    using SafeCast for uint256; // Using SafeCast for uint256 for safe type casting\n    using Uint256x256Math for uint256;\n\n    address public sPrime;\n\n    constructor(address sPrime_) {\n        sPrime = sPrime_;\n    }\n\n    /**\n     * @dev Check if the active id is in the user position range\n     * @param tokenId Token Id.\n     * @return status bin status\n     */\n    function binInRange(uint256 tokenId) public view returns(bool) {\n        IPositionManager positionManager = ISPrimeTraderJoe(sPrime).positionManager();\n        ILBPair lbPair = ISPrimeTraderJoe(sPrime).getLBPair();\n\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfigFromTokenId(tokenId);\n\n        uint256[] memory depositIds = depositConfig.depositIds;\n        uint256 activeId = lbPair.getActiveId();\n        if (depositIds[0] <= activeId && depositIds[depositIds.length - 1] >= activeId) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n    * @dev Returns the token balances for the specific bin.\n    * @param depositIds Deposited bin id list.\n    * @param liquidityMinted Liquidity minted for each bin.\n    * @param poolPrice Oracle Price\n    */\n    function getLiquidityTokenAmounts(uint256[] memory depositIds, uint256[] memory liquidityMinted, uint256 poolPrice) public view returns(uint256 amountX, uint256 amountY) {\n        \n        ILBPair lbPair = ISPrimeTraderJoe(sPrime).getLBPair();\n        IERC20Metadata tokenY = IERC20Metadata(address(ISPrimeTraderJoe(sPrime).getTokenY()));\n        poolPrice = FullMath.mulDiv(poolPrice, 10 ** tokenY.decimals(), 1e8);\n\n        uint24 binId = lbPair.getIdFromPrice(PriceHelper.convertDecimalPriceTo128x128(poolPrice));\n\n        for (uint256 i; i < depositIds.length; ++i) {\n            uint24 id = depositIds[i].safe24();\n\n            uint256 liquidity = liquidityMinted[i];\n            (uint256 binReserveX, uint256 binReserveY) = lbPair.getBin(id);\n\n            // Get Current Pool price from id.\n            uint256 currentPrice = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(id));\n\n            uint256 totalSupply = lbPair.totalSupply(id);\n            uint256 xAmount = liquidity.mulDivRoundDown(binReserveX, totalSupply);\n            uint256 yAmount = liquidity.mulDivRoundDown(binReserveY, totalSupply);\n            if(binId > id) {\n                yAmount = yAmount + FullMath.mulDiv(xAmount, currentPrice, 10 ** 18);\n                xAmount = 0;\n            } else if(binId < id) {\n                xAmount = xAmount + FullMath.mulDiv(yAmount, 10 ** 18, currentPrice);\n                yAmount = 0;\n            } \n\n            amountX += xAmount;\n            amountY += yAmount;\n        }\n    }\n}"
    },
    "contracts/token/sPrimeUniswap.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f02dab5ae5dd02d0771bb7dedabb0ad6ac8802c;\npragma solidity ^0.8.27;\n\n// Importing necessary libraries and interfaces\nimport \"../interfaces/ISPrimeUniswap.sol\";\nimport \"../interfaces/IVPrimeController.sol\";\nimport \"../interfaces/uniswap-v3/IUniswapV3Factory.sol\";\nimport \"../interfaces/uniswap-v3/ISwapRouter.sol\";\nimport \"../lib/uniswap-v3/OracleLibrary.sol\";\nimport \"../lib/uniswap-v3/PositionValue.sol\";\nimport \"../lib/uniswap-v3/UniswapV3IntegrationHelper.sol\";\nimport \"../abstract/PendingOwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/utils/ERC721HolderUpgradeable.sol\";\n\n// SPrime contract declaration\ncontract sPrimeUniswap is\n    ISPrimeUniswap,\n    ReentrancyGuardUpgradeable,\n    PendingOwnableUpgradeable,\n    ERC20Upgradeable,\n    ERC721HolderUpgradeable,\n    ProxyConnector\n{\n    using SafeERC20 for IERC20Metadata; // Using SafeERC20 for IERC20 for safe token transfers\n    using PositionValue for INonfungiblePositionManager;\n    // Constants declaration\n    uint256 private constant _REBALANCE_MARGIN = 5; // 5% Rebalance Limit - If token diff is smaller than this percent, it will skip the token swap part\n    uint256 private constant _MAX_SLIPPAGE = 500; // 5% Max slippage at the time of token swap for equal values\n    uint256 public constant MAX_LOCK_TIME = 3 * 365 days;\n    uint256 public constant PRECISION = 20;\n    uint256 private constant _DENOMINATOR = 10000;\n\n    // Mapping for storing pair information and user shares\n    mapping(address => LockDetails[]) public locks;\n    mapping(address => uint256) public userTokenId;\n\n    // Immutable variables for storing token and pair information\n    IERC20Metadata public tokenX;\n    IERC20Metadata public tokenY;\n    int24 public tickSpacing;\n    int24 private deltaId;\n\n    IUniswapV3Pool public pool;\n    uint8 public tokenDecimals;\n    uint24 public feeTier;\n\n    INonfungiblePositionManager public positionManager;\n    ISwapRouter public swapRouter;\n    IVPrimeController public vPrimeController;\n\n    bool public tokenSequence;\n    \n    address private implementation;\n    address public operator;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n     * @dev Initializer of the contract.\n     * @param tokenX_ The address of the token X.\n     * @param tokenY_ The address of the token Y.\n     * @param name_ The name of the SPrime token. ex: PRIME-USDC LP\n     * @param feeTier_ Fee Tier of Uniswap V3 Pool\n     * @param deltaId_ Delta id for tick lower and tick upper\n     * @param positionManager_ Uniswap v3 NonfungiblePositionManager contract\n     * @param swapRouter_ Uniswap V3 Swap Router contract\n     * @param uniV3Factory_ Uniswap V3 Factory contract\n     */\n    function initialize(\n        IERC20Metadata tokenX_,\n        IERC20Metadata tokenY_,\n        string memory name_,\n        uint24 feeTier_,\n        int24 deltaId_,\n        INonfungiblePositionManager positionManager_,\n        ISwapRouter swapRouter_,\n        IUniswapV3Factory uniV3Factory_\n    ) external initializer {\n        __PendingOwnable_init();\n        __ReentrancyGuard_init_unchained();\n        __ERC20_init_unchained(name_, \"sPrime\");\n        __ERC721Holder_init_unchained();\n\n        tokenDecimals = tokenY_.decimals();\n\n        tokenSequence = tokenX_ > tokenY_;\n        tokenX = tokenX_;\n        tokenY = tokenY_;\n        feeTier = feeTier_;\n\n        positionManager = positionManager_;\n        swapRouter = swapRouter_;\n\n        address poolAddress = uniV3Factory_.getPool(\n            address(tokenX_),\n            address(tokenY_),\n            feeTier_\n        );\n        if (poolAddress == address(0)) {\n            revert PoolNotExisting();\n        }\n        pool = IUniswapV3Pool(poolAddress);\n        tickSpacing = pool.tickSpacing();\n        deltaId = deltaId_;\n    }\n\n    modifier onlyOperator() {\n        if(_msgSender() != operator) {\n            revert AccessDenied();\n        }\n        _;\n    }\n\n    function setVPrimeControllerAddress(\n        IVPrimeController _vPrimeController\n    ) public onlyOwner {\n        vPrimeController = _vPrimeController;\n    }\n\n    function setOperator(\n        address _operator\n    ) public onlyOwner {\n        operator = _operator;\n    }\n\n    function setImplementation(\n        address _implementation\n    ) public onlyOwner {\n        implementation = _implementation;\n    }\n\n    function getTokenX() public view returns (IERC20) {\n        return IERC20(tokenX);\n    }\n\n    function getTokenY() public view returns (IERC20) {\n        return IERC20(tokenY);\n    }\n\n    function getToken0() internal view returns (IERC20Metadata) {\n        return IERC20Metadata(pool.token0());\n    }\n\n    function getToken1() internal view returns (IERC20Metadata) {\n        return IERC20Metadata(pool.token1());\n    }\n\n    /**\n     * @dev Check if the tick is in the user position range\n     * @param user User Address.\n     * @return status tick status\n     */\n    function tickInRange(address user) public view returns (bool status) {\n        uint256 tokenId = userTokenId[user];\n        if (tokenId == 0) {\n            revert NoPosition();\n        }\n        (bool success, bytes memory result) = implementation.staticcall(abi.encodeWithSignature(\"tickInRange(uint256)\", tokenId));\n        if (!success)  {\n            revert ProxyCallFailed();\n        }\n        status = abi.decode(result, (bool));\n    }\n\n    /**\n     * @dev Returns the estimated USD value of the user position\n     * @param user User Address\n     * @param poolPrice Pool Price or oracle price for calculating proper token amount\n     * @return amountY Total Value in tokenY amount for the user's position.\n     */\n    function getUserValueInTokenY(\n        address user,\n        uint256 poolPrice\n    ) public view returns (uint256 amountY) {\n        (bool success, bytes memory result) = implementation.staticcall(abi.encodeWithSignature(\"getUserValueInTokenY(address,uint256)\", user, poolPrice));\n        \n        if (!success)  {\n            revert ProxyCallFailed();\n        }\n        amountY = abi.decode(result, (uint256));\n    }\n\n    /**\n     * @dev Returns the estimated USD value of the user position\n     * @param user User Address\n     * @return Total Value in tokenY amount for the user's position.\n     */\n    function getUserValueInTokenY(address user) external view returns (uint256) {\n        uint256 poolPrice = getPoolPrice();\n        return getUserValueInTokenY(user, poolPrice);\n    }\n\n    /**\n     * @dev Returns the fully vested locked balance for an account.\n     * @dev Full business logic description can be found in Pool::getFullyVestedLockedBalance() docstring\n     * @param account The address of the account.\n     * @return fullyVestedBalance Fully vested locked balance\n     */\n    function getFullyVestedLockedBalance(\n        address account\n    ) public view returns (uint256 fullyVestedBalance) {\n        uint256 length = locks[account].length;\n        for (uint256 i; i != length; ++i) {\n            if (locks[account][i].unlockTime > block.timestamp) {\n                fullyVestedBalance += FullMath.mulDiv(\n                    locks[account][i].amount,\n                    locks[account][i].lockPeriod,\n                    MAX_LOCK_TIME\n                );\n            }\n        }\n    }\n\n    /**\n     * @dev Returns the total locked balance of an account.\n     * @param account The address of the account.\n     * @return The total locked balance of the account.\n     */\n    function getLockedBalance(address account) public view returns (uint256) {\n        uint256 lockedBalance = 0;\n        uint256 length = locks[account].length;\n        for (uint256 i; i != length; ++i) {\n            if (locks[account][i].unlockTime > block.timestamp) {\n                lockedBalance += locks[account][i].amount;\n            }\n        }\n        return lockedBalance;\n    }\n\n    /**\n     * @dev Returns the total weight of tokens in a liquidity pair.\n     * @param amountX Token X Amount.\n     * @param amountY Token Y Amount.\n     * @return weight The total weight of tokens in the liquidity pair.\n     */\n    function _getTotalInTokenY(\n        uint256 amountX,\n        uint256 amountY\n    ) internal view returns (uint256 weight) {\n        uint256 amountXToY = _getTokenYFromTokenX(amountX);\n        weight = amountY + amountXToY;\n    }\n\n    /**\n     * @dev Returns the estimated token Y amount from token X.\n     * @param amountX Token X Amount.\n     * @return amountY Token Y Amount to return.\n     */\n    function _getTokenYFromTokenX(\n        uint256 amountX\n    ) internal view returns (uint256 amountY) {\n        (, int24 tick, , , , , ) = pool.slot0();\n        amountY = OracleLibrary.getQuoteAtTick(\n            tick,\n            uint128(amountX),\n            address(tokenX),\n            address(tokenY)\n        );\n    }\n\n    function getPoolPrice() public view returns (uint256) {\n        (, int24 tick, , , , , ) = pool.slot0();\n        uint256 price = OracleLibrary.getQuoteAtTick(\n            tick,\n            uint128(10 ** tokenX.decimals()),\n            address(tokenX),\n            address(tokenY)\n        );\n        return\n            FullMath.mulDiv(\n                price,\n                1e8,\n                10 ** tokenY.decimals()\n            );\n    }\n\n    /**\n     * @dev Returns the updated amounts of tokens.\n     * @return amountX The updated amount of token X.\n     * @return amountY The updated amount of token Y.\n     */\n    function _swapForEqualValues(\n        uint256 amountX,\n        uint256 amountY,\n        uint256 swapSlippage\n    ) internal returns (uint256, uint256) {\n        uint256 amountXToY = _getTokenYFromTokenX(amountX);\n        bool swapTokenX = amountY < amountXToY;\n        uint256 diff = swapTokenX ? amountXToY - amountY : amountY - amountXToY;\n        // (amountXToY != 0 || amountX == 0) for excluding the initial LP deposit\n        if (\n            (amountY * _REBALANCE_MARGIN) / 100 < diff &&\n            (amountXToY > 0 || amountX == 0)\n        ) {\n            uint256 amountIn;\n            {\n                (, int24 tick, , , , , ) = pool.slot0();\n                amountIn = OracleLibrary.getQuoteAtTick(\n                    tick,\n                    uint128(diff / 2),\n                    address(tokenY),\n                    address(tokenX)\n                );\n            }\n            uint256 amountOut = diff / 2;\n\n            address tokenIn;\n            address tokenOut;\n\n            (amountIn, amountOut) = swapTokenX\n                ? (amountIn, amountOut)\n                : (amountOut, amountIn);\n\n            if (swapTokenX) {\n                tokenIn = address(tokenX);\n                tokenOut = address(tokenY);\n            } else {\n                tokenIn = address(tokenY);\n                tokenOut = address(tokenX);\n            }\n            \n            IERC20Metadata(tokenIn).safeApprove(address(swapRouter), 0);\n            IERC20Metadata(tokenIn).safeApprove(address(swapRouter), amountIn);\n            \n            (amountIn, amountOut) = _processTokenSwap(\n                tokenIn,\n                tokenOut,\n                amountIn,\n                amountOut * (_DENOMINATOR - swapSlippage) / _DENOMINATOR\n            );\n\n            (amountX, amountY) = swapTokenX\n                ? (amountX - amountIn, amountY + amountOut)\n                : (amountX + amountOut, amountY - amountIn);\n        }\n        return (amountX, amountY);\n    }\n\n    function _processTokenSwap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amount,\n        uint256 amountOutMinimum\n    ) internal returns (uint256 amountIn, uint256 amountOut) {\n        uint256 beforeBalance = IERC20(tokenIn).balanceOf(address(this));\n        amountOut = swapRouter.exactInputSingle(\n            ISwapRouter.ExactInputSingleParams({\n                tokenIn: tokenIn,\n                tokenOut: tokenOut,\n                fee: feeTier,\n                recipient: address(this),\n                amountIn: amount,\n                amountOutMinimum: amountOutMinimum,\n                sqrtPriceLimitX96: 0\n            })\n        );\n        amountIn = beforeBalance - IERC20(tokenIn).balanceOf(address(this));\n    }\n\n    function _depositToUniswap(\n        address user,\n        int24 tickLower,\n        int24 tickUpper,\n        uint256 amountX,\n        uint256 amountY,\n        uint256 desiredAmountX,\n        uint256 desiredAmountY\n    ) internal {\n        uint256 tokenId = userTokenId[user];\n        uint256 amountXAdded;\n        uint256 amountYAdded;\n        tokenX.forceApprove(address(positionManager), amountX);\n        tokenY.forceApprove(address(positionManager), amountY);\n\n        (uint256 amount0, uint256 amount1) = tokenSequence ? (amountY, amountX) : (amountX, amountY);\n        (desiredAmountX, desiredAmountY) = tokenSequence ? (desiredAmountY, desiredAmountX) : (desiredAmountX, desiredAmountY);\n\n        if (tokenId == 0) {\n            (tokenId, , amountXAdded, amountYAdded) = positionManager.mint(\n                INonfungiblePositionManager.MintParams({\n                    token0: address(getToken0()),\n                    token1: address(getToken1()),\n                    fee: feeTier,\n                    tickLower: tickLower,\n                    tickUpper: tickUpper,\n                    amount0Desired: amount0,\n                    amount1Desired: amount1,\n                    amount0Min: desiredAmountX,\n                    amount1Min: desiredAmountY,\n                    recipient: address(this),\n                    deadline: block.timestamp\n                })\n            );\n            userTokenId[user] = tokenId;\n        } else {\n            (, amountXAdded, amountYAdded) = positionManager.increaseLiquidity(\n                INonfungiblePositionManager.IncreaseLiquidityParams({\n                    tokenId: tokenId,\n                    amount0Desired: amount0,\n                    amount1Desired: amount1,\n                    amount0Min: desiredAmountX,\n                    amount1Min: desiredAmountY,\n                    deadline: block.timestamp\n                })\n            );\n        }\n        if(tokenSequence) {\n            (amountXAdded, amountYAdded) = (amountYAdded, amountXAdded);\n        }\n\n        uint256 share = _getTotalInTokenY(amountXAdded, amountYAdded);\n\n        _mint(user, share);\n\n        _transferTokens(\n            address(this),\n            user,\n            amountX - amountXAdded,\n            amountY - amountYAdded\n        );\n    }\n\n    /**\n     * @dev Internal function to transfer tokens between addresses.\n     * @param from The address from which tokens are being transferred.\n     * @param to The address to which tokens are being transferred.\n     * @param amountX The amount of token X to transfer.\n     * @param amountY The amount of token Y to transfer.\n     */\n    function _transferTokens(\n        address from,\n        address to,\n        uint256 amountX,\n        uint256 amountY\n    ) internal {\n        if (from == address(this)) {\n            if (amountX > 0) tokenX.safeTransfer(to, amountX);\n            if (amountY > 0) tokenY.safeTransfer(to, amountY);\n        } else {\n            if (amountX > 0) tokenX.safeTransferFrom(from, to, amountX);\n            if (amountY > 0) tokenY.safeTransferFrom(from, to, amountY);\n        }\n    }\n\n    /**\n     * @dev Users can use deposit function for depositing tokens to the specific bin.\n     * @param tickDesired The tick that user wants to add liquidity from\n     * @param tickSlippage The tick slippage that are allowed to slip\n     * @param amountX The amount of token X to deposit.\n     * @param amountY The amount of token Y to deposit.\n     * @param desiredAmountX The desired amount of token X to deposit.\n     * @param desiredAmountY The desired amount of token Y to deposit.\n     * @param isRebalance Rebalance the existing position with deposit.\n     * @param swapSlippage Slippage for the rebalance.\n     */\n    function deposit(\n        int24 tickDesired,\n        int24 tickSlippage,\n        uint256 amountX,\n        uint256 amountY,\n        uint256 desiredAmountX,\n        uint256 desiredAmountY,\n        bool isRebalance,\n        uint256 swapSlippage\n    ) public nonReentrant {\n        _transferTokens(_msgSender(), address(this), amountX, amountY);\n\n        if (swapSlippage > _MAX_SLIPPAGE) {\n            revert SlippageTooHigh();\n        }\n\n        _deposit(\n            _msgSender(),\n            tickDesired,\n            tickSlippage,\n            amountX,\n            amountY,\n            desiredAmountX,\n            desiredAmountY,\n            isRebalance,\n            swapSlippage\n        );\n    }\n\n    function _deposit(\n        address user,\n        int24 tickDesired,\n        int24 tickSlippage,\n        uint256 amountX,\n        uint256 amountY,\n        uint256 desiredAmountX,\n        uint256 desiredAmountY,\n        bool isRebalance,\n        uint256 swapSlippage\n    ) internal {\n        int24 tickLower;\n        int24 tickUpper;\n\n        uint256 tokenId = userTokenId[user];\n        if (tokenId > 0) {\n            uint128 liquidity;\n            (, , , , , tickLower, tickUpper, liquidity, , , , ) = positionManager.positions(tokenId);\n\n            if (isRebalance) {\n                // Withdraw Position For Rebalance\n                (uint256 amountXBefore, uint256 amountYBefore) = positionManagerRemove(tokenId, liquidity, address(this), 0, 0);\n                \n                if(getToken0() != tokenX) {\n                    (amountXBefore, amountYBefore) = (amountYBefore, amountXBefore);\n                }\n\n                burnUserPosition(user, tokenId);\n\n                (amountX, amountY) = (amountX + amountXBefore, amountY + amountYBefore);\n            }\n        }\n        (amountX, amountY) = _swapForEqualValues(amountX, amountY, swapSlippage);\n\n        if (userTokenId[user] == 0) {\n            (, int24 currenTick, , , , , ) = pool.slot0();\n            currenTick = convertToNearestTickSpacingMultiple(currenTick);\n            if (!(tickDesired + tickSlippage >= currenTick && currenTick + tickSlippage >= tickDesired)) {\n                revert SlippageTooHigh();\n            }\n            tickLower = currenTick - tickSpacing * deltaId;\n            tickUpper = currenTick + tickSpacing * deltaId;\n        }\n        _depositToUniswap(user, tickLower, tickUpper, amountX, amountY, desiredAmountX, desiredAmountY);\n\n        notifyVPrimeController(user);\n    }\n\n    function convertToNearestTickSpacingMultiple(int24 tick) internal view returns (int24) {\n        return (tick / tickSpacing) * tickSpacing;\n    }\n\n    function collect() external nonReentrant() {\n        uint256 tokenId = userTokenId[_msgSender()];\n        if (tokenId == 0) {\n            revert NoPosition();\n        }\n\n        positionManagerCollect(\n            tokenId,\n            _msgSender()\n        );\n    }\n\n    /**\n     * @dev Users can use withdraw function for withdrawing their share.\n     * @param share Amount to withdraw\n     */\n    function withdraw(uint256 share, uint256 amountXMin, uint256 amountYMin) external nonReentrant {\n        address msgSender = _msgSender();\n        uint256 tokenId = userTokenId[msgSender];\n        if (tokenId == 0) {\n            revert NoPositionToWithdraw();\n        }\n\n        (, , , , , , , uint128 liquidity, , , , ) = positionManager.positions(\n            tokenId\n        );\n\n        uint256 balance = balanceOf(msgSender);\n        if (balance < share + getLockedBalance(msgSender)) {\n            revert BalanceLocked();\n        }\n\n        (amountXMin, amountYMin) = tokenSequence ? (amountYMin, amountXMin) : (amountXMin, amountYMin);\n        positionManagerRemove(tokenId, uint128((liquidity * share) / balance), msgSender, amountXMin, amountYMin);\n\n        // Burn Position NFT\n        if (balance == share) {\n            positionManager.burn(tokenId);\n            delete userTokenId[msgSender];\n        }\n\n        _burn(msgSender, share);\n\n        notifyVPrimeController(msgSender);\n    }\n\n    /**\n     * @dev Users can use deposit function for depositing tokens to the specific bin.\n     * @param user The active id that user wants to add liquidity from\n     * @param percentForLocks sPrime amount % to lock\n     * @param lockPeriods Lock period to Lock for each amount\n     * @param amountX The amount of token X to deposit.\n     * @param amountY The amount of token Y to deposit.\n     * @param tickDesired The tick that user wants to add liquidity from\n     * @param tickSlippage Tick slippage from the current tick.\n     */\n    function mintForUserAndLock(\n        address user,\n        uint256[] calldata percentForLocks,\n        uint256[] calldata lockPeriods,\n        uint256 amountX,\n        uint256 amountY,\n        int24 tickDesired,\n        int24 tickSlippage\n    ) public onlyOperator nonReentrant {\n        address msgSender = _msgSender();\n        _transferTokens(msgSender, address(this), amountX, amountY);\n\n        if (percentForLocks.length != lockPeriods.length) {\n            revert LengthMismatch();\n        }\n\n        uint256 oldBalance = balanceOf(user);\n        _deposit(user, tickDesired, tickSlippage, amountX, amountY, 0, 0, true, _MAX_SLIPPAGE);\n        \n        if(balanceOf(user) > oldBalance) {\n            lockForUser(user, balanceOf(user) - oldBalance, percentForLocks, lockPeriods);\n        } else {\n            revert InsufficientBalanceToLock();\n        }\n\n        notifyVPrimeController(user);\n    }\n\n    function lockForUser(address user, uint256 balance, uint256[] calldata percentForLocks, uint256[] calldata lockPeriods) internal {\n        uint256 totalLock;\n        uint256 length = lockPeriods.length;\n        for (uint8 i; i != length; ++i) {\n            totalLock += percentForLocks[i];\n        }\n        if (totalLock != 100) {\n            revert TotalLockMismatch();\n        }\n        totalLock = 0;\n        for (uint8 i; i != length; ++i) {\n            if (lockPeriods[i] > MAX_LOCK_TIME) {\n                revert LockPeriodExceeded();\n            }\n            // Should minus from total balance to avoid the round issue\n            uint256 amount = i == length - 1\n                ? balance - totalLock\n                : (balance * percentForLocks[i]) / 100;\n            locks[user].push(\n                LockDetails({\n                    lockPeriod: lockPeriods[i],\n                    amount: amount,\n                    unlockTime: block.timestamp + lockPeriods[i]\n                })\n            );\n            totalLock += amount;\n        }\n    }\n\n    function positionManagerCollect(\n        uint256 tokenId,\n        address recipient\n    ) internal returns (uint256 amount0, uint256 amount1) {\n        return\n            positionManager.collect(\n                INonfungiblePositionManager.CollectParams({\n                    tokenId: tokenId,\n                    recipient: recipient,\n                    amount0Max: type(uint128).max,\n                    amount1Max: type(uint128).max\n                })\n            );\n    }\n\n    function positionManagerRemove(\n        uint256 tokenId,\n        uint128 liquidity,\n        address recipient,\n        uint256 amount0Min,\n        uint256 amount1Min\n    ) internal returns (uint256, uint256) {\n        positionManager.decreaseLiquidity(\n            INonfungiblePositionManager.DecreaseLiquidityParams({\n                tokenId: tokenId,\n                liquidity: liquidity,\n                amount0Min: amount0Min,\n                amount1Min: amount1Min,\n                deadline: block.timestamp\n            })\n        );\n\n        return positionManagerCollect(\n            tokenId,\n            recipient\n        );\n    }\n\n    function burnUserPosition(address user, uint256 tokenId) internal {\n        _burn(user, balanceOf(user));\n        positionManager.burn(tokenId);\n\n        delete userTokenId[user];\n    }\n\n    /**\n     * @dev Users can use deposit function for depositing tokens to the specific bin.\n     * @param tokenId Token ID from UniswapPositionManager\n     * @param tickDesired The tick that user wants to add liquidity from\n     * @param tickSlippage The tick slippage that are allowed to slip\n     * @param swapSlippage Slippage for the rebalance.\n     */\n    function migrateLiquidity(\n        uint256 tokenId,\n        int24 tickDesired,\n        int24 tickSlippage,\n        uint256 swapSlippage\n    ) public nonReentrant {\n        if(positionManager.ownerOf(tokenId) != _msgSender()) {\n            revert NoPosition();\n        }\n\n        (, , , , , , , uint128 liquidity , , , ,) = positionManager.positions(tokenId);\n\n        (uint256 amountX, uint256 amountY) = positionManagerRemove(tokenId, liquidity, address(this), 0, 0);\n\n        if(getToken0() != tokenX) {\n            (amountX, amountY) = (amountY, amountX);\n        }\n        positionManager.burn(tokenId);\n\n        if (swapSlippage > _MAX_SLIPPAGE) {\n            revert SlippageTooHigh();\n        }\n\n        _deposit(_msgSender(), tickDesired, tickSlippage, amountX, amountY, 0, 0, true, swapSlippage);\n    }\n\n    /**\n     * @dev Locks a specified amount of balance for a specified lock period.\n     * @param amount The amount of balance to be locked.\n     * @param lockPeriod The duration for which the balance will be locked.\n     */\n    function lockBalance(uint256 amount, uint256 lockPeriod) public nonReentrant {\n        address msgSender = _msgSender();\n        uint256 lockedBalance = getLockedBalance(msgSender);\n        if (balanceOf(msgSender) < amount + lockedBalance) {\n            revert InsufficientBalanceToLock();\n        }\n        if (lockPeriod > MAX_LOCK_TIME) {\n            revert LockPeriodExceeded();\n        }\n        locks[msgSender].push(\n            LockDetails({\n                lockPeriod: lockPeriod,\n                amount: amount,\n                unlockTime: block.timestamp + lockPeriod\n            })\n        );\n\n        notifyVPrimeController(msgSender);\n    }\n\n    /** Overrided Functions */\n\n    /**\n    * @dev The hook that happens before token transfer.\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param amount The amount to transfer.\n    */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if (from != address(0) && to != address(0)) {\n            uint256 lockedBalance = getLockedBalance(from);\n            uint256 fromBalance = balanceOf(from);\n            if (fromBalance < amount + lockedBalance) {\n                revert InsufficientBalance();\n            }\n        }\n    }\n\n    /**\n     * @dev The hook that happens after token transfer.\n     * @param from The address to transfer from.\n     * @param to The address to transfer to.\n     * @param amount The amount to transfer.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if (from != address(0) && to != address(0)) {\n            uint256 fromBalance = balanceOf(from);\n            if (userTokenId[to] != 0) {\n                revert ReceiverAlreadyHasPosition();\n            }\n\n            uint256 tokenId = userTokenId[from];\n\n            // Collect the fee before transfer\n            positionManagerCollect(\n                tokenId,\n                from\n            );\n\n            if (fromBalance == 0) {\n                userTokenId[to] = userTokenId[from];\n                delete userTokenId[from];\n            } else {\n                ( , , , , , int24 tickLower, int24 tickUpper, uint128 liquidity, , , ,) = positionManager.positions(tokenId);\n\n                (uint256 amountX, uint256 amountY) = positionManagerRemove(tokenId, uint128((liquidity * amount) / (fromBalance + amount)), address(this), 0, 0);\n                getToken0().forceApprove(address(positionManager), amountX);\n                getToken1().forceApprove(address(positionManager), amountY);\n                (\n                    uint256 newTokenId,\n                    ,\n                    uint256 amountXAdded,\n                    uint256 amountYAdded\n                ) = positionManager.mint(\n                        INonfungiblePositionManager.MintParams({\n                            token0: address(getToken0()),\n                            token1: address(getToken1()),\n                            fee: feeTier,\n                            tickLower: tickLower,\n                            tickUpper: tickUpper,\n                            amount0Desired: amountX,\n                            amount1Desired: amountY,\n                            amount0Min: 0,\n                            amount1Min: 0,\n                            recipient: address(this),\n                            deadline: block.timestamp\n                        })\n                    );\n                amountX -= amountXAdded;\n                amountY -= amountYAdded;\n\n                if(getToken0() != tokenX) { \n                    (amountXAdded, amountYAdded) = (amountYAdded, amountXAdded);\n                    (amountX, amountY) = (amountY, amountX);\n                }\n\n                uint256 total = _getTotalInTokenY(amountXAdded, amountYAdded);\n\n                _transferTokens(\n                    address(this),\n                    to,\n                    amountX - amountXAdded,\n                    amountY - amountYAdded\n                );\n\n                if (amount > total) {\n                    _burn(to, amount - total);\n                } else {\n                    _mint(to, total - amount);\n                }\n\n                userTokenId[to] = newTokenId;\n            }\n            notifyVPrimeController(from);\n            notifyVPrimeController(to);\n        }\n    }\n\n    function containsOracleCalldata() public pure returns (bool) {\n        // Checking if the calldata ends with the RedStone marker\n        bool hasValidRedstoneMarker;\n        assembly {\n            let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n            hasValidRedstoneMarker := eq(\n                REDSTONE_MARKER_MASK,\n                and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n            )\n        }\n        return hasValidRedstoneMarker;\n    }\n\n    function notifyVPrimeController(address account) internal {\n        if(address(vPrimeController) != address(0)){\n            if(containsOracleCalldata()) {\n                proxyCalldata(\n                    address(vPrimeController),\n                    abi.encodeWithSignature\n                    (\"updateVPrimeSnapshot(address)\", account),\n                    false\n                );\n            } else {\n                vPrimeController.setUserNeedsUpdate(account);\n            }\n        }\n    }\n\n\n    function decimals() public view virtual override returns (uint8) {\n        return tokenDecimals;\n    }\n\n    // CUSTOM ERROR MESSAGES\n    error PoolNotExisting();\n    error InsufficientBalance();\n    error ReceiverAlreadyHasPosition();\n    error NoPosition();\n    error SlippageTooHigh();\n    error NoPositionToWithdraw();\n    error StillInLockPeriod();\n    error BalanceLocked();\n    error UserAlreadyHasPosition();\n    error LengthMismatch();\n    error TotalLockMismatch();\n    error InsufficientBalanceToLock();\n    error LockPeriodExceeded();\n    error AccessDenied();\n    error ProxyCallFailed();\n}\n"
    },
    "contracts/token/sPrimeUniswapImpl.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f02dab5ae5dd02d0771bb7dedabb0ad6ac8802c;\npragma solidity ^0.8.27;\n\n// Importing necessary libraries and interfaces\nimport \"./sPrimeUniswap.sol\";\nimport \"../lib/uniswap-v3/PositionValue.sol\";\nimport \"../lib/uniswap-v3/UniswapV3IntegrationHelper.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n// SPrime contract declaration\ncontract sPrimeUniswapImpl\n{\n    using PositionValue for INonfungiblePositionManager;\n    address public sPrime;\n\n    constructor(address sPrimeUniswap_) {\n        sPrime = sPrimeUniswap_;\n    }\n\n    function getTokenIDByUser(address user) internal view returns (uint256) {\n        return sPrimeUniswap(sPrime).userTokenId(user);\n    }\n\n    function getV3Pool() internal view returns (IUniswapV3Pool) {\n        return IUniswapV3Pool(sPrimeUniswap(sPrime).pool());\n    }\n\n    function getPositionManager() internal view returns (INonfungiblePositionManager) {\n        return INonfungiblePositionManager(sPrimeUniswap(sPrime).positionManager());\n    }\n\n    function tickInRange(uint256 tokenId) public view returns (bool) {\n        IUniswapV3Pool pool = getV3Pool();\n        INonfungiblePositionManager positionManager = getPositionManager();\n\n        (, int24 tick, , , , , ) = pool.slot0();\n\n        (, , , , , int24 tickLower, int24 tickUpper, , , , , ) = positionManager\n            .positions(tokenId);\n        return tickLower <= tick && tick <= tickUpper;\n    }\n\n    /**\n     * @dev Returns the estimated USD value of the user position\n     * @param user User Address\n     * @param poolPrice Pool Price or oracle price for calculating proper token amount\n     * @return amountY Total Value in tokenY amount for the user's position.\n     */\n    function getUserValueInTokenY(\n        address user,\n        uint256 poolPrice\n    ) public view returns (uint256 amountY) {\n        uint256 tokenId = getTokenIDByUser(user);\n        IUniswapV3Pool pool = getV3Pool();\n        IERC20Metadata tokenX = IERC20Metadata(address(sPrimeUniswap(sPrime).getTokenX()));\n        IERC20Metadata tokenY = IERC20Metadata(address(sPrimeUniswap(sPrime).getTokenY()));\n        IERC20Metadata token0 = IERC20Metadata(pool.token0());\n        IERC20Metadata token1 = IERC20Metadata(pool.token1());\n        INonfungiblePositionManager positionManager = getPositionManager();\n\n        if(tokenId > 0) {\n            uint256 price = poolPrice;\n\n            if (token0 != tokenX) {\n                price = 10 ** (8 + token1.decimals()) / price;\n            } else {\n                price = FullMath.mulDiv(price, 10 ** token1.decimals(), 10 ** 8);\n            }\n            uint160 sqrtRatioX96 = uint160((UniswapV3IntegrationHelper.sqrt(price) * 2 ** 96) / 10 ** (token0.decimals() / 2));\n            uint256 amountX;\n            (amountX, amountY) = positionManager.total(\n                tokenId,\n                sqrtRatioX96\n            );\n\n            if(token0 != tokenX) {\n                (amountX, amountY) = (amountY, amountX);\n            }\n\n            uint8 tokenXDecimals = tokenX.decimals();\n            uint8 tokenYDecimals = tokenY.decimals();\n            if (tokenYDecimals >= tokenXDecimals + 8) {\n                amountY =\n                    amountY +\n                    amountX *\n                    poolPrice *\n                    10 ** (tokenYDecimals - tokenXDecimals - 8);\n            } else {\n                amountY =\n                    amountY +\n                    FullMath.mulDiv(\n                        amountX,\n                        poolPrice,\n                        10 ** (tokenXDecimals + 8 - tokenYDecimals)\n                    );\n            }\n        }\n\n        return amountY;\n    }\n}"
    },
    "contracts/token/vPrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 7791f4c6f965248c1000f6642d53e9701e04a22d;\npragma solidity ^0.8.27;\n\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"../interfaces/IBorrowersRegistry.sol\";\nimport \"../abstract/PendingOwnableUpgradeable.sol\";\nimport {vPrimeController} from \"./vPrimeController.sol\";\n\n\ncontract vPrime is PendingOwnableUpgradeable, ReentrancyGuardUpgradeable {\n    struct Checkpoint {\n        uint32 blockTimestamp;\n        uint256 balance;\n        int256 rate; // Tokens per second\n        uint256 balanceLimit;\n    }\n\n    IBorrowersRegistry public borrowersRegistry;\n    address public vPrimeControllerAddress;\n    mapping(address => Checkpoint[]) private _checkpoints; // _checkpoints[address(this)] serves as a total supply checkpoint\n    mapping(address => bool) public needsUpdate; // Account needs balance recalculating\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(IBorrowersRegistry _borrowersRegistry) external initializer {\n        __PendingOwnable_init();\n        __ReentrancyGuard_init();\n\n        borrowersRegistry = _borrowersRegistry;\n    }\n\n\n    /* ========== MODIFIERS ========== */\n    modifier onlyVPrimeController() virtual {\n        require(_msgSender() == vPrimeControllerAddress, \"Only vPrimeController can call this function\");\n        _;\n    }\n\n\n    /* ========== MUTATIVE EXTERNAL FUNCTIONS ========== */\n\n    function setUserNeedsUpdate(address user) external onlyVPrimeController {\n        needsUpdate[user] = true;\n        emit UserNeedsUpdateSet(user, msg.sender, block.timestamp);\n    }\n\n    function clearUserNeedsUpdate(address user) internal {\n        needsUpdate[user] = false;\n        emit UserNeedsUpdateCleared(user, msg.sender, block.timestamp);\n    }\n\n    /**\n    * @notice Sets the address of the vPrimeController contract.\n    * @dev Can only be called by the contract owner.\n    * @param _vPrimeControllerAddress The address of the vPrimeController contract.\n    */\n    function setVPrimeControllerAddress(address _vPrimeControllerAddress) external onlyOwner {\n        require(_vPrimeControllerAddress != address(0), \"vPrime: vPrimeController address cannot be 0\");\n        address oldVPrimeControllerAddress = vPrimeControllerAddress;\n\n        vPrimeControllerAddress = _vPrimeControllerAddress;\n\n        emit NewVPrimeControllerSet(oldVPrimeControllerAddress, _vPrimeControllerAddress, msg.sender, block.timestamp);\n    }\n\n    // Called by the vPrimeController to adjust the rate and balanceLimit of a user\n    function adjustRateAndCap(address user, int256 rate, uint256 newBalanceLimit) external onlyVPrimeController nonReentrant {\n        uint256 lastRecordedVotes = getVotes(user);\n        uint256 currentVotesBalance = balanceOf(user);\n        int256 votesDiff = SafeCast.toInt256(currentVotesBalance) - SafeCast.toInt256(lastRecordedVotes);\n\n        if (votesDiff > 0) {\n            increaseTotalSupply(uint256(votesDiff));\n            _writeCheckpoint(_checkpoints[user], _add, uint256(votesDiff), rate, newBalanceLimit);\n        } else if (votesDiff < 0) {\n            decreaseTotalSupply(uint256(- votesDiff));\n            _writeCheckpoint(_checkpoints[user], _subtract, uint256(- votesDiff), rate, newBalanceLimit);\n        } else {\n            _writeCheckpoint(_checkpoints[user], _add, 0, rate, newBalanceLimit);\n        }\n        clearUserNeedsUpdate(user);\n    }\n\n    // Called by the vPrimeController to adjust the rate, balanceLimit and overwrite the balance of a user\n    // Balance overwrite is used when the user's balance is changed by a different mechanism than the rate\n    // In our case that would be locking deposit/sPrime pairs (up to 3 years) for an instant vPrime unvesting\n    function adjustRateCapAndBalance(address user, int256 rate, uint256 newBalanceLimit, uint256 balance) external onlyVPrimeController nonReentrant {\n        uint256 lastRecordedVotes = getVotes(user);\n        int256 votesDiff = SafeCast.toInt256(balance) - SafeCast.toInt256(lastRecordedVotes);\n\n        if (votesDiff > 0) {\n            increaseTotalSupply(uint256(votesDiff));\n            _writeCheckpointOverwriteBalance(_checkpoints[user], balance, rate, newBalanceLimit);\n        } else if (votesDiff < 0) {\n            decreaseTotalSupply(uint256(- votesDiff));\n            _writeCheckpointOverwriteBalance(_checkpoints[user], balance, rate, newBalanceLimit);\n        } else {\n            _writeCheckpointOverwriteBalance(_checkpoints[user], lastRecordedVotes, rate, newBalanceLimit);\n        }\n        clearUserNeedsUpdate(user);\n    }\n\n    /* ========== VIEW EXTERNAL FUNCTIONS ========== */\n\n    // Override balanceOf to compute balance dynamically\n    function balanceOf(address account) public view returns (uint256) {\n        uint256 userCkpsLen = _checkpoints[account].length;\n        if (userCkpsLen == 0) {\n            return 0;\n        }\n        Checkpoint memory cp = _checkpoints[account][userCkpsLen - 1];\n\n        // If account was updated without recalculations, return the last recorded balance\n        if(needsUpdate[account]) {\n            return cp.balance;\n        }\n\n        uint256 elapsedTime = block.timestamp - cp.blockTimestamp;\n        uint256 newBalance;\n\n        if (cp.rate >= 0) {\n            uint256 balanceIncrease = uint256(cp.rate) * elapsedTime;\n            newBalance = cp.balance + balanceIncrease;\n            return (newBalance > cp.balanceLimit) ? cp.balanceLimit : newBalance;\n        } else {\n            // If rate is negative, convert to positive for calculation, then subtract\n            uint256 balanceDecrease = uint256(- cp.rate) * elapsedTime;\n            if (balanceDecrease > cp.balance) {\n                // Prevent underflow, setting balance to min cap if decrease exceeds current balance\n                return cp.balanceLimit;\n            } else {\n                newBalance = cp.balance - balanceDecrease;\n                return (newBalance < cp.balanceLimit) ? cp.balanceLimit : newBalance;\n            }\n        }\n    }\n\n\n    /**\n     * @dev Clock used for flagging checkpoints. Can be overridden to implement timestamp based checkpoints (and voting).\n     */\n    // Overrides IERC6372 functions to make the token & governor timestamp-based\n    function clock() public view returns (uint48) {\n        return uint48(block.timestamp);\n    }\n    /**\n     * @dev Description of the clockx\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function CLOCK_MODE() public pure returns (string memory) {\n        return \"mode=timestamp\";\n    }\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCast.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Gets the last recorded votes balance for `account`\n     */\n    function getVotes(address account) public view virtual returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        unchecked {\n            return pos == 0 ? 0 : _checkpoints[account][pos - 1].balance;\n        }\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `timestamp`.\n     *\n     * Requirements:\n     *\n     * - `timestamp` must be in the past\n     */\n    function getPastVotes(address account, uint256 timestamp) public view virtual returns (uint256) {\n        require(timestamp < clock(), \"Future lookup\");\n        return _checkpointsLookup(_checkpoints[account], timestamp);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `timestamp`. Note, this value is the sum of all balances.\n     * It is NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `timestamp` must be in the past\n     */\n    function getPastTotalSupply(uint256 timestamp) public view virtual returns (uint256) {\n        require(timestamp < clock(), \"Future lookup\");\n        return _checkpointsLookup(_checkpoints[address(this)], timestamp);\n    }\n\n    function getLastRecordedTotalSupply() public view virtual returns (uint256) {\n        uint256 pos = _checkpoints[address(this)].length;\n        unchecked {\n            return pos == 0 ? 0 : _checkpoints[address(this)][pos - 1].balance;\n        }\n    }\n\n    /* ========== INTERNAL MUTATIVE FUNCTIONS ========== */\n\n    function increaseTotalSupply(uint256 amount) internal {\n        require(getLastRecordedTotalSupply() + amount <= _maxSupply(), \"Total supply risks overflowing votes\");\n        _writeCheckpoint(_checkpoints[address(this)], _add, amount, 0, 0);\n    }\n\n    function decreaseTotalSupply(uint256 amount) internal {\n        _writeCheckpoint(_checkpoints[address(this)], _subtract, amount, 0, 0);\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta,\n        int256 rate,\n        uint256 balanceLimit\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0, 0, 0) : ckpts[pos - 1];\n\n        oldWeight = oldCkpt.balance;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && oldCkpt.blockTimestamp == clock()) {\n            oldCkpt.balance = newWeight;\n            oldCkpt.rate = rate;\n            oldCkpt.balanceLimit = balanceLimit;\n        } else {\n            ckpts.push(Checkpoint({\n                blockTimestamp: SafeCast.toUint32(clock()),\n                balance: newWeight,\n                rate: rate,\n                balanceLimit: balanceLimit\n            }));\n        }\n    }\n\n    function _writeCheckpointOverwriteBalance(\n        Checkpoint[] storage ckpts,\n        uint256 balance,\n        int256 rate,\n        uint256 balanceLimit\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        Checkpoint memory oldCkpt = pos == 0 ? Checkpoint(0, 0, 0, 0) : ckpts[pos - 1];\n\n        if (pos > 0 && oldCkpt.blockTimestamp == clock()) {\n            oldCkpt.balance = balance;\n            oldCkpt.rate = rate;\n            oldCkpt.balanceLimit = balanceLimit;\n        } else {\n            ckpts.push(Checkpoint({\n                blockTimestamp: SafeCast.toUint32(clock()),\n                balance: balance,\n                rate: rate,\n                balanceLimit: balanceLimit\n            }));\n        }\n    }\n\n    /* ========== INTERNAL VIEW FUNCTIONS ========== */\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 timestamp) private view returns (uint256) {\n        // We run a binary search to look for the last (most recent) checkpoint taken before (or at) `timestamp`.\n        //\n        // Initially we check if the block is recent to narrow the search range.\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `timestamp`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `timestamp`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `timestamp`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `timestamp`, but it works out\n        // the same.\n        uint256 length = ckpts.length;\n\n        uint256 low = 0;\n        uint256 high = length;\n\n        if (length > 5) {\n            uint256 mid = length - Math.sqrt(length);\n            if (_unsafeAccess(ckpts, mid).blockTimestamp > timestamp) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        while (low < high) {\n            uint256 mid = Math.average(low, high);\n            if (_unsafeAccess(ckpts, mid).blockTimestamp > timestamp) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        unchecked {\n            return high == 0 ? 0 : _unsafeAccess(ckpts, high - 1).balance;\n        }\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Access an element of the array without performing bounds check. The position is assumed to be within bounds.\n     */\n    function _unsafeAccess(Checkpoint[] storage ckpts, uint256 pos) private pure returns (Checkpoint storage result) {\n        assembly {\n            mstore(0, ckpts.slot)\n            result.slot := add(keccak256(0, 0x20), pos)\n        }\n    }\n\n    // event for setting new vPrimeContoller with old address, new address, msg.sender and timestamp\n    event NewVPrimeControllerSet(\n        address indexed oldVPrimeControllerAddress,\n        address indexed newVPrimeControllerAddress,\n        address indexed sender,\n        uint256 timestamp);\n\n    // event for setting user needs update with user address, msg.sender and timestamp\n    event UserNeedsUpdateSet(\n        address indexed user,\n        address indexed sender,\n        uint256 timestamp);\n\n    // event for clearing user needs update with user address, msg.sender and timestamp\n    event UserNeedsUpdateCleared(\n        address indexed user,\n        address indexed sender,\n        uint256 timestamp);\n}\n"
    },
    "contracts/token/vPrimeController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity ^0.8.27;\n\nimport \"@redstone-finance/evm-connector/contracts/core/RedstoneConsumerNumericBase.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\nimport \"../abstract/PendingOwnableUpgradeable.sol\";\nimport \"../interfaces/ITokenManager.sol\";\nimport \"../interfaces/IBorrowersRegistry.sol\";\nimport \"../interfaces/facets/IOwnershipFacet.sol\";\nimport \"../interfaces/IPool.sol\";\nimport \"../interfaces/ISPrime.sol\";\nimport \"./vPrime.sol\";\nimport \"../lib/uniswap-v3/FullMath.sol\";\n\nabstract contract vPrimeController is PendingOwnableUpgradeable, RedstoneConsumerNumericBase {\n    ISPrime[] public whitelistedSPrimeContracts;\n    ITokenManager public tokenManager;\n    vPrime public vPrimeContract;\n    IBorrowersRegistry public borrowersRegistry;\n    bool public useOraclePrimeFeed;\n    uint256 public constant BORROWER_YEARLY_V_PRIME_RATE = 1;\n    uint256 public constant DEPOSITOR_YEARLY_V_PRIME_RATE = 5;\n    uint256 public constant MAX_V_PRIME_VESTING_YEARS = 3;\n    uint256 public constant V_PRIME_DETERIORATION_DAYS = 14;\n    uint256 public constant V_PRIME_PAIR_RATIO = 10;\n    uint256 public constant RS_PRICE_PRECISION_1e18_COMPLEMENT = 1e10;\n\n    struct VPrimeCalculationsStruct {\n        int256 vPrimeRate;\n        uint256 vPrimeBalanceLimit;\n        uint256 vPrimeBalanceAlreadyVested;\n        uint256 userSPrimeDollarValueFullyVested;\n        uint256 userSPrimeDollarValueNonVested;\n        uint256 userDepositFullyVestedDollarValue;\n        uint256 userDepositNonVestedDollarValue;\n        uint256 primeAccountBorrowedDollarValue;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n\n    /* ========== INITIALIZER ========== */\n\n    function initialize(ISPrime[] memory _whitelistedSPrimeContracts, ITokenManager _tokenManager, vPrime _vPrime, bool _useOraclePrimeFeed) external initializer {\n        whitelistedSPrimeContracts = _whitelistedSPrimeContracts;\n        tokenManager = _tokenManager;\n        vPrimeContract = _vPrime;\n        useOraclePrimeFeed = _useOraclePrimeFeed;\n        __PendingOwnable_init();\n    }\n\n\n    /* ========== MUTATIVE EXTERNAL FUNCTIONS ========== */\n\n    // Update vPrime snapshot for `userAddress`\n    function updateVPrimeSnapshot(address userAddress) public {\n        (int256 vPrimeRate, uint256 vPrimeBalanceLimit, uint256 alreadyVestedVPrimeBalance) = getUserVPrimeRateAndMaxCap(userAddress);\n\n        // alreadyVestedVPrimeBalance > 0 mean that the already vested vPrime is higher than the current balance\n        if(alreadyVestedVPrimeBalance > 0){\n            vPrimeContract.adjustRateCapAndBalance(userAddress, vPrimeRate, vPrimeBalanceLimit, alreadyVestedVPrimeBalance);\n        } else {\n            vPrimeContract.adjustRateAndCap(userAddress, vPrimeRate, vPrimeBalanceLimit);\n        }\n    }\n\n    function setUserNeedsUpdate(address userAddress) public onlyPoolOrSPrime {\n        vPrimeContract.setUserNeedsUpdate(userAddress);\n    }\n\n\n    function updateVPrimeSnapshotsForAccounts(address[] memory accounts) public {\n        for (uint i = 0; i < accounts.length; i++) {\n            updateVPrimeSnapshot(accounts[i]);\n        }\n    }\n\n\n    /* ========== SETTERS ========== */\n\n    function getWhitelistedPools() public view returns (IPool[] memory) {\n        bytes32[] memory poolsTokenSymbols = tokenManager.getAllPoolAssets();\n        IPool[] memory whitelistedPools = new IPool[](poolsTokenSymbols.length);\n        for (uint i = 0; i < poolsTokenSymbols.length; i++) {\n            whitelistedPools[i] = IPool(tokenManager.getPoolAddress(poolsTokenSymbols[i]));\n        }\n        return whitelistedPools;\n    }\n\n    modifier onlyPoolOrSPrime() {\n        IPool[] memory whitelistedPools = getWhitelistedPools();\n        bool isPoolOrSPrime = false;\n        for (uint i = 0; i < whitelistedPools.length; i++) {\n            if (address(whitelistedPools[i]) == msg.sender) {\n                isPoolOrSPrime = true;\n                break;\n            }\n        }\n        for(uint i = 0; i < whitelistedSPrimeContracts.length; i++){\n            if (address(whitelistedSPrimeContracts[i]) == msg.sender) {\n                isPoolOrSPrime = true;\n                break;\n            }\n        }\n        require(isPoolOrSPrime, \"Only Pool or sPrime can call this function\");\n        _;\n    }\n\n    /**\n    * @notice Updates the list of whitelisted sPrime contracts.\n    * @dev Can only be called by the contract owner.\n    * @param newWhitelistedSPrimeContracts An array of addresses representing the new list of whitelisted sPrime contracts.\n    */\n    function updateWhitelistedSPrimeContracts(ISPrime[] memory newWhitelistedSPrimeContracts) external onlyOwner {\n        whitelistedSPrimeContracts = newWhitelistedSPrimeContracts;\n        emit WhitelistedSPrimeContractsUpdated(newWhitelistedSPrimeContracts, msg.sender, block.timestamp);\n    }\n\n    /**\n    * @notice Updates the token manager contract.\n    * @dev Can only be called by the contract owner.\n    * @param newTokenManager The address of the new token manager contract.\n    */\n    function updateTokenManager(ITokenManager newTokenManager) external onlyOwner {\n        tokenManager = newTokenManager;\n        emit TokenManagerUpdated(newTokenManager, msg.sender, block.timestamp);\n    }\n\n    // only owner setter for useOraclePriceFeed\n    function setUseOraclePrimeFeed(bool _useOraclePrimeFeed) external onlyOwner {\n        useOraclePrimeFeed = _useOraclePrimeFeed;\n        emit UseOraclePrimeFeedUpdated(_useOraclePrimeFeed, msg.sender, block.timestamp);\n    }\n\n    /**\n    * @notice Updates the borrowers registry contract.\n    * @dev Can only be called by the contract owner.\n    * @param newBorrowersRegistry The address of the new borrowers registry contract.\n    */\n    function updateBorrowersRegistry(IBorrowersRegistry newBorrowersRegistry) external onlyOwner {\n        borrowersRegistry = newBorrowersRegistry;\n    }\n\n\n\n    /* ========== VIEW EXTERNAL FUNCTIONS ========== */\n\n    function getPoolsPrices(IPool[] memory whitelistedPools) internal view returns (uint256[] memory) {\n        bytes32[] memory poolsTokenSymbols = new bytes32[](whitelistedPools.length);\n        for (uint i = 0; i < whitelistedPools.length; i++) {\n            poolsTokenSymbols[i] = tokenManager.tokenAddressToSymbol(whitelistedPools[i].tokenAddress());\n        }\n        return getOracleNumericValuesFromTxMsg(poolsTokenSymbols);\n    }\n\n    function getUserDepositDollarValueAcrossWhiteListedPoolsVestedAndNonVested(address userAddress) public view returns (uint256 fullyVestedDollarValue, uint256 nonVestedDollarValue) {\n        fullyVestedDollarValue = 0;\n        nonVestedDollarValue = 0;\n        IPool[] memory whitelistedPools = getWhitelistedPools();\n        uint256[] memory prices = getPoolsPrices(whitelistedPools);\n\n        for (uint i = 0; i < whitelistedPools.length; i++) {\n            uint256 fullyVestedBalance = whitelistedPools[i].getFullyVestedLockedBalance(userAddress);\n            uint256 nonVestedBalance = IERC20(whitelistedPools[i]).balanceOf(userAddress) - fullyVestedBalance;\n\n            uint256 _denominator = 10 ** whitelistedPools[i].decimals();\n            fullyVestedDollarValue += FullMath.mulDiv(fullyVestedBalance, prices[i] * RS_PRICE_PRECISION_1e18_COMPLEMENT, _denominator);\n            nonVestedDollarValue += FullMath.mulDiv(nonVestedBalance, prices[i] * RS_PRICE_PRECISION_1e18_COMPLEMENT, _denominator);\n        }\n        return (fullyVestedDollarValue, nonVestedDollarValue);\n    }\n\n    function getPrimeAccountBorrowedDollarValueAcrossWhitelistedPools(address userAddress) public view returns (uint256) {\n        uint256 totalDollarValue = 0;\n\n        address primeAccountAddress = borrowersRegistry.getLoanForOwner(userAddress);\n        if(primeAccountAddress != address(0)){\n            IPool[] memory whitelistedPools = getWhitelistedPools();\n            bytes32[] memory poolsTokenSymbols = new bytes32[](whitelistedPools.length);\n            for (uint i = 0; i < whitelistedPools.length; i++) {\n                poolsTokenSymbols[i] = tokenManager.tokenAddressToSymbol(whitelistedPools[i].tokenAddress());\n            }\n            uint256[] memory prices = getOracleNumericValuesFromTxMsg(poolsTokenSymbols);\n\n            for (uint i = 0; i < whitelistedPools.length; i++) {\n                uint256 poolBorrowedAmount = whitelistedPools[i].getBorrowed(primeAccountAddress);\n                uint256 poolDollarValue = FullMath.mulDiv(poolBorrowedAmount, prices[i] * RS_PRICE_PRECISION_1e18_COMPLEMENT, 10 ** whitelistedPools[i].decimals());\n                totalDollarValue += poolDollarValue;\n            }\n        }\n\n        return totalDollarValue;\n    }\n\n    function getPrimeTokenPoolPrice(ISPrime sPrimeContract, uint256 tokenYPrice) public view returns (uint256) {\n        if(useOraclePrimeFeed){\n            bytes32 primeSymbol = \"PRIME\";\n            uint256 primePrice = getOracleNumericValueFromTxMsg(primeSymbol);\n            return primePrice * 1e8 / tokenYPrice; // both tokenYPrice and primePrice have 8 decimals\n        } else {\n            uint256 poolPrice = sPrimeContract.getPoolPrice(); // returns price with 8 decimals\n            if(poolPrice * tokenYPrice / 1e8 > 13125 * 1e5){ // 13.125 with 8 decimals which comes from 10xinitialPrice MAX PRICE CAP before oracle feed will be ready\n                poolPrice = 13125 * 1e13 / tokenYPrice; // 13125 * 1e5 * 1e8 / tokenYPrice\n            }\n            return poolPrice;\n        }\n    }\n\n    function getUserSPrimeDollarValueVestedAndNonVested(address userAddress) public view returns (uint256 fullyVestedDollarValue, uint256 nonVestedDollarValue) {\n        fullyVestedDollarValue = 0;\n        nonVestedDollarValue = 0;\n        for (uint i = 0; i < whitelistedSPrimeContracts.length; i++) {\n            bytes32 sPrimeTokenYSymbol = tokenManager.tokenAddressToSymbol(address(whitelistedSPrimeContracts[i].getTokenY()));\n            uint256 sPrimeTokenYDecimals = IERC20Metadata(address(whitelistedSPrimeContracts[i].getTokenY())).decimals();\n            uint256 sPrimeTokenYPrice = getOracleNumericValueFromTxMsg(sPrimeTokenYSymbol);\n            uint256 poolPrice = getPrimeTokenPoolPrice(whitelistedSPrimeContracts[i], sPrimeTokenYPrice);\n            uint256 sPrimeBalance = IERC20Metadata(address(whitelistedSPrimeContracts[i])).balanceOf(userAddress);\n            uint256 fullyVestedBalance = whitelistedSPrimeContracts[i].getFullyVestedLockedBalance(userAddress);\n            uint256 nonVestedBalance = sPrimeBalance - fullyVestedBalance;\n            uint256 userSPrimeValueInTokenY = whitelistedSPrimeContracts[i].getUserValueInTokenY(userAddress, poolPrice);\n            if(sPrimeBalance > 0) {\n                uint256 _denominator = sPrimeBalance * 10 ** sPrimeTokenYDecimals;\n                fullyVestedDollarValue += FullMath.mulDiv(userSPrimeValueInTokenY, sPrimeTokenYPrice * RS_PRICE_PRECISION_1e18_COMPLEMENT * fullyVestedBalance, _denominator);\n                nonVestedDollarValue += FullMath.mulDiv(userSPrimeValueInTokenY, sPrimeTokenYPrice * RS_PRICE_PRECISION_1e18_COMPLEMENT * nonVestedBalance, _denominator);\n            }\n        }\n        return (fullyVestedDollarValue, nonVestedDollarValue);\n    }\n\n    /*\n    * For every $10 deposited and $1 $sPRIME owned, your balance increases with 5 $vPRIME per year.\n    * For every $10 borrowed and $1 $sPRIME owned, your balance increases with 1 $vPRIME per year.\n    * Only full ${V_PRIME_PAIR_RATIO}-1 pairs can produce $vPRIME.\n    */\n    function getUserVPrimeRateAndMaxCap(address userAddress) public view returns (int256, uint256, uint256){\n        VPrimeCalculationsStruct memory vPrimeCalculations = VPrimeCalculationsStruct({\n            vPrimeRate: 0,\n            vPrimeBalanceLimit: 0,\n            vPrimeBalanceAlreadyVested: 0,\n            userSPrimeDollarValueFullyVested: 0,\n            userSPrimeDollarValueNonVested: 0,\n            userDepositFullyVestedDollarValue: 0,\n            userDepositNonVestedDollarValue: 0,\n            primeAccountBorrowedDollarValue: 0\n        });\n\n        {\n            (uint256 _userSPrimeDollarValueFullyVested, uint256 _userSPrimeDollarValueNonVested) = getUserSPrimeDollarValueVestedAndNonVested(userAddress);\n            (uint256 _userDepositFullyVestedDollarValue, uint256 _userDepositNonVestedDollarValue) = getUserDepositDollarValueAcrossWhiteListedPoolsVestedAndNonVested(userAddress);\n            uint256 _primeAccountBorrowedDollarValue = getPrimeAccountBorrowedDollarValueAcrossWhitelistedPools(userAddress);\n            vPrimeCalculations.userSPrimeDollarValueFullyVested = _userSPrimeDollarValueFullyVested;\n            vPrimeCalculations.userSPrimeDollarValueNonVested = _userSPrimeDollarValueNonVested;\n            vPrimeCalculations.userDepositFullyVestedDollarValue = _userDepositFullyVestedDollarValue;\n            vPrimeCalculations.userDepositNonVestedDollarValue = _userDepositNonVestedDollarValue;\n            vPrimeCalculations.primeAccountBorrowedDollarValue = _primeAccountBorrowedDollarValue;\n        }\n\n\n        // How many pairs can be created based on the sPrime\n        uint256 maxSPrimePairsCount = (vPrimeCalculations.userSPrimeDollarValueFullyVested + vPrimeCalculations.userSPrimeDollarValueNonVested) / 1e18;\n        // How many pairs can be created based on the deposits\n        uint256 maxDepositPairsCount = ((vPrimeCalculations.userDepositFullyVestedDollarValue + vPrimeCalculations.userDepositNonVestedDollarValue) / V_PRIME_PAIR_RATIO) / 1e18;\n        // How many pairs can be created based on the borrowings\n        uint256 maxBorrowerPairsCount = vPrimeCalculations.primeAccountBorrowedDollarValue / V_PRIME_PAIR_RATIO / 1e18;\n\n        // How many sPrime-depositor pairs can be created\n        uint256 maxSPrimeDepositorPairsCount = Math.min(maxSPrimePairsCount, maxDepositPairsCount);\n        // How many sPrime-borrower pairs can be created taken into account sPrime used by sPrime-depositor pairs\n        uint256 maxSPrimeBorrowerPairsCount = Math.min(maxSPrimePairsCount - maxSPrimeDepositorPairsCount, maxBorrowerPairsCount);\n\n        // Increase vPrimeCalculations.vPrimeBalanceLimit and vPrimeCalculations.vPrimeBalanceAlreadyVested based on the sPrime-depositor pairs\n        if(maxSPrimeDepositorPairsCount > 0){\n            uint256 balanceLimitIncrease = maxSPrimeDepositorPairsCount * DEPOSITOR_YEARLY_V_PRIME_RATE * MAX_V_PRIME_VESTING_YEARS * 1e18;\n            vPrimeCalculations.vPrimeBalanceLimit += balanceLimitIncrease;\n\n            uint256 depositVestedPairsCount = Math.min(vPrimeCalculations.userDepositFullyVestedDollarValue / V_PRIME_PAIR_RATIO, vPrimeCalculations.userSPrimeDollarValueFullyVested) / 1e18;\n            if(depositVestedPairsCount > 0){\n                vPrimeCalculations.vPrimeBalanceAlreadyVested += balanceLimitIncrease * depositVestedPairsCount / maxSPrimeDepositorPairsCount;\n            }\n        }\n\n        // Increase vPrimeCalculations.vPrimeBalanceLimit based on the sPrime-borrower pairs\n        if(maxSPrimeBorrowerPairsCount > 0){\n            vPrimeCalculations.vPrimeBalanceLimit += maxSPrimeBorrowerPairsCount * BORROWER_YEARLY_V_PRIME_RATE * MAX_V_PRIME_VESTING_YEARS * 1e18;\n        }\n\n        // Check current vPrime balance\n        uint256 currentVPrimeBalance = vPrimeContract.balanceOf(userAddress);\n\n        // If already vested vPrime balance is higher than the current balance, then the current balance should be replaced with the already vested balance\n        bool balanceShouldBeReplaced = false;\n        if(currentVPrimeBalance < vPrimeCalculations.vPrimeBalanceAlreadyVested){\n            currentVPrimeBalance = vPrimeCalculations.vPrimeBalanceAlreadyVested;\n            balanceShouldBeReplaced = true;\n        }\n\n        int256 vPrimeBalanceDelta = int256(vPrimeCalculations.vPrimeBalanceLimit) - int256(currentVPrimeBalance);\n        if(vPrimeBalanceDelta < 0){\n            vPrimeCalculations.vPrimeRate = vPrimeBalanceDelta / int256(V_PRIME_DETERIORATION_DAYS) / 1 days;\n        } else {\n            vPrimeCalculations.vPrimeRate = vPrimeBalanceDelta / int256(MAX_V_PRIME_VESTING_YEARS) / 365 days;\n        }\n\n        if(balanceShouldBeReplaced){\n            return (vPrimeCalculations.vPrimeRate, vPrimeCalculations.vPrimeBalanceLimit, vPrimeCalculations.vPrimeBalanceAlreadyVested);\n        } else {\n            return (vPrimeCalculations.vPrimeRate, vPrimeCalculations.vPrimeBalanceLimit, 0);\n        }\n    }\n\n\n    // EVENTS\n    event WhitelistedSPrimeContractsUpdated(ISPrime[] newWhitelistedSPrimeContracts, address userAddress, uint256 timestamp);\n    event TokenManagerUpdated(ITokenManager newTokenManager, address userAddress, uint256 timestamp);\n    event UseOraclePrimeFeedUpdated(bool _useOraclePrimeFeed, address userAddress, uint256 timestamp);\n}\n"
    },
    "contracts/token/vPrimeControllerArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: c01f75e2bf34101db273d19406f08014faf1e524;\npragma solidity 0.8.27;\n\nimport \"./vPrimeController.sol\";\n\ncontract vPrimeControllerArbitrum is vPrimeController {\n    function getDataServiceId() public view virtual override returns (string memory) {\n    return \"redstone-arbitrum-prod\";\n  }\n\n  function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n    return 3;\n  }\n\n  function getAuthorisedSignerIndex(\n    address signerAddress\n  ) public view virtual override returns (uint8) {\n    if (signerAddress == 0x345Efd26098e173F811e3B9Af1B0e0a11872B38b) {\n      return 0;\n    } else if (signerAddress == 0xbD0c5ccd85D5831B10E3e49527B8Cd67e2EFAf39) {\n      return 1;\n    } else if (signerAddress == 0x2F3E8EC88C01593d10ca9461c807660fF2D8DB28) {\n      return 2;\n    } else if (signerAddress == 0xb7f154bB5491565D215F4EB1c3fe3e84960627aF) {\n      return 3;\n    } else if (signerAddress == 0xE6b0De8F4B31F137d3c59b5a0A71e66e7D504Ef9) {\n      return 4;\n    } else {\n      revert SignerNotAuthorised(signerAddress);\n    }\n  }\n}\n"
    },
    "contracts/token/vPrimeControllerAvalanche.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 7791f4c6f965248c1000f6642d53e9701e04a22d;\npragma solidity 0.8.27;\n\nimport \"./vPrimeController.sol\";\n\ncontract vPrimeControllerAvalanche is vPrimeController {\n    function getDataServiceId() public view virtual override returns (string memory) {\n        return \"redstone-avalanche-prod\";\n    }\n\n    function getUniqueSignersThreshold() public view virtual override returns (uint8) {\n        return 3;\n    }\n\n    function getAuthorisedSignerIndex(\n        address signerAddress\n    ) public view virtual override returns (uint8) {\n        if (signerAddress == 0x1eA62d73EdF8AC05DfceA1A34b9796E937a29EfF) {\n            return 0;\n        } else if (signerAddress == 0x2c59617248994D12816EE1Fa77CE0a64eEB456BF) {\n            return 1;\n        } else if (signerAddress == 0x12470f7aBA85c8b81D63137DD5925D6EE114952b) {\n            return 2;\n        } else if (signerAddress == 0x109B4a318A4F5ddcbCA6349B45f881B4137deaFB) {\n            return 3;\n        } else if (signerAddress == 0x83cbA8c619fb629b81A65C2e67fE15cf3E3C9747) {\n            return 4;\n        } else {\n            revert SignerNotAuthorised(signerAddress);\n        }\n    }\n}\n"
    },
    "contracts/TokenList.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity >=0.7.0 <0.9.0;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\n\ncontract TokenListOwnableUpgreadable is OwnableUpgradeable {\n    mapping(address => bool) isTokenWhitelisted;\n    mapping(address => uint256) tokenPositionInList;\n    address[] whitelistedTokensList;\n\n    function __TokenList_init(address[] memory _whitelistedTokens) internal onlyInitializing {\n        for (uint256 i = 0; i < _whitelistedTokens.length; i++) {\n            require(_whitelistToken(_whitelistedTokens[i], false), \"Whitelisting token failed\");\n        }\n\n        __Ownable_init();\n    }\n\n    // PUBLIC MUTATIVE FUNCTIONS\n\n    function whitelistTokens(address[] memory tokensToWhitelist) public onlyOwner {\n        for (uint256 i = 0; i < tokensToWhitelist.length; i++) {\n            require(_whitelistToken(tokensToWhitelist[i], true), \"Whitelisting token failed\");\n        }\n    }\n\n    function delistTokens(address[] memory tokensToDelist) public onlyOwner {\n        for (uint256 i = 0; i < tokensToDelist.length; i++) {\n            require(_delistToken(tokensToDelist[i], true), \"Delisting token failed\");\n        }\n    }\n\n    // PUBLIC VIEW FUNCTIONS\n\n    function getAllWhitelistedTokens() public view returns (address[] memory) {\n        return whitelistedTokensList;\n    }\n\n    // Already auto-generated because of the public visibility modifier\n    // function isTokenWhitelisted(address token) public view returns (bool) {\n    //     return isTokenWhitelisted[token];\n    // }\n\n    // INTERNAL MUTATIVE FUNCTIONS\n\n    function _whitelistToken(address token, bool revertOnDuplicates) internal returns (bool){\n        require(token != address(0), \"Cannot whitelist a zero address\");\n\n        if (!isTokenWhitelisted[token]) {\n            whitelistedTokensList.push(token);\n            tokenPositionInList[token] = whitelistedTokensList.length - 1;\n            isTokenWhitelisted[token] = true;\n            emit TokenWhitelisted(msg.sender, token, block.timestamp);\n            return true;\n\n        } else if (revertOnDuplicates) {\n            revert(\"Token already whitelisted\");\n        }\n        return false;\n    }\n\n    function _delistToken(address token, bool revertOnNonListedTokens) internal returns (bool){\n        if (isTokenWhitelisted[token]) {\n            _removeTokenFromList(token);\n            isTokenWhitelisted[token] = false;\n            emit TokenDelisted(msg.sender, token, block.timestamp);\n            return true;\n\n        } else if (revertOnNonListedTokens) {\n            revert(\"Token was not whitelisted before\");\n        }\n        return false;\n    }\n\n    // INTERNAL HELPER MUTATIVE FUNCTIONS\n\n    function _removeTokenFromList(address tokenToRemove) internal {\n        // Move last address token to the `tokenToRemoveIndex` position (index of an asset that is being removed) in the address[] whitelistedTokensList\n        // and update map(address=>uint256) tokenPostitionInList if the token is not already the last element\n        uint256 tokenToRemoveIndex = tokenPositionInList[tokenToRemove];\n        require(tokenToRemoveIndex < whitelistedTokensList.length, \"Index out of range\");\n        if (tokenToRemoveIndex == 0 && whitelistedTokensList[0] != tokenToRemove) {\n            revert(\"Token does not exist\");\n        }\n        if (tokenToRemoveIndex != (whitelistedTokensList.length - 1)) {\n            address currentLastToken = whitelistedTokensList[whitelistedTokensList.length - 1];\n            tokenPositionInList[currentLastToken] = tokenToRemoveIndex;\n            whitelistedTokensList[tokenToRemoveIndex] = currentLastToken;\n        }\n        // Remove last element - that is either the token that is being removed (if was already at the end)\n        // or some other asset that at this point was already copied to the `index` positon\n        whitelistedTokensList.pop();\n        tokenPositionInList[tokenToRemove] = 0;\n    }\n\n    // EVENTS\n    /**\n    * @dev emitted after whitelisting a token\n    * @param user performing the transaction\n    * @param token address of whitelisted token\n    * @param timestamp of change\n    **/\n    event TokenWhitelisted(address indexed user, address token, uint256 timestamp);\n\n    /**\n    * @dev emitted after delisting a token\n    * @param user performing the transaction\n    * @param token address of delisted token\n    * @param timestamp of change\n    **/\n    event TokenDelisted(address indexed user, address token, uint256 timestamp);\n}"
    },
    "contracts/TokenManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: cb1fa840386b7a38a8711e20dbc566c5b3a700d7;\npragma solidity 0.8.27;\n\nimport \"./lib/Bytes32EnumerableMap.sol\";\nimport \"./interfaces/IBorrowersRegistry.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"./lib/arbitrum/DeploymentConstants.sol\";\n\ncontract TokenManager is OwnableUpgradeable {\n    /**\n     * For adding supported assets\n     **/\n    struct Asset {\n        bytes32 asset;\n        address assetAddress;\n        uint256 debtCoverage;\n    }\n\n    /**\n     * For adding supported lending pools\n     **/\n    struct poolAsset {\n        bytes32 asset;\n        address poolAddress;\n    }\n\n    struct Exposure {\n        uint256 current;\n        uint256 max; // Setting max to 0 means no exposure limitations.\n    }\n\n    using EnumerableMap for EnumerableMap.Bytes32ToAddressMap;\n\n    uint256 private constant _NOT_SUPPORTED = 0;\n    uint256 private constant _INACTIVE = 1;\n    uint256 private constant _ACTIVE = 2;\n\n    // Stores an asset's bytes32 symbol representation to pool's address mapping\n    EnumerableMap.Bytes32ToAddressMap private assetToPoolAddress;\n    // Stores an asset's bytes32 symbol representation to asset's address mapping\n    EnumerableMap.Bytes32ToAddressMap private assetToTokenAddress;\n    mapping(address => bytes32) public tokenAddressToSymbol;\n    mapping(address => uint256) private tokenPositionInList;\n    // used for defining different leverage ratios for tokens\n    mapping(address => uint256) public debtCoverage;\n    address[] public supportedTokensList;\n\n    mapping(address => uint256) public tokenToStatus;\n    // used for defining different leverage ratios for staked assets\n    mapping(bytes32 => uint256) public debtCoverageStaked;\n\n    mapping(bytes32 => bytes32) public identifierToExposureGroup;\n    mapping(bytes32 => Exposure) public groupToExposure;\n\n    mapping(address => mapping(bytes32 => uint256)) public pendingUserExposure;\n    mapping(bytes32 => uint256) public pendingProtocolExposure;\n\n    address public vPrimeControllerAddress;\n\n    /**\n    * Returns the address of the vPrimeController contract\n     */\n    function getVPrimeControllerAddress() public view returns (address) {\n        return vPrimeControllerAddress;\n    }\n\n    /**\n    * Sets the address of the vPrimeController contract\n     */\n    function setVPrimeControllerAddress(address _vPrimeControllerAddress) public onlyOwner {\n        vPrimeControllerAddress = _vPrimeControllerAddress;\n    }\n\n    function initialize(Asset[] memory tokenAssets, poolAsset[] memory poolAssets) external initializer {\n        __Ownable_init();\n\n        addTokenAssets(tokenAssets);\n        addPoolAssets(poolAssets);\n    }\n\n    function getAllPoolAssets() public view returns (bytes32[] memory result) {\n        return assetToPoolAddress._inner._keys._inner._values;\n    }\n\n    function getSupportedTokensAddresses() public view returns (address[] memory) {\n        return supportedTokensList;\n    }\n\n    function getAllTokenAssets() public view returns (bytes32[] memory result) {\n        return assetToTokenAddress._inner._keys._inner._values;\n    }\n\n    /**\n    * Returns address of an asset\n    **/\n    function getAssetAddress(bytes32 _asset, bool allowInactive) public view returns (address) {\n        (, address assetAddress) = assetToTokenAddress.tryGet(_asset);\n        require(assetAddress != address(0), \"Asset not supported.\");\n        if (!allowInactive) {\n            require(tokenToStatus[assetAddress] == _ACTIVE, \"Asset inactive\");\n        }\n\n        return assetAddress;\n    }\n\n    /**\n    * Returns address of an asset's lending pool\n    **/\n    function getPoolAddress(bytes32 _asset) public view returns (address) {\n        (, address assetAddress) = assetToPoolAddress.tryGet(_asset);\n        require(assetAddress != address(0), \"Pool asset not supported.\");\n\n        return assetAddress;\n    }\n\n    function increaseProtocolExposure(bytes32 assetIdentifier, uint256 exposureIncrease) public onlyPrimeAccountOrOwner {\n        bytes32 group = identifierToExposureGroup[assetIdentifier];\n        if(group != \"\"){\n            Exposure storage exposure = groupToExposure[group];\n            if(exposure.max != 0){\n                exposure.current += exposureIncrease;\n                require(exposure.current <= exposure.max, \"Max asset exposure breached\");\n                emit ProtocolExposureChanged(msg.sender, group, exposure.current, block.timestamp);\n            }\n        }\n    }\n\n    function decreaseProtocolExposure(bytes32 assetIdentifier, uint256 exposureDecrease) public onlyPrimeAccountOrOwner {\n        bytes32 group = identifierToExposureGroup[assetIdentifier];\n        if(group != \"\"){\n            Exposure storage exposure = groupToExposure[group];\n            if(exposure.max != 0){\n                exposure.current = exposure.current <= exposureDecrease ? 0 : exposure.current - exposureDecrease;\n                emit ProtocolExposureChanged(msg.sender, group, exposure.current, block.timestamp);\n            }\n        }\n    }\n\n    function setCurrentProtocolExposure(bytes32[] memory groupIdentifiers, uint256[] memory currentExposures) external onlyOwner {\n        require(groupIdentifiers.length == currentExposures.length, \"Arrays lengths mismatch\");\n        for (uint256 i = 0; i < groupIdentifiers.length; i++) {\n            _setCurrentProtocolExposure(groupIdentifiers[i], currentExposures[i]);\n        }\n    }\n\n    function setMaxProtocolsExposure(bytes32[] memory groupIdentifiers, uint256[] memory maxExposures) public onlyOwner {\n        require(groupIdentifiers.length == maxExposures.length, \"Arrays lengths mismatch\");\n        for (uint256 i = 0; i < groupIdentifiers.length; i++) {\n            _setMaxProtocolExposure(groupIdentifiers[i], maxExposures[i]);\n        }\n    }\n\n    function _setMaxProtocolExposure(bytes32 groupIdentifier, uint256 maxExposure) internal {\n        require(groupIdentifier != \"\", \"Cannot set an empty string asset.\");\n        uint256 prevExposure = groupToExposure[groupIdentifier].max;\n        groupToExposure[groupIdentifier].max = maxExposure;\n\n        emit ProtocolExposureSet(msg.sender, groupIdentifier, prevExposure, maxExposure, groupToExposure[groupIdentifier].current , block.timestamp);\n    }\n\n    function _setCurrentProtocolExposure(bytes32 groupIdentifier, uint256 currentExposure) internal {\n        require(groupIdentifier != \"\", \"Cannot set an empty string asset.\");\n        uint256 prevExposure = groupToExposure[groupIdentifier].current;\n        groupToExposure[groupIdentifier].current = currentExposure;\n\n        emit ProtocolCurrentExposureSet(msg.sender, groupIdentifier, prevExposure, currentExposure, block.timestamp);\n    }\n\n    function setIdentifiersToExposureGroups(bytes32[] memory identifiers, bytes32[] memory exposureGroups) public onlyOwner {\n        require(identifiers.length == exposureGroups.length, \"Arrays lengths mismatch\");\n        for(uint i=0; i<identifiers.length; i++){\n            identifierToExposureGroup[identifiers[i]] = exposureGroups[i];\n            emit IdentifierToExposureGroupSet(msg.sender, identifiers[i], exposureGroups[i], block.timestamp);\n        }\n\n    }\n\n    function addPoolAssets(poolAsset[] memory poolAssets) public onlyOwner {\n        for (uint256 i = 0; i < poolAssets.length; i++) {\n            _addPoolAsset(poolAssets[i].asset, poolAssets[i].poolAddress);\n        }\n    }\n\n    function _addPoolAsset(bytes32 _asset, address _poolAddress) internal {\n        require(Address.isContract(_poolAddress), \"TokenManager: Pool must be a contract\");\n        require(!assetToPoolAddress.contains(_asset), \"Asset's pool already exists\");\n        assetToPoolAddress.set(_asset, _poolAddress);\n        emit PoolAssetAdded(msg.sender, _asset, _poolAddress, block.timestamp);\n    }\n\n    function addTokenAssets(Asset[] memory tokenAssets) public onlyOwner {\n        for (uint256 i = 0; i < tokenAssets.length; i++) {\n            _addTokenAsset(tokenAssets[i].asset, tokenAssets[i].assetAddress, tokenAssets[i].debtCoverage);\n        }\n    }\n\n    function isTokenAssetActive(address token) external view returns(bool) {\n        return tokenToStatus[token] == _ACTIVE;\n    }\n\n    function activateToken(address token) public onlyOwner {\n        require(tokenToStatus[token] == _INACTIVE, \"Must be inactive\");\n        tokenToStatus[token] = _ACTIVE;\n        emit TokenAssetActivated(msg.sender, token, block.timestamp);\n    }\n\n    function deactivateToken(address token) public onlyOwner {\n        require(tokenToStatus[token] == _ACTIVE, \"Must be active\");\n        tokenToStatus[token] = _INACTIVE;\n        emit TokenAssetDeactivated(msg.sender, token, block.timestamp);\n    }\n\n    function _addTokenAsset(bytes32 _asset, address _tokenAddress, uint256 _debtCoverage) internal {\n        require(_asset != \"\", \"Cannot set an empty string asset.\");\n        require(_tokenAddress != address(0), \"Cannot set an empty address.\");\n        require(!assetToTokenAddress.contains(_asset), \"Asset's token already exists\");\n        require(tokenAddressToSymbol[_tokenAddress] == 0, \"Asset address is already in use\");\n        setDebtCoverage(_tokenAddress, _debtCoverage);\n\n        assetToTokenAddress.set(_asset, _tokenAddress);\n        tokenAddressToSymbol[_tokenAddress] = _asset;\n        tokenToStatus[_tokenAddress] = _ACTIVE;\n\n        supportedTokensList.push(_tokenAddress);\n        tokenPositionInList[_tokenAddress] = supportedTokensList.length - 1;\n\n        emit TokenAssetAdded(msg.sender, _asset, _tokenAddress, block.timestamp);\n    }\n\n    function _removeTokenFromList(address tokenToRemove) internal {\n        // Move last address token to the `tokenToRemoveIndex` position (index of an asset that is being removed) in the address[] supportedTokensList\n        // and update map(address=>uint256) tokenPostitionInList if the token is not already the last element\n        uint256 tokenToRemoveIndex = tokenPositionInList[tokenToRemove];\n        require(tokenToRemoveIndex < supportedTokensList.length, \"Index out of range\");\n        if (tokenToRemoveIndex == 0 && supportedTokensList[0] != tokenToRemove) {\n            revert(\"Token does not exist\");\n        }\n        if (tokenToRemoveIndex != (supportedTokensList.length - 1)) {\n            address currentLastToken = supportedTokensList[supportedTokensList.length - 1];\n            tokenPositionInList[currentLastToken] = tokenToRemoveIndex;\n            supportedTokensList[tokenToRemoveIndex] = currentLastToken;\n        }\n        // Remove last element - that is either the token that is being removed (if was already at the end)\n        // or some other asset that at this point was already copied to the `index` positon\n        supportedTokensList.pop();\n        tokenPositionInList[tokenToRemove] = 0;\n    }\n\n    function removeTokenAssets(bytes32[] memory _tokenAssets) public onlyOwner {\n        for (uint256 i = 0; i < _tokenAssets.length; i++) {\n            _removeTokenAsset(_tokenAssets[i]);\n        }\n    }\n\n    function _removeTokenAsset(bytes32 _tokenAsset) internal {\n        address tokenAddress = getAssetAddress(_tokenAsset, true);\n        EnumerableMap.remove(assetToTokenAddress, _tokenAsset);\n        tokenAddressToSymbol[tokenAddress] = 0;\n        tokenToStatus[tokenAddress] = _NOT_SUPPORTED;\n        debtCoverage[tokenAddress] = 0;\n        _removeTokenFromList(tokenAddress);\n        emit TokenAssetRemoved(msg.sender, _tokenAsset, block.timestamp);\n    }\n\n    function removePoolAssets(bytes32[] memory _poolAssets) public onlyOwner {\n        for (uint256 i = 0; i < _poolAssets.length; i++) {\n            _removePoolAsset(_poolAssets[i]);\n        }\n    }\n\n    function _removePoolAsset(bytes32 _poolAsset) internal {\n        address poolAddress = getPoolAddress(_poolAsset);\n        EnumerableMap.remove(assetToPoolAddress, _poolAsset);\n        emit PoolAssetRemoved(msg.sender, _poolAsset, poolAddress, block.timestamp);\n    }\n\n    function setDebtCoverage(address token, uint256 coverage) public onlyOwner {\n        //LTV must be lower than 5\n        require(coverage <= 0.833333333333333333e18, 'Debt coverage higher than maximum acceptable');\n        debtCoverage[token] = coverage;\n    }\n\n    function setDebtCoverageStaked(bytes32 stakedAsset, uint256 coverage) public onlyOwner {\n        //LTV must be lower than 5\n        require(coverage <= 0.833333333333333333e18, 'Debt coverage higher than maximum acceptable');\n        debtCoverageStaked[stakedAsset] = coverage;\n    }\n\n    function isExposureAvailable(bytes32 assetIdentifier) internal view returns(bool) {\n        bytes32 group = identifierToExposureGroup[assetIdentifier];\n        if(group != \"\"){\n            Exposure memory exposure = groupToExposure[group];\n            if(exposure.max != 0){\n                if(exposure.max <= exposure.current + pendingProtocolExposure[assetIdentifier]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    function increasePendingExposure(bytes32 assetIdentifier, address user, uint256 amount) public onlyPrimeAccountOrOwner {\n        pendingUserExposure[user][assetIdentifier] += amount;\n        pendingProtocolExposure[assetIdentifier] += amount;\n        \n        require(isExposureAvailable(assetIdentifier), \"Lack of Exposure\");\n    }\n\n    function setPendingExposureToZero(bytes32 assetIdentifier, address user) public onlyPrimeAccountOrOwner {\n        uint256 pending = pendingUserExposure[user][assetIdentifier];\n        if(pending > 0) {\n            pendingProtocolExposure[assetIdentifier] -= pending;\n            pendingUserExposure[user][assetIdentifier] = 0;\n        }\n    }\n\n    function getSmartLoansFactoryAddress() public view virtual returns (address) {\n        return DeploymentConstants.getSmartLoansFactoryAddress();\n    }\n\n    /* ========== OVERRIDDEN FUNCTIONS ========== */\n\n    function renounceOwnership() public virtual override {}\n\n    /* ========== MODIFIERS ========== */\n\n    modifier onlyPrimeAccountOrOwner() {\n        IBorrowersRegistry borrowersRegistry = IBorrowersRegistry(getSmartLoansFactoryAddress());\n        require(borrowersRegistry.canBorrow(msg.sender) || owner() == _msgSender(), \"Only PrimeAccount or owner can change protocol exposure\");\n        _;\n    }\n\n    /**\n     * @dev emitted after changing current protocol exposure\n     * @param performer an address of the wallet changing the exposure\n     * @param identifier group identifier\n     * @param newExposure new current protocol exposure\n     * @param timestamp time of associating identifier with a exposure group\n     **/\n    event ProtocolExposureChanged(address indexed performer, bytes32 indexed identifier, uint256 newExposure, uint256 timestamp);\n\n\n    /**\n     * @dev emitted after associating identifier with a exposure group\n     * @param performer an address of the wallet setting max exposure\n     * @param identifier asset identifier\n     * @param exposureGroup exposure group identifier\n     * @param timestamp time of associating identifier with a exposure group\n     **/\n    event IdentifierToExposureGroupSet(address indexed performer, bytes32 indexed identifier, bytes32 indexed exposureGroup, uint256 timestamp);\n\n    /**\n     * @dev emitted after setting max exposure for a given protocol.\n     * @param performer an address of the wallet setting max exposure\n     * @param groupIdentifier exposure group identifier\n     * @param prevMaxExposure previous max protocol exposure\n     * @param newMaxExposure new max protocol exposure\n     * @param currentExposure current protocol exposure\n     * @param timestamp time of setting max exposure\n     **/\n    event ProtocolExposureSet(address indexed performer, bytes32 indexed groupIdentifier, uint256 prevMaxExposure, uint256 newMaxExposure, uint256 currentExposure, uint256 timestamp);\n\n\n    /**\n         * @dev emitted after setting max exposure for a given protocol.\n     * @param performer an address of the wallet setting max exposure\n     * @param groupIdentifier exposure group identifier\n     * @param prevCurrentExposure previous max protocol exposure\n     * @param newCurrentExposure new max protocol exposure\n     * @param timestamp time of setting max exposure\n     **/\n    event ProtocolCurrentExposureSet(address indexed performer, bytes32 indexed groupIdentifier, uint256 prevCurrentExposure, uint256 newCurrentExposure, uint256 timestamp);\n\n\n\n    /**\n     * @dev emitted after adding a token asset\n     * @param performer an address of the wallet adding a token asset\n     * @param tokenAsset token asset\n     * @param assetAddress an address of the token asset\n     * @param timestamp time of adding a token asset\n     **/\n    event TokenAssetAdded(address indexed performer, bytes32 indexed tokenAsset, address assetAddress, uint256 timestamp);\n\n    /**\n     * @dev emitted after activating a token asset\n     * @param performer an address of the wallet activating a token asset\n     * @param assetAddress an address of the token asset\n     * @param timestamp time of activating a token asset\n     **/\n    event TokenAssetActivated(address indexed performer, address assetAddress, uint256 timestamp);\n\n    /**\n     * @dev emitted after deactivating a token asset\n     * @param performer an address of the wallet deactivating a token asset\n     * @param assetAddress an address of the token asset\n     * @param timestamp time of deactivating a token asset\n     **/\n    event TokenAssetDeactivated(address indexed performer, address assetAddress, uint256 timestamp);\n\n    /**\n     * @dev emitted after removing a token asset\n     * @param performer an address of the wallet removing a token asset\n     * @param tokenAsset token asset\n     * @param timestamp time a token asset removal\n     **/\n    event TokenAssetRemoved(address indexed performer, bytes32 indexed tokenAsset, uint256 timestamp);\n\n    /**\n     * @dev emitted after adding a pool asset\n     * @param performer an address of wallet adding the pool asset\n     * @param poolAsset pool asset\n     * @param poolAddress an address of the pool asset\n     * @param timestamp time of the pool asset addition\n     **/\n    event PoolAssetAdded(address indexed performer, bytes32 indexed poolAsset, address poolAddress, uint256 timestamp);\n\n    /**\n     * @dev emitted after removing a pool asset\n     * @param performer an address of wallet removing the pool asset\n     * @param poolAsset pool asset\n     * @param poolAddress an address of the pool asset\n     * @param timestamp time of a pool asset removal\n     **/\n    event PoolAssetRemoved(address indexed performer, bytes32 indexed poolAsset, address poolAddress, uint256 timestamp);\n}\n"
    },
    "contracts/VestingDistributor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 9f1e1bba11316303810f35a4440e20bc5ad0ef86;\npragma solidity 0.8.27;\n\nimport \"./Pool.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title VestingDistributor\n * @dev Contract distributing pool's spread among vesting participants.\n */\ncontract VestingDistributor {\n\n    Pool immutable pool;\n    IERC20Metadata immutable poolToken;\n    address keeper;\n    address pendingKeeper;\n\n    uint256 totalLockedMultiplied;\n    address[] public participants;\n    mapping(address => uint256) public locked;\n    mapping(address => uint256) public withdrawn;\n    mapping(address => uint256) public unvestingTime;\n    mapping(address => uint256) public unlockTimestamp;\n    mapping(address => uint256) public multiplier;\n    mapping(uint256 => uint256) rewardAmount;\n    mapping(uint256 => mapping(address => bool)) rewardDistributed;\n    mapping(uint256 => uint256) numRewardDistributed;\n\n    uint256 lastUpdated;\n    uint256 updateInterval = 6 hours;\n\n    uint256 public constant ONE_DAY = 24 * 3600; // 24 hours * 3600 seconds\n    uint256 public constant MIN_VESTING_TIME = ONE_DAY; // 1 day * 24 hours * 3600 seconds\n    uint256 public constant MAX_VESTING_TIME = 30 * ONE_DAY; // 30 days * 24 hours * 3600 seconds\n\n    modifier onlyPool() {\n        require(msg.sender == address(pool), \"Unauthorized: onlyPool\");\n        _;\n    }\n\n    modifier onlyKeeper() {\n        require(msg.sender == keeper, \"Unauthorized: onlyKeeper\");\n        _;\n    }\n\n    modifier onlyPendingKeeper() {\n        require(msg.sender == pendingKeeper, \"Unauthorized: onlyPendingKeeper\");\n        _;\n    }\n\n    constructor(address poolAddress, address keeperAddress) {\n        pool = Pool(poolAddress);\n        poolToken = IERC20Metadata(pool.tokenAddress());\n        keeper = keeperAddress;\n        lastUpdated = block.timestamp;\n    }\n\n    function transferKeeper(address keeperAddress) external onlyKeeper {\n        pendingKeeper = keeperAddress;\n    }\n\n    function acceptKeeper() external onlyPendingKeeper {\n        keeper = pendingKeeper;\n        pendingKeeper = address(0);\n    }\n\n    /**\n     * Add vesting participant (msg.sender)\n     **/\n    function startVesting(uint256 amount, uint256 time) public {\n        if (time < MIN_VESTING_TIME || time > MAX_VESTING_TIME) revert InvalidVestingTime();\n        if (pool.balanceOf(msg.sender) < amount) revert InsufficientPoolBalance();\n        if (locked[msg.sender] > 0 || unvestingTime[msg.sender] > 0) revert AlreadyLocked();\n\n        participants.push(msg.sender);\n        locked[msg.sender] = amount;\n        unvestingTime[msg.sender] = time;\n        uint256 _multiplier = getMultiplier(time);\n        multiplier[msg.sender] = _multiplier;\n\n        totalLockedMultiplied += amount * _multiplier / 1e18;\n    }\n\n    /**\n     * Increase vesting of msg.sender\n     **/\n    function increaseVesting(uint256 amount) public {\n        if (locked[msg.sender] == 0 || unvestingTime[msg.sender] == 0) revert UserNotLocked();\n        if (pool.balanceOf(msg.sender) < locked[msg.sender] + amount) revert InsufficientPoolBalance();\n        if (unlockTimestamp[msg.sender] > 0) revert TooLate();\n\n        locked[msg.sender] += amount;\n\n        totalLockedMultiplied += amount * multiplier[msg.sender] / 1e18;\n    }\n\n    /**\n     * Unlock funds - start of unvesting\n     **/\n    function unlock() public {\n        if (locked[msg.sender] == 0 || unvestingTime[msg.sender] == 0) revert UserNotLocked();\n\n        unlockTimestamp[msg.sender] = block.timestamp;\n    }\n\n    /**\n     * Check how much user can withdraw\n     **/\n    function availableToWithdraw(address account) public view returns (uint256) {\n        if (locked[account] == 0 || unvestingTime[account] == 0) revert UserNotLocked();\n        if (unlockTimestamp[account] == 0) revert UserLocked();\n\n        uint256 timeFromUnlock = block.timestamp - unlockTimestamp[account];\n        if (timeFromUnlock > unvestingTime[account]) timeFromUnlock = unvestingTime[account];\n        uint256 initialUnlock = ONE_DAY * locked[account] / (unvestingTime[account] + ONE_DAY); // 1D / vesting days * locked amount\n\n        return initialUnlock + timeFromUnlock * (locked[account] - initialUnlock) / unvestingTime[account];\n    }\n\n    /**\n     * Gets pool's spread and distributes among vesting participants.\n     * @dev _totalLoans total value of loans\n     * @dev _totalDeposits total value of deposits\n     **/\n    //TODO: run periodically by bots\n    function distributeRewards(uint256 fromIndex, uint256 toIndex) public onlyKeeper {\n        if (block.timestamp < lastUpdated + updateInterval) revert DistributeTooEarly();\n\n        (fromIndex, toIndex) = fromIndex < toIndex ? (fromIndex, toIndex) : (toIndex, fromIndex);\n        toIndex = toIndex < participants.length ? toIndex : participants.length - 1;\n\n        if (rewardAmount[lastUpdated] == 0) {\n            rewardAmount[lastUpdated] = pool.balanceOf(address(this));\n        }\n        uint256 rewards = rewardAmount[lastUpdated];\n\n        for (uint256 i = fromIndex; i <= toIndex; i++) {\n            address participant = participants[i];\n            if (rewardDistributed[lastUpdated][participant]) {\n                continue;\n            }\n\n            //TODO: right now we distribute rewards even when someone start withdrawing. The rewards should depend on the amount which is still locked.\n            uint256 participantReward = rewards * (locked[participant] - withdrawn[participant]) * multiplier[participant] / 1e18 / totalLockedMultiplied;\n\n            pool.transfer(participant, participantReward);\n\n            rewardDistributed[lastUpdated][participant] = true;\n            ++numRewardDistributed[lastUpdated];\n            if (numRewardDistributed[lastUpdated] == participants.length) {\n                lastUpdated = block.timestamp;\n            }\n        }\n    }\n\n    //TODO: run periodically by bots\n    function updateParticipants(uint256 fromIndex, uint256 toIndex) public onlyKeeper {\n        (fromIndex, toIndex) = fromIndex < toIndex ? (fromIndex, toIndex) : (toIndex, fromIndex);\n        toIndex = toIndex < participants.length ? toIndex : participants.length - 1;\n        for (uint256 i = fromIndex; i <= toIndex;) {\n            address participant = participants[i];\n            if (unlockTimestamp[participant] > 0 && (block.timestamp - unlockTimestamp[participant]) > unvestingTime[participant]) {\n                totalLockedMultiplied -= (locked[participant] - withdrawn[participant]) * multiplier[participant] / 1e18;\n\n                unvestingTime[participant] = 0;\n                locked[participant] = 0;\n                unlockTimestamp[participant] = 0;\n                withdrawn[participant] = 0;\n                multiplier[participant] = 0;\n\n                participants[i] = participants[participants.length - 1];\n                participants.pop();\n                --toIndex;\n            } else {\n                ++i;\n            }\n        }\n    }\n\n    function updateWithdrawn(address account, uint256 amount) public onlyPool {\n        withdrawn[account] += amount;\n        if (withdrawn[account] > availableToWithdraw(account)) {\n            revert WithdrawMoreThanLocked();\n        }\n        totalLockedMultiplied -= amount * multiplier[account] / 1e18;\n    }\n\n    function getMultiplier(uint256 time) public pure returns (uint256){\n        if (time >= 30 * ONE_DAY) return 2e18; // min. 30 days\n        if (time >= 29 * ONE_DAY) return 1.99e18; // min. 29 days\n        if (time >= 28 * ONE_DAY) return 1.98e18; // min. 28 days\n        if (time >= 27 * ONE_DAY) return 1.97e18; // min. 27 days\n        if (time >= 26 * ONE_DAY) return 1.96e18; // min. 26 days\n        if (time >= 25 * ONE_DAY) return 1.948e18; // min. 25 days\n        if (time >= 24 * ONE_DAY) return 1.936e18; // min. 24 days\n        if (time >= 23 * ONE_DAY) return 1.924e18; // min. 23 days\n        if (time >= 22 * ONE_DAY) return 1.912e18; // min. 22 days\n        if (time >= 21 * ONE_DAY) return 1.9e18; // min. 21 days\n        if (time >= 20 * ONE_DAY) return 1.885e18; // min. 20 days\n        if (time >= 19 * ONE_DAY) return 1.871e18; // min. 19 days\n        if (time >= 18 * ONE_DAY) return 1.856e18; // min. 18 days\n        if (time >= 17 * ONE_DAY) return 1.841e18; // min. 17 days\n        if (time >= 16 * ONE_DAY) return 1.824e18; // min. 16 days\n        if (time >= 15 * ONE_DAY) return 1.806e18; // min. 15 days\n        if (time >= 14 * ONE_DAY) return 1.788e18; // min. 14 days\n        if (time >= 13 * ONE_DAY) return 1.768e18; // min. 13 days\n        if (time >= 12 * ONE_DAY) return 1.746e18; // min. 12 days\n        if (time >= 11 * ONE_DAY) return 1.723e18; // min. 11 days\n        if (time >= 10 * ONE_DAY) return 1.698e18; // min. 10 days\n        if (time >= 9 * ONE_DAY) return 1.67e18; // min. 9 days\n        if (time >= 8 * ONE_DAY) return 1.64e18; // min. 8 days\n        if (time >= 7 * ONE_DAY) return 1.605e18; // min. 7 days\n        if (time >= 6 * ONE_DAY) return 1.566e18; // min. 6 days\n        if (time >= 5 * ONE_DAY) return 1.521e18; // min. 5 days\n        if (time >= 4 * ONE_DAY) return 1.468e18; // min. 4 days\n        if (time >= 3 * ONE_DAY) return 1.4e18; // min. 3 days\n        if (time >= 2 * ONE_DAY) return 1.32e18; // min. 2 days\n        if (time >= 1 * ONE_DAY) return 1.2e18; // min. 1 day\n\n        return 1e18;\n    }\n\n\n    // Trying to distribute before the update interval has been reached\n    error DistributeTooEarly();\n\n    // Already participates in vesting\n    error AlreadyLocked();\n\n    // Vesting time is out of range\n    error InvalidVestingTime();\n\n    // Insufficient user balance of pool's tokens\n    error InsufficientPoolBalance();\n\n    // User not locked\n    error UserNotLocked();\n\n    // User funds are locked\n    error UserLocked();\n\n    // Too late\n    error TooLate();\n\n    // Withdraw amount is more than locked\n    error WithdrawMoreThanLocked();\n}"
    },
    "contracts/WrappedNativeTokenPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: 5bae95ca244e96444fe80078195944f6637e72d8;\npragma solidity 0.8.27;\n\nimport \"./Pool.sol\";\nimport \"./interfaces/IWrappedNativeToken.sol\";\n\n/**\n * @title Pool\n * @dev Contract allowing user to deposit to and borrow from a single pot\n * Depositors are rewarded with the interest rates collected from borrowers.\n * Rates are compounded every second and getters always return the current deposit and borrowing balance.\n * The interest rates calculation is delegated to the external calculator contract.\n */\ncontract WrappedNativeTokenPool is Pool {\n    using TransferHelper for address payable;\n    using TransferHelper for address;\n\n    /**\n     * Wraps and deposits amount attached to the transaction\n     **/\n    function depositNativeToken() external payable gated virtual {\n        if(msg.value == 0) revert ZeroDepositAmount();\n\n        _accumulateDepositInterest(msg.sender);\n\n        if(totalSupplyCap != 0){\n            if(_deposited[address(this)] + msg.value > totalSupplyCap) revert TotalSupplyCapBreached();\n        }\n\n        IWrappedNativeToken(tokenAddress).deposit{value : msg.value}();\n\n        _mint(msg.sender, msg.value);\n        _deposited[address(this)] += msg.value;\n        _updateRates();\n\n        if (address(poolRewarder) != address(0) && !isDepositorExcludedFromRewarder(msg.sender)) {\n            poolRewarder.stakeFor(msg.value, msg.sender);\n        }\n\n        notifyVPrimeController(msg.sender);\n\n        emit Deposit(msg.sender, msg.value, block.timestamp);\n    }\n\n    /**\n     * Unwraps and withdraws selected amount from the user deposits\n     * @dev _amount the amount to be withdrawn\n     **/\n    function withdrawNativeToken(uint256 _amount) external nonReentrant gated {\n        if(_amount > IERC20(tokenAddress).balanceOf(address(this))) revert InsufficientPoolFunds();\n\n        _accumulateDepositInterest(msg.sender);\n\n        if(_amount > _deposited[address(this)]) revert BurnAmountExceedsBalance();\n        // verified in \"require\" above\n        unchecked {\n            _deposited[address(this)] -= _amount;\n        }\n        _burn(msg.sender, _amount);\n\n        _updateRates();\n\n        IWrappedNativeToken(tokenAddress).withdraw(_amount);\n        payable(msg.sender).safeTransferETH(_amount);\n\n        if (address(poolRewarder) != address(0) && !isDepositorExcludedFromRewarder(msg.sender)) {\n            poolRewarder.withdrawFor(_amount, msg.sender);\n        }\n\n        notifyVPrimeController(msg.sender);\n\n        emit Withdrawal(msg.sender, _amount, block.timestamp);\n    }\n\n    /* ========== RECEIVE AVAX FUNCTION ========== */\n    //needed for withdrawNativeToken\n    receive() external payable {}\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "evmVersion": "cancun",
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}