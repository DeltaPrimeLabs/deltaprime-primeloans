{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuardUpgradeable is Initializable {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    function __ReentrancyGuard_init() internal onlyInitializing {\n        __ReentrancyGuard_init_unchained();\n    }\n\n    function __ReentrancyGuard_init_unchained() internal onlyInitializing {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/CalldataExtractor.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\n\nimport \"./RedstoneConstants.sol\";\n\n/**\n * @title The base contract with the main logic of data extraction from calldata\n * @author The Redstone Oracles team\n * @dev This contract was created to reuse the same logic in the RedstoneConsumerBase\n * and the ProxyConnector contracts\n */\ncontract CalldataExtractor is RedstoneConstants {\n  using SafeMath for uint256;\n\n  error DataPackageTimestampMustNotBeZero();\n  error DataPackageTimestampsMustBeEqual();\n  error RedstonePayloadMustHaveAtLeastOneDataPackage();\n\n  function extractTimestampsAndAssertAllAreEqual() public pure returns (uint256 extractedTimestamp) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n\n    if (dataPackagesCount == 0) {\n      revert RedstonePayloadMustHaveAtLeastOneDataPackage();\n    }\n\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n\n      // Extracting timestamp for the current data package\n      uint48 dataPackageTimestamp; // uint48, because timestamp uses 6 bytes\n      uint256 timestampNegativeOffset = (calldataNegativeOffset + TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS);\n      uint256 timestampOffset = msg.data.length - timestampNegativeOffset;\n      assembly {\n        dataPackageTimestamp := calldataload(timestampOffset)\n      }\n\n      if (dataPackageTimestamp == 0) {\n        revert DataPackageTimestampMustNotBeZero();\n      }\n\n      if (extractedTimestamp == 0) {\n        extractedTimestamp = dataPackageTimestamp;\n      } else if (dataPackageTimestamp != extractedTimestamp) {\n        revert DataPackageTimestampsMustBeEqual();\n      }\n\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n  }\n\n  function _getDataPackageByteSize(uint256 calldataNegativeOffset) internal pure returns (uint256) {\n    (\n      uint256 dataPointsCount,\n      uint256 eachDataPointValueByteSize\n    ) = _extractDataPointsDetailsForDataPackage(calldataNegativeOffset);\n\n    return\n      dataPointsCount *\n      (DATA_POINT_SYMBOL_BS + eachDataPointValueByteSize) +\n      DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n  }\n\n  function _extractByteSizeOfUnsignedMetadata() internal pure returns (uint256) {\n    // Checking if the calldata ends with the RedStone marker\n    bool hasValidRedstoneMarker;\n    assembly {\n      let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n      hasValidRedstoneMarker := eq(\n        REDSTONE_MARKER_MASK,\n        and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n      )\n    }\n    if (!hasValidRedstoneMarker) {\n      revert CalldataMustHaveValidPayload();\n    }\n\n    // Using uint24, because unsigned metadata byte size number has 3 bytes\n    uint24 unsignedMetadataByteSize;\n    if (REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      unsignedMetadataByteSize := calldataload(\n        sub(calldatasize(), REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS)\n      )\n    }\n    uint256 calldataNegativeOffset = unsignedMetadataByteSize\n      + UNSIGNED_METADATA_BYTE_SIZE_BS\n      + REDSTONE_MARKER_BS;\n    if (calldataNegativeOffset + DATA_PACKAGES_COUNT_BS > msg.data.length) {\n      revert IncorrectUnsignedMetadataSize();\n    }\n    return calldataNegativeOffset;\n  }\n\n  // We return uint16, because unsigned metadata byte size number has 2 bytes\n  function _extractDataPackagesCountFromCalldata(uint256 calldataNegativeOffset)\n    internal\n    pure\n    returns (uint16 dataPackagesCount)\n  {\n    uint256 calldataNegativeOffsetWithStandardSlot = calldataNegativeOffset + STANDARD_SLOT_BS;\n    if (calldataNegativeOffsetWithStandardSlot > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n    assembly {\n      dataPackagesCount := calldataload(\n        sub(calldatasize(), calldataNegativeOffsetWithStandardSlot)\n      )\n    }\n    return dataPackagesCount;\n  }\n\n  function _extractDataPointValueAndDataFeedId(\n    uint256 calldataNegativeOffsetForDataPackage,\n    uint256 defaultDataPointValueByteSize,\n    uint256 dataPointIndex\n  ) internal pure virtual returns (bytes32 dataPointDataFeedId, uint256 dataPointValue) {\n    uint256 negativeOffsetToDataPoints = calldataNegativeOffsetForDataPackage + DATA_PACKAGE_WITHOUT_DATA_POINTS_BS;\n    uint256 dataPointNegativeOffset = negativeOffsetToDataPoints.add(\n      (1 + dataPointIndex).mul((defaultDataPointValueByteSize + DATA_POINT_SYMBOL_BS))\n    );\n    uint256 dataPointCalldataOffset = msg.data.length.sub(dataPointNegativeOffset);\n    assembly {\n      dataPointDataFeedId := calldataload(dataPointCalldataOffset)\n      dataPointValue := calldataload(add(dataPointCalldataOffset, DATA_POINT_SYMBOL_BS))\n    }\n  }\n\n  function _extractDataPointsDetailsForDataPackage(uint256 calldataNegativeOffsetForDataPackage)\n    internal\n    pure\n    returns (uint256 dataPointsCount, uint256 eachDataPointValueByteSize)\n  {\n    // Using uint24, because data points count byte size number has 3 bytes\n    uint24 dataPointsCount_;\n\n    // Using uint32, because data point value byte size has 4 bytes\n    uint32 eachDataPointValueByteSize_;\n\n    // Extract data points count\n    uint256 negativeCalldataOffset = calldataNegativeOffsetForDataPackage + SIG_BS;\n    uint256 calldataOffset = msg.data.length.sub(negativeCalldataOffset + STANDARD_SLOT_BS);\n    assembly {\n      dataPointsCount_ := calldataload(calldataOffset)\n    }\n\n    // Extract each data point value size\n    calldataOffset = calldataOffset.sub(DATA_POINTS_COUNT_BS);\n    assembly {\n      eachDataPointValueByteSize_ := calldataload(calldataOffset)\n    }\n\n    // Prepare returned values\n    dataPointsCount = dataPointsCount_;\n    eachDataPointValueByteSize = eachDataPointValueByteSize_;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\nimport \"./RedstoneConstants.sol\";\nimport \"./CalldataExtractor.sol\";\n\n/**\n * @title The base contract for forwarding redstone payload to other contracts\n * @author The Redstone Oracles team\n */\ncontract ProxyConnector is RedstoneConstants, CalldataExtractor {\n  error ProxyCalldataFailedWithoutErrMsg();\n  error ProxyCalldataFailedWithStringMessage(string message);\n  error ProxyCalldataFailedWithCustomError(bytes result);\n\n  function proxyCalldata(\n    address contractAddress,\n    bytes memory encodedFunction,\n    bool forwardValue\n  ) internal returns (bytes memory) {\n    bytes memory message = _prepareMessage(encodedFunction);\n\n    (bool success, bytes memory result) =\n      contractAddress.call{value: forwardValue ? msg.value : 0}(message);\n\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyDelegateCalldata(address contractAddress, bytes memory encodedFunction)\n    internal\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.delegatecall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function proxyCalldataView(address contractAddress, bytes memory encodedFunction)\n    internal\n    view\n    returns (bytes memory)\n  {\n    bytes memory message = _prepareMessage(encodedFunction);\n    (bool success, bytes memory result) = contractAddress.staticcall(message);\n    return _prepareReturnValue(success, result);\n  }\n\n  function _prepareMessage(bytes memory encodedFunction) private pure returns (bytes memory) {\n    uint256 encodedFunctionBytesCount = encodedFunction.length;\n    uint256 redstonePayloadByteSize = _getRedstonePayloadByteSize();\n    uint256 resultMessageByteSize = encodedFunctionBytesCount + redstonePayloadByteSize;\n\n    if (redstonePayloadByteSize > msg.data.length) {\n      revert CalldataOverOrUnderFlow();\n    }\n\n    bytes memory message;\n\n    assembly {\n      message := mload(FREE_MEMORY_PTR) // sets message pointer to first free place in memory\n\n      // Saving the byte size of the result message (it's a standard in EVM)\n      mstore(message, resultMessageByteSize)\n\n      // Copying function and its arguments\n      for {\n        let from := add(BYTES_ARR_LEN_VAR_BS, encodedFunction)\n        let fromEnd := add(from, encodedFunctionBytesCount)\n        let to := add(BYTES_ARR_LEN_VAR_BS, message)\n      } lt (from, fromEnd) {\n        from := add(from, STANDARD_SLOT_BS)\n        to := add(to, STANDARD_SLOT_BS)\n      } {\n        // Copying data from encodedFunction to message (32 bytes at a time)\n        mstore(to, mload(from))\n      }\n\n      // Copying redstone payload to the message bytes\n      calldatacopy(\n        add(message, add(BYTES_ARR_LEN_VAR_BS, encodedFunctionBytesCount)), // address\n        sub(calldatasize(), redstonePayloadByteSize), // offset\n        redstonePayloadByteSize // bytes length to copy\n      )\n\n      // Updating free memory pointer\n      mstore(\n        FREE_MEMORY_PTR,\n        add(\n          add(message, add(redstonePayloadByteSize, encodedFunctionBytesCount)),\n          BYTES_ARR_LEN_VAR_BS\n        )\n      )\n    }\n\n    return message;\n  }\n\n  function _getRedstonePayloadByteSize() private pure returns (uint256) {\n    uint256 calldataNegativeOffset = _extractByteSizeOfUnsignedMetadata();\n    uint256 dataPackagesCount = _extractDataPackagesCountFromCalldata(calldataNegativeOffset);\n    calldataNegativeOffset += DATA_PACKAGES_COUNT_BS;\n    for (uint256 dataPackageIndex = 0; dataPackageIndex < dataPackagesCount; dataPackageIndex++) {\n      uint256 dataPackageByteSize = _getDataPackageByteSize(calldataNegativeOffset);\n      calldataNegativeOffset += dataPackageByteSize;\n    }\n\n    return calldataNegativeOffset;\n  }\n\n  function _prepareReturnValue(bool success, bytes memory result)\n    internal\n    pure\n    returns (bytes memory)\n  {\n    if (!success) {\n\n      if (result.length == 0) {\n        revert ProxyCalldataFailedWithoutErrMsg();\n      } else {\n        bool isStringErrorMessage;\n        assembly {\n          let first32BytesOfResult := mload(add(result, BYTES_ARR_LEN_VAR_BS))\n          isStringErrorMessage := eq(first32BytesOfResult, STRING_ERR_MESSAGE_MASK)\n        }\n\n        if (isStringErrorMessage) {\n          string memory receivedErrMsg;\n          assembly {\n            receivedErrMsg := add(result, REVERT_MSG_OFFSET)\n          }\n          revert ProxyCalldataFailedWithStringMessage(receivedErrMsg);\n        } else {\n          revert ProxyCalldataFailedWithCustomError(result);\n        }\n      }\n    }\n\n    return result;\n  }\n}\n"
    },
    "@redstone-finance/evm-connector/contracts/core/RedstoneConstants.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.4;\n\n/**\n * @title The base contract with helpful constants\n * @author The Redstone Oracles team\n * @dev It mainly contains redstone-related values, which improve readability\n * of other contracts (e.g. CalldataExtractor and RedstoneConsumerBase)\n */\ncontract RedstoneConstants {\n  // === Abbreviations ===\n  // BS - Bytes size\n  // PTR - Pointer (memory location)\n  // SIG - Signature\n\n  // Solidity and YUL constants\n  uint256 internal constant STANDARD_SLOT_BS = 32;\n  uint256 internal constant FREE_MEMORY_PTR = 0x40;\n  uint256 internal constant BYTES_ARR_LEN_VAR_BS = 32;\n  uint256 internal constant FUNCTION_SIGNATURE_BS = 4;\n  uint256 internal constant REVERT_MSG_OFFSET = 68; // Revert message structure described here: https://ethereum.stackexchange.com/a/66173/106364\n  uint256 internal constant STRING_ERR_MESSAGE_MASK = 0x08c379a000000000000000000000000000000000000000000000000000000000;\n\n  // RedStone protocol consts\n  uint256 internal constant SIG_BS = 65;\n  uint256 internal constant TIMESTAMP_BS = 6;\n  uint256 internal constant DATA_PACKAGES_COUNT_BS = 2;\n  uint256 internal constant DATA_POINTS_COUNT_BS = 3;\n  uint256 internal constant DATA_POINT_VALUE_BYTE_SIZE_BS = 4;\n  uint256 internal constant DATA_POINT_SYMBOL_BS = 32;\n  uint256 internal constant DEFAULT_DATA_POINT_VALUE_BS = 32;\n  uint256 internal constant UNSIGNED_METADATA_BYTE_SIZE_BS = 3;\n  uint256 internal constant REDSTONE_MARKER_BS = 9; // byte size of 0x000002ed57011e0000\n  uint256 internal constant REDSTONE_MARKER_MASK = 0x0000000000000000000000000000000000000000000000000002ed57011e0000;\n\n  // Derived values (based on consts)\n  uint256 internal constant TIMESTAMP_NEGATIVE_OFFSET_IN_DATA_PACKAGE_WITH_STANDARD_SLOT_BS = 104; // SIG_BS + DATA_POINTS_COUNT_BS + DATA_POINT_VALUE_BYTE_SIZE_BS + STANDARD_SLOT_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_BS = 78; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS + SIG_BS\n  uint256 internal constant DATA_PACKAGE_WITHOUT_DATA_POINTS_AND_SIG_BS = 13; // DATA_POINT_VALUE_BYTE_SIZE_BS + TIMESTAMP_BS + DATA_POINTS_COUNT_BS\n  uint256 internal constant REDSTONE_MARKER_BS_PLUS_STANDARD_SLOT_BS = 41; // REDSTONE_MARKER_BS + STANDARD_SLOT_BS\n\n  // Error messages\n  error CalldataOverOrUnderFlow();\n  error IncorrectUnsignedMetadataSize();\n  error InsufficientNumberOfUniqueSigners(uint256 receivedSignersCount, uint256 requiredSignersCount);\n  error EachSignerMustProvideTheSameValue();\n  error EmptyCalldataPointersArr();\n  error InvalidCalldataPointer();\n  error CalldataMustHaveValidPayload();\n  error SignerNotAuthorised(address receivedSigner);\n}\n"
    },
    "contracts/abstract/PendingOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.17;\n\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"../interfaces/IPendingOwnableUpgradeable.sol\";\n\nabstract contract PendingOwnableUpgradeable is OwnableUpgradeable, IPendingOwnableUpgradeable {\n    // keccak256(\"pending.owner.slot\") = 0x63a0d9df49fae3f1b9d24f8dc819a568c429a1b11d0d8e9de63df53a0194acb2\n    bytes32 private constant _PENDING_OWNER_SLOT = 0x63a0d9df49fae3f1b9d24f8dc819a568c429a1b11d0d8e9de63df53a0194acb2;\n\n    event OwnershipTransferRequested(address indexed from, address indexed to);\n\n    function __PendingOwnable_init() internal onlyInitializing {\n        __Ownable_init();\n    }\n\n    function transferOwnership(address newOwner) public virtual override(OwnableUpgradeable, IPendingOwnableUpgradeable) onlyOwner {\n        require(newOwner != address(0), \"PendingOwnable: new owner is the zero address\");\n        _setPendingOwner(newOwner);\n        emit OwnershipTransferRequested(owner(), newOwner);\n    }\n\n    function acceptOwnership() public virtual override {\n        address pendingOwner = _getPendingOwner();\n        require(msg.sender == pendingOwner, \"PendingOwnable: caller is not the pending owner\");\n        _transferOwnership(pendingOwner);\n        _setPendingOwner(address(0));\n    }\n\n    function pendingOwner() public view virtual override returns (address) {\n        return _getPendingOwner();\n    }\n\n    function _getPendingOwner() internal view returns (address) {\n        address pendingOwner;\n        bytes32 slot = _PENDING_OWNER_SLOT;\n        assembly {\n            pendingOwner := sload(slot)\n        }\n        return pendingOwner;\n    }\n\n    function _setPendingOwner(address newOwner) private {\n        bytes32 slot = _PENDING_OWNER_SLOT;\n        assembly {\n            sstore(slot, newOwner)\n        }\n    }\n}"
    },
    "contracts/interfaces/IPendingOwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: ;\npragma solidity 0.8.17;\n\ninterface IPendingOwnableUpgradeable {\n    function transferOwnership(address newOwner) external;\n    function acceptOwnership() external;\n    function pendingOwner() external view returns (address);\n}"
    },
    "contracts/interfaces/IPositionManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity 0.8.17;\n\nimport '@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol';\nimport \"./ISPrimeTraderJoe.sol\";\n\ninterface IPositionManager is IERC721Enumerable {\n    // details about the position\n    struct Position {\n        // the liquidity of the position\n        uint256 totalShare;\n        uint256 centerId;\n        uint256[] liquidityMinted;\n    }\n\n    struct DepositConfig {\n        uint256[] depositIds;\n        bytes32[] liquidityConfigs;\n    }\n\n\n    struct UpdateParams {\n        uint256 tokenId;\n        uint256 share;\n        uint256[] liquidityAmounts;\n        bool isAdd;\n    }\n\n    struct MintParams {\n        address recipient;\n        uint256 totalShare;\n        uint256 centerId;\n        uint256[] liquidityMinted;\n        bytes32[] liquidityConfigs;\n        uint256[] depositIds;\n    }\n\n    event SPrimeUpdated(ISPrimeTraderJoe prime);\n\n    // Mint new position NFT\n    function mint(\n        MintParams calldata params\n    )\n        external\n        returns (\n            uint256 tokenId\n        );\n\n    // Burn position NFT\n    function burn(\n        uint256 tokenId\n    )\n        external;\n\n    function update(\n        UpdateParams calldata params\n    )\n        external;\n\n    function forceTransfer(address from, address to, uint256 tokenId) external;\n    function getDepositConfig(uint256 centerId) external view returns(DepositConfig memory);\n    function getDepositConfigFromTokenId(uint256 tokenId) external view returns(DepositConfig memory);\n    \n    // Get position details\n    function positions(uint256 tokenId)\n        external\n        view\n        returns (\n            IERC20 token0,\n            IERC20 token1,\n            ILBPair pairAddr,\n            uint256 totalShare,\n            uint256 centerId,\n            uint256[] memory liquidityMinted\n        );\n}"
    },
    "contracts/interfaces/ISPrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface ISPrime {\n    /**\n    * @dev Struct representing details of a locked amount.\n    * @param lockPeriod The duration for which the amount is locked.\n    * @param amount The amount that is locked.\n    * @param unlockTime The timestamp when the locked amount will be able to released.\n    */\n    struct LockDetails {\n        uint256 lockPeriod;\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    /**\n    * @dev Users can use withdraw function for withdrawing their share.\n    * @param shareWithdraw The amount of share to withdraw.\n    */\n    function withdraw(\n        uint256 shareWithdraw\n    ) external;\n\n    function getTokenX() external view returns(IERC20);\n    function getTokenY() external view returns(IERC20);\n    function getPoolPrice() external view returns(uint256);\n    function getUserValueInTokenY(address user, uint256 poolPrice) external view returns (uint256);\n    function getFullyVestedLockedBalance(address account) external view returns(uint256);\n}"
    },
    "contracts/interfaces/ISPrimeTraderJoe.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\nimport \"./ISPrime.sol\";\nimport \"./joe-v2/ILBPair.sol\";\n\ninterface ISPrimeTraderJoe is ISPrime {\n  struct DepositForm{\n    int256 deltaId;\n    uint64 distributionX;\n    uint64 distributionY;\n  }\n\n  /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param activeIdDesired The active id that user wants to add liquidity from\n    * @param idSlippage The number of id that are allowed to slip\n    * @param amountX The amount of token X to deposit.\n    * @param amountY The amount of token Y to deposit.\n    * @param isRebalance Rebalance the existing position with deposit.\n    * @param swapSlippage Slippage for the rebalance.\n    */\n    function deposit(\n        uint256 activeIdDesired,\n        uint256 idSlippage,\n        uint256 amountX,\n        uint256 amountY,\n        bool isRebalance,\n        uint256 swapSlippage\n    ) external;\n    \n  function getLBPair() external view returns(ILBPair);\n}\n"
    },
    "contracts/interfaces/IVPrimeController.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n\npragma solidity ^0.8.17;\n\ninterface IVPrimeController {\n    function updateVPrimeSnapshotsForAccounts(address[] memory accounts) external;\n    function updateVPrimeSnapshot(address userAddress) external;\n    function setUserNeedsUpdate(address userAddress) external;\n}"
    },
    "contracts/interfaces/joe-v2/IJoeFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\n\npragma solidity ^0.8.10;\n\n/// @title Joe V1 Factory Interface\n/// @notice Interface to interact with Joe V1 Factory\ninterface IJoeFactory {\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);\n\n    function feeTo() external view returns (address);\n\n    function feeToSetter() external view returns (address);\n\n    function migrator() external view returns (address);\n\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n    function allPairs(uint256) external view returns (address pair);\n\n    function allPairsLength() external view returns (uint256);\n\n    function createPair(address tokenA, address tokenB) external returns (address pair);\n\n    function setFeeTo(address) external;\n\n    function setFeeToSetter(address) external;\n\n    function setMigrator(address) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBPair} from \"./ILBPair.sol\";\nimport {IPendingOwnable} from \"./IPendingOwnable.sol\";\n\n/**\n * @title Liquidity Book Factory Interface\n * @author Trader Joe\n * @notice Required interface of LBFactory contract\n */\ninterface ILBFactory is IPendingOwnable {\n    error LBFactory__IdenticalAddresses(IERC20 token);\n    error LBFactory__QuoteAssetNotWhitelisted(IERC20 quoteAsset);\n    error LBFactory__QuoteAssetAlreadyWhitelisted(IERC20 quoteAsset);\n    error LBFactory__AddressZero();\n    error LBFactory__LBPairAlreadyExists(IERC20 tokenX, IERC20 tokenY, uint256 _binStep);\n    error LBFactory__LBPairDoesNotExist(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\n    error LBFactory__LBPairNotCreated(IERC20 tokenX, IERC20 tokenY, uint256 binStep);\n    error LBFactory__FlashLoanFeeAboveMax(uint256 fees, uint256 maxFees);\n    error LBFactory__BinStepTooLow(uint256 binStep);\n    error LBFactory__PresetIsLockedForUsers(address user, uint256 binStep);\n    error LBFactory__LBPairIgnoredIsAlreadyInTheSameState();\n    error LBFactory__BinStepHasNoPreset(uint256 binStep);\n    error LBFactory__PresetOpenStateIsAlreadyInTheSameState();\n    error LBFactory__SameFeeRecipient(address feeRecipient);\n    error LBFactory__SameFlashLoanFee(uint256 flashLoanFee);\n    error LBFactory__LBPairSafetyCheckFailed(address LBPairImplementation);\n    error LBFactory__SameImplementation(address LBPairImplementation);\n    error LBFactory__ImplementationNotSet();\n\n    /**\n     * @dev Structure to store the LBPair information, such as:\n     * binStep: The bin step of the LBPair\n     * LBPair: The address of the LBPair\n     * createdByOwner: Whether the pair was created by the owner of the factory\n     * ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\n     */\n    struct LBPairInformation {\n        uint16 binStep;\n        ILBPair LBPair;\n        bool createdByOwner;\n        bool ignoredForRouting;\n    }\n\n    event LBPairCreated(\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBPair LBPair, uint256 pid\n    );\n\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\n\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n\n    event LBPairIgnoredStateChanged(ILBPair indexed LBPair, bool ignored);\n\n    event PresetSet(\n        uint256 indexed binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator\n    );\n\n    event PresetOpenStateChanged(uint256 indexed binStep, bool indexed isOpen);\n\n    event PresetRemoved(uint256 indexed binStep);\n\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\n\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\n\n    function getMinBinStep() external pure returns (uint256);\n\n    function getFeeRecipient() external view returns (address);\n\n    function getMaxFlashLoanFee() external pure returns (uint256);\n\n    function getFlashLoanFee() external view returns (uint256);\n\n    function getLBPairImplementation() external view returns (address);\n\n    function getNumberOfLBPairs() external view returns (uint256);\n\n    function getLBPairAtIndex(uint256 id) external returns (ILBPair);\n\n    function getNumberOfQuoteAssets() external view returns (uint256);\n\n    function getQuoteAssetAtIndex(uint256 index) external view returns (IERC20);\n\n    function isQuoteAsset(IERC20 token) external view returns (bool);\n\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\n        external\n        view\n        returns (LBPairInformation memory);\n\n    function getPreset(uint256 binStep)\n        external\n        view\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxAccumulator,\n            bool isOpen\n        );\n\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\n\n    function getOpenBinSteps() external view returns (uint256[] memory openBinStep);\n\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\n        external\n        view\n        returns (LBPairInformation[] memory LBPairsBinStep);\n\n    function setLBPairImplementation(address lbPairImplementation) external;\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBPair pair);\n\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint16 binStep, bool ignored) external;\n\n    function setPreset(\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        bool isOpen\n    ) external;\n\n    function setPresetOpenState(uint16 binStep, bool isOpen) external;\n\n    function removePreset(uint16 binStep) external;\n\n    function setFeesParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function setFeeRecipient(address feeRecipient) external;\n\n    function setFlashLoanFee(uint256 flashLoanFee) external;\n\n    function addQuoteAsset(IERC20 quoteAsset) external;\n\n    function removeQuoteAsset(IERC20 quoteAsset) external;\n\n    function forceDecay(ILBPair lbPair) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBFlashLoanCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title Liquidity Book Flashloan Callback Interface\n/// @author Trader Joe\n/// @notice Required interface to interact with LB flash loans\ninterface ILBFlashLoanCallback {\n    function LBFlashLoanCallback(\n        address sender,\n        IERC20 tokenX,\n        IERC20 tokenY,\n        bytes32 amounts,\n        bytes32 totalFees,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBHooksBaseRewarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title LB Hooks Base Rewarder Interface\n * @dev Interface for the LB Hooks Base Rewarder\n */\ninterface ILBHooksBaseRewarder {\n    error LBHooksBaseRewarder__InvalidDeltaBins();\n    error LBHooksBaseRewarder__Overflow();\n    error LBHooksBaseRewarder__NativeTransferFailed();\n    error LBHooksBaseRewarder__UnlinkedHooks();\n    error LBHooksBaseRewarder__InvalidHooksParameters();\n    error LBHooksBaseRewarder__ZeroBalance();\n    error LBHooksBaseRewarder__LockedRewardToken();\n    error LBHooksBaseRewarder__NotNativeRewarder();\n    error LBHooksBaseRewarder__NotImplemented();\n    error LBHooksBaseRewarder__UnauthorizedCaller();\n    error LBHooksBaseRewarder__ExceedsMaxNumberOfBins();\n\n    event DeltaBinsSet(int24 deltaBinA, int24 deltaBinB);\n    event Claim(address indexed user, uint256 amount);\n\n    struct Bin {\n        uint256 accRewardsPerShareX64;\n        mapping(address => uint256) userAccRewardsPerShareX64;\n    }\n\n    function getRewardToken() external view returns (IERC20);\n\n    function getLBHooksManager() external view returns (address);\n\n    function isStopped() external view returns (bool);\n\n    function getRewardedRange() external view returns (uint256 binStart, uint256 binEnd);\n\n    function getPendingRewards(address user, uint256[] calldata ids) external view returns (uint256 pendingRewards);\n\n    function claim(address user, uint256[] calldata ids) external;\n\n    function setDeltaBins(int24 deltaBinA, int24 deltaBinB) external;\n\n    function sweep(IERC20 token, address to) external;\n}"
    },
    "contracts/interfaces/joe-v2/ILBLegacyFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBLegacyPair} from \"./ILBLegacyPair.sol\";\nimport {IPendingOwnable} from \"./IPendingOwnable.sol\";\n\n/// @title Liquidity Book Factory Interface\n/// @author Trader Joe\n/// @notice Required interface of LBFactory contract\ninterface ILBLegacyFactory is IPendingOwnable {\n    /// @dev Structure to store the LBPair information, such as:\n    /// - binStep: The bin step of the LBPair\n    /// - LBPair: The address of the LBPair\n    /// - createdByOwner: Whether the pair was created by the owner of the factory\n    /// - ignoredForRouting: Whether the pair is ignored for routing or not. An ignored pair will not be explored during routes finding\n    struct LBPairInformation {\n        uint16 binStep;\n        ILBLegacyPair LBPair;\n        bool createdByOwner;\n        bool ignoredForRouting;\n    }\n\n    event LBPairCreated(\n        IERC20 indexed tokenX, IERC20 indexed tokenY, uint256 indexed binStep, ILBLegacyPair LBPair, uint256 pid\n    );\n\n    event FeeRecipientSet(address oldRecipient, address newRecipient);\n\n    event FlashLoanFeeSet(uint256 oldFlashLoanFee, uint256 newFlashLoanFee);\n\n    event FeeParametersSet(\n        address indexed sender,\n        ILBLegacyPair indexed LBPair,\n        uint256 binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator\n    );\n\n    event FactoryLockedStatusUpdated(bool unlocked);\n\n    event LBPairImplementationSet(address oldLBPairImplementation, address LBPairImplementation);\n\n    event LBPairIgnoredStateChanged(ILBLegacyPair indexed LBPair, bool ignored);\n\n    event PresetSet(\n        uint256 indexed binStep,\n        uint256 baseFactor,\n        uint256 filterPeriod,\n        uint256 decayPeriod,\n        uint256 reductionFactor,\n        uint256 variableFeeControl,\n        uint256 protocolShare,\n        uint256 maxVolatilityAccumulator,\n        uint256 sampleLifetime\n    );\n\n    event PresetRemoved(uint256 indexed binStep);\n\n    event QuoteAssetAdded(IERC20 indexed quoteAsset);\n\n    event QuoteAssetRemoved(IERC20 indexed quoteAsset);\n\n    function MAX_FEE() external pure returns (uint256);\n\n    function MIN_BIN_STEP() external pure returns (uint256);\n\n    function MAX_BIN_STEP() external pure returns (uint256);\n\n    function MAX_PROTOCOL_SHARE() external pure returns (uint256);\n\n    function LBPairImplementation() external view returns (address);\n\n    function getNumberOfQuoteAssets() external view returns (uint256);\n\n    function getQuoteAsset(uint256 index) external view returns (IERC20);\n\n    function isQuoteAsset(IERC20 token) external view returns (bool);\n\n    function feeRecipient() external view returns (address);\n\n    function flashLoanFee() external view returns (uint256);\n\n    function creationUnlocked() external view returns (bool);\n\n    function allLBPairs(uint256 id) external returns (ILBLegacyPair);\n\n    function getNumberOfLBPairs() external view returns (uint256);\n\n    function getLBPairInformation(IERC20 tokenX, IERC20 tokenY, uint256 binStep)\n        external\n        view\n        returns (LBPairInformation memory);\n\n    function getPreset(uint16 binStep)\n        external\n        view\n        returns (\n            uint256 baseFactor,\n            uint256 filterPeriod,\n            uint256 decayPeriod,\n            uint256 reductionFactor,\n            uint256 variableFeeControl,\n            uint256 protocolShare,\n            uint256 maxAccumulator,\n            uint256 sampleLifetime\n        );\n\n    function getAllBinSteps() external view returns (uint256[] memory presetsBinStep);\n\n    function getAllLBPairs(IERC20 tokenX, IERC20 tokenY)\n        external\n        view\n        returns (LBPairInformation[] memory LBPairsBinStep);\n\n    function setLBPairImplementation(address LBPairImplementation) external;\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBLegacyPair pair);\n\n    function setLBPairIgnored(IERC20 tokenX, IERC20 tokenY, uint256 binStep, bool ignored) external;\n\n    function setPreset(\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        uint16 sampleLifetime\n    ) external;\n\n    function removePreset(uint16 binStep) external;\n\n    function setFeesParametersOnPair(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function setFeeRecipient(address feeRecipient) external;\n\n    function setFlashLoanFee(uint256 flashLoanFee) external;\n\n    function setFactoryLockedState(bool locked) external;\n\n    function addQuoteAsset(IERC20 quoteAsset) external;\n\n    function removeQuoteAsset(IERC20 quoteAsset) external;\n\n    function forceDecay(ILBLegacyPair LBPair) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBLegacyPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBLegacyToken} from \"./ILBLegacyToken.sol\";\n\n/// @title Liquidity Book Pair V2 Interface\n/// @author Trader Joe\n/// @notice Required interface of LBPair contract\ninterface ILBLegacyPair is ILBLegacyToken {\n    /// @dev Structure to store the protocol fees:\n    /// - binStep: The bin step\n    /// - baseFactor: The base factor\n    /// - filterPeriod: The filter period, where the fees stays constant\n    /// - decayPeriod: The decay period, where the fees are halved\n    /// - reductionFactor: The reduction factor, used to calculate the reduction of the accumulator\n    /// - variableFeeControl: The variable fee control, used to control the variable fee, can be 0 to disable them\n    /// - protocolShare: The share of fees sent to protocol\n    /// - maxVolatilityAccumulated: The max value of volatility accumulated\n    /// - volatilityAccumulated: The value of volatility accumulated\n    /// - volatilityReference: The value of volatility reference\n    /// - indexRef: The index reference\n    /// - time: The last time the accumulator was called\n    struct FeeParameters {\n        // 144 lowest bits in slot\n        uint16 binStep;\n        uint16 baseFactor;\n        uint16 filterPeriod;\n        uint16 decayPeriod;\n        uint16 reductionFactor;\n        uint24 variableFeeControl;\n        uint16 protocolShare;\n        uint24 maxVolatilityAccumulated;\n        // 112 highest bits in slot\n        uint24 volatilityAccumulated;\n        uint24 volatilityReference;\n        uint24 indexRef;\n        uint40 time;\n    }\n\n    /// @dev Structure used during swaps to distributes the fees:\n    /// - total: The total amount of fees\n    /// - protocol: The amount of fees reserved for protocol\n    struct FeesDistribution {\n        uint128 total;\n        uint128 protocol;\n    }\n\n    /// @dev Structure to store the reserves of bins:\n    /// - reserveX: The current reserve of tokenX of the bin\n    /// - reserveY: The current reserve of tokenY of the bin\n    struct Bin {\n        uint112 reserveX;\n        uint112 reserveY;\n        uint256 accTokenXPerShare;\n        uint256 accTokenYPerShare;\n    }\n\n    /// @dev Structure to store the information of the pair such as:\n    /// slot0:\n    /// - activeId: The current id used for swaps, this is also linked with the price\n    /// - reserveX: The sum of amounts of tokenX across all bins\n    /// slot1:\n    /// - reserveY: The sum of amounts of tokenY across all bins\n    /// - oracleSampleLifetime: The lifetime of an oracle sample\n    /// - oracleSize: The current size of the oracle, can be increase by users\n    /// - oracleActiveSize: The current active size of the oracle, composed only from non empty data sample\n    /// - oracleLastTimestamp: The current last timestamp at which a sample was added to the circular buffer\n    /// - oracleId: The current id of the oracle\n    /// slot2:\n    /// - feesX: The current amount of fees to distribute in tokenX (total, protocol)\n    /// slot3:\n    /// - feesY: The current amount of fees to distribute in tokenY (total, protocol)\n    struct PairInformation {\n        uint24 activeId;\n        uint136 reserveX;\n        uint136 reserveY;\n        uint16 oracleSampleLifetime;\n        uint16 oracleSize;\n        uint16 oracleActiveSize;\n        uint40 oracleLastTimestamp;\n        uint16 oracleId;\n        FeesDistribution feesX;\n        FeesDistribution feesY;\n    }\n\n    /// @dev Structure to store the debts of users\n    /// - debtX: The tokenX's debt\n    /// - debtY: The tokenY's debt\n    struct Debts {\n        uint256 debtX;\n        uint256 debtY;\n    }\n\n    /// @dev Structure to store fees:\n    /// - tokenX: The amount of fees of token X\n    /// - tokenY: The amount of fees of token Y\n    struct Fees {\n        uint128 tokenX;\n        uint128 tokenY;\n    }\n\n    /// @dev Structure to minting informations:\n    /// - amountXIn: The amount of token X sent\n    /// - amountYIn: The amount of token Y sent\n    /// - amountXAddedToPair: The amount of token X that have been actually added to the pair\n    /// - amountYAddedToPair: The amount of token Y that have been actually added to the pair\n    /// - activeFeeX: Fees X currently generated\n    /// - activeFeeY: Fees Y currently generated\n    /// - totalDistributionX: Total distribution of token X. Should be 1e18 (100%) or 0 (0%)\n    /// - totalDistributionY: Total distribution of token Y. Should be 1e18 (100%) or 0 (0%)\n    /// - id: Id of the current working bin when looping on the distribution array\n    /// - amountX: The amount of token X deposited in the current bin\n    /// - amountY: The amount of token Y deposited in the current bin\n    /// - distributionX: Distribution of token X for the current working bin\n    /// - distributionY: Distribution of token Y for the current working bin\n    struct MintInfo {\n        uint256 amountXIn;\n        uint256 amountYIn;\n        uint256 amountXAddedToPair;\n        uint256 amountYAddedToPair;\n        uint256 activeFeeX;\n        uint256 activeFeeY;\n        uint256 totalDistributionX;\n        uint256 totalDistributionY;\n        uint256 id;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 distributionX;\n        uint256 distributionY;\n    }\n\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        uint256 indexed id,\n        bool swapForY,\n        uint256 amountIn,\n        uint256 amountOut,\n        uint256 volatilityAccumulated,\n        uint256 fees\n    );\n\n    event FlashLoan(address indexed sender, address indexed receiver, IERC20 token, uint256 amount, uint256 fee);\n\n    event CompositionFee(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 feesX, uint256 feesY\n    );\n\n    event DepositedToBin(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 amountX, uint256 amountY\n    );\n\n    event WithdrawnFromBin(\n        address indexed sender, address indexed recipient, uint256 indexed id, uint256 amountX, uint256 amountY\n    );\n\n    event FeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event ProtocolFeesCollected(address indexed sender, address indexed recipient, uint256 amountX, uint256 amountY);\n\n    event OracleSizeIncreased(uint256 previousSize, uint256 newSize);\n\n    function tokenX() external view returns (IERC20);\n\n    function tokenY() external view returns (IERC20);\n\n    function factory() external view returns (address);\n\n    function getReservesAndId() external view returns (uint256 reserveX, uint256 reserveY, uint256 activeId);\n\n    function getGlobalFees()\n        external\n        view\n        returns (uint128 feesXTotal, uint128 feesYTotal, uint128 feesXProtocol, uint128 feesYProtocol);\n\n    function getOracleParameters()\n        external\n        view\n        returns (\n            uint256 oracleSampleLifetime,\n            uint256 oracleSize,\n            uint256 oracleActiveSize,\n            uint256 oracleLastTimestamp,\n            uint256 oracleId,\n            uint256 min,\n            uint256 max\n        );\n\n    function getOracleSampleFrom(uint256 timeDelta)\n        external\n        view\n        returns (uint256 cumulativeId, uint256 cumulativeAccumulator, uint256 cumulativeBinCrossed);\n\n    function feeParameters() external view returns (FeeParameters memory);\n\n    function findFirstNonEmptyBinId(uint24 id_, bool sentTokenY) external view returns (uint24 id);\n\n    function getBin(uint24 id) external view returns (uint256 reserveX, uint256 reserveY);\n\n    function pendingFees(address account, uint256[] memory ids)\n        external\n        view\n        returns (uint256 amountX, uint256 amountY);\n\n    function swap(bool sentTokenY, address to) external returns (uint256 amountXOut, uint256 amountYOut);\n\n    function flashLoan(address receiver, IERC20 token, uint256 amount, bytes calldata data) external;\n\n    function mint(\n        uint256[] calldata ids,\n        uint256[] calldata distributionX,\n        uint256[] calldata distributionY,\n        address to\n    ) external returns (uint256 amountXAddedToPair, uint256 amountYAddedToPair, uint256[] memory liquidityMinted);\n\n    function burn(uint256[] calldata ids, uint256[] calldata amounts, address to)\n        external\n        returns (uint256 amountX, uint256 amountY);\n\n    function increaseOracleLength(uint16 newSize) external;\n\n    function collectFees(address account, uint256[] calldata ids) external returns (uint256 amountX, uint256 amountY);\n\n    function collectProtocolFees() external returns (uint128 amountX, uint128 amountY);\n\n    function setFeesParameters(bytes32 packedFeeParameters) external;\n\n    function forceDecay() external;\n\n    function initialize(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint24 activeId,\n        uint16 sampleLifetime,\n        bytes32 packedFeeParameters\n    ) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBLegacyRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {IJoeFactory} from \"./IJoeFactory.sol\";\nimport {ILBLegacyPair} from \"./ILBLegacyPair.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\nimport {IWNATIVE} from \"./IWNATIVE.sol\";\n\n/// @title Liquidity Book Router Interface\n/// @author Trader Joe\n/// @notice Required interface of LBRouter contract\ninterface ILBLegacyRouter {\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        uint256 deadline;\n    }\n\n    function factory() external view returns (address);\n\n    function wavax() external view returns (address);\n\n    function oldFactory() external view returns (address);\n\n    function getIdFromPrice(ILBLegacyPair LBPair, uint256 price) external view returns (uint24);\n\n    function getPriceFromId(ILBLegacyPair LBPair, uint24 id) external view returns (uint256);\n\n    function getSwapIn(ILBLegacyPair lbPair, uint256 amountOut, bool swapForY)\n        external\n        view\n        returns (uint256 amountIn, uint256 feesIn);\n\n    function getSwapOut(ILBLegacyPair lbPair, uint256 amountIn, bool swapForY)\n        external\n        view\n        returns (uint256 amountOut, uint256 feesIn);\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBLegacyPair pair);\n\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function addLiquidityAVAX(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        returns (uint256[] memory depositIds, uint256[] memory liquidityMinted);\n\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function removeLiquidityAVAX(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountAVAXMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountAVAX);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAX(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapTokensForExactAVAX(\n        uint256 amountOut,\n        uint256 amountInMax,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapAVAXForExactTokens(\n        uint256 amountOut,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amountsIn);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForAVAXSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinAVAX,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactAVAXForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        uint256[] memory pairBinSteps,\n        IERC20[] memory tokenPath,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function sweep(IERC20 token, address to, uint256 amount) external;\n\n    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n        external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBLegacyToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/// @title Liquidity Book V2 Token Interface\n/// @author Trader Joe\n/// @notice Required interface of LBToken contract\ninterface ILBLegacyToken is IERC165 {\n    event TransferSingle(address indexed sender, address indexed from, address indexed to, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory batchBalances);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function setApprovalForAll(address sender, bool approved) external;\n\n    function safeTransferFrom(address from, address to, uint256 id, uint256 amount) external;\n\n    function safeBatchTransferFrom(address from, address to, uint256[] calldata id, uint256[] calldata amount)\n        external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {ILBFlashLoanCallback} from \"./ILBFlashLoanCallback.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\n\ninterface ILBPair is ILBToken {\n    error LBPair__ZeroBorrowAmount();\n    error LBPair__AddressZero();\n    error LBPair__AlreadyInitialized();\n    error LBPair__EmptyMarketConfigs();\n    error LBPair__FlashLoanCallbackFailed();\n    error LBPair__FlashLoanInsufficientAmount();\n    error LBPair__InsufficientAmountIn();\n    error LBPair__InsufficientAmountOut();\n    error LBPair__InvalidInput();\n    error LBPair__InvalidStaticFeeParameters();\n    error LBPair__OnlyFactory();\n    error LBPair__OnlyProtocolFeeRecipient();\n    error LBPair__OutOfLiquidity();\n    error LBPair__TokenNotSupported();\n    error LBPair__ZeroAmount(uint24 id);\n    error LBPair__ZeroAmountsOut(uint24 id);\n    error LBPair__ZeroShares(uint24 id);\n    error LBPair__MaxTotalFeeExceeded();\n\n    struct MintArrays {\n        uint256[] ids;\n        bytes32[] amounts;\n        uint256[] liquidityMinted;\n    }\n\n    event DepositedToBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\n\n    event WithdrawnFromBins(address indexed sender, address indexed to, uint256[] ids, bytes32[] amounts);\n\n    event CompositionFees(address indexed sender, uint24 id, bytes32 totalFees, bytes32 protocolFees);\n\n    event CollectedProtocolFees(address indexed feeRecipient, bytes32 protocolFees);\n\n    event Swap(\n        address indexed sender,\n        address indexed to,\n        uint24 id,\n        bytes32 amountsIn,\n        bytes32 amountsOut,\n        uint24 volatilityAccumulator,\n        bytes32 totalFees,\n        bytes32 protocolFees\n    );\n\n    event StaticFeeParametersSet(\n        address indexed sender,\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    );\n\n    event FlashLoan(\n        address indexed sender,\n        ILBFlashLoanCallback indexed receiver,\n        uint24 activeId,\n        bytes32 amounts,\n        bytes32 totalFees,\n        bytes32 protocolFees\n    );\n\n    event OracleLengthIncreased(address indexed sender, uint16 oracleLength);\n\n    event ForcedDecay(address indexed sender, uint24 idReference, uint24 volatilityReference);\n\n    function initialize(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator,\n        uint24 activeId\n    ) external;\n\n    function getFactory() external view returns (ILBFactory factory);\n\n    function getTokenX() external view returns (IERC20 tokenX);\n\n    function getTokenY() external view returns (IERC20 tokenY);\n\n    function getBinStep() external view returns (uint16 binStep);\n\n    function getReserves() external view returns (uint128 reserveX, uint128 reserveY);\n\n    function getActiveId() external view returns (uint24 activeId);\n\n    function getBin(uint24 id) external view returns (uint128 binReserveX, uint128 binReserveY);\n\n    function getNextNonEmptyBin(bool swapForY, uint24 id) external view returns (uint24 nextId);\n\n    function getProtocolFees() external view returns (uint128 protocolFeeX, uint128 protocolFeeY);\n\n    function getStaticFeeParameters()\n        external\n        view\n        returns (\n            uint16 baseFactor,\n            uint16 filterPeriod,\n            uint16 decayPeriod,\n            uint16 reductionFactor,\n            uint24 variableFeeControl,\n            uint16 protocolShare,\n            uint24 maxVolatilityAccumulator\n        );\n\n    function getLBHooksParameters() external view returns (bytes32 hooksParameters);\n\n    function getVariableFeeParameters()\n        external\n        view\n        returns (uint24 volatilityAccumulator, uint24 volatilityReference, uint24 idReference, uint40 timeOfLastUpdate);\n\n    function getOracleParameters()\n        external\n        view\n        returns (uint8 sampleLifetime, uint16 size, uint16 activeSize, uint40 lastUpdated, uint40 firstTimestamp);\n\n    function getOracleSampleAt(uint40 lookupTimestamp)\n        external\n        view\n        returns (uint64 cumulativeId, uint64 cumulativeVolatility, uint64 cumulativeBinCrossed);\n\n    function getPriceFromId(uint24 id) external view returns (uint256 price);\n\n    function getIdFromPrice(uint256 price) external view returns (uint24 id);\n\n    function getSwapIn(uint128 amountOut, bool swapForY)\n        external\n        view\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n\n    function getSwapOut(uint128 amountIn, bool swapForY)\n        external\n        view\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n\n    function swap(bool swapForY, address to) external returns (bytes32 amountsOut);\n\n    function flashLoan(ILBFlashLoanCallback receiver, bytes32 amounts, bytes calldata data) external;\n\n    function mint(address to, bytes32[] calldata liquidityConfigs, address refundTo)\n        external\n        returns (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted);\n\n    function burn(address from, address to, uint256[] calldata ids, uint256[] calldata amountsToBurn)\n        external\n        returns (bytes32[] memory amounts);\n\n    function collectProtocolFees() external returns (bytes32 collectedProtocolFees);\n\n    function increaseOracleLength(uint16 newLength) external;\n\n    function setStaticFeeParameters(\n        uint16 baseFactor,\n        uint16 filterPeriod,\n        uint16 decayPeriod,\n        uint16 reductionFactor,\n        uint24 variableFeeControl,\n        uint16 protocolShare,\n        uint24 maxVolatilityAccumulator\n    ) external;\n\n    function forceDecay() external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IJoeFactory} from \"./IJoeFactory.sol\";\nimport {ILBFactory} from \"./ILBFactory.sol\";\nimport {ILBLegacyFactory} from \"./ILBLegacyFactory.sol\";\nimport {ILBLegacyRouter} from \"./ILBLegacyRouter.sol\";\nimport {ILBPair} from \"./ILBPair.sol\";\nimport {ILBToken} from \"./ILBToken.sol\";\nimport {IWNATIVE} from \"./IWNATIVE.sol\";\n\n/**\n * @title Liquidity Book Router Interface\n * @author Trader Joe\n * @notice Required interface of LBRouter contract\n */\ninterface ILBRouter {\n    error LBRouter__SenderIsNotWNATIVE();\n    error LBRouter__PairNotCreated(address tokenX, address tokenY, uint256 binStep);\n    error LBRouter__WrongAmounts(uint256 amount, uint256 reserve);\n    error LBRouter__SwapOverflows(uint256 id);\n    error LBRouter__BrokenSwapSafetyCheck();\n    error LBRouter__NotFactoryOwner();\n    error LBRouter__TooMuchTokensIn(uint256 excess);\n    error LBRouter__BinReserveOverflows(uint256 id);\n    error LBRouter__IdOverflows(int256 id);\n    error LBRouter__LengthsMismatch();\n    error LBRouter__WrongTokenOrder();\n    error LBRouter__IdSlippageCaught(uint256 activeIdDesired, uint256 idSlippage, uint256 activeId);\n    error LBRouter__AmountSlippageCaught(uint256 amountXMin, uint256 amountX, uint256 amountYMin, uint256 amountY);\n    error LBRouter__IdDesiredOverflows(uint256 idDesired, uint256 idSlippage);\n    error LBRouter__FailedToSendNATIVE(address recipient, uint256 amount);\n    error LBRouter__DeadlineExceeded(uint256 deadline, uint256 currentTimestamp);\n    error LBRouter__AmountSlippageBPTooBig(uint256 amountSlippage);\n    error LBRouter__InsufficientAmountOut(uint256 amountOutMin, uint256 amountOut);\n    error LBRouter__MaxAmountInExceeded(uint256 amountInMax, uint256 amountIn);\n    error LBRouter__InvalidTokenPath(address wrongToken);\n    error LBRouter__InvalidVersion(uint256 version);\n    error LBRouter__WrongNativeLiquidityParameters(\n        address tokenX, address tokenY, uint256 amountX, uint256 amountY, uint256 msgValue\n    );\n\n    /**\n     * @dev This enum represents the version of the pair requested\n     * - V1: Joe V1 pair\n     * - V2: LB pair V2. Also called legacyPair\n     * - V2_1: LB pair V2.1\n     * - V2_2: LB pair V2.2 (current version)\n     */\n    enum Version {\n        V1,\n        V2,\n        V2_1,\n        V2_2\n    }\n\n    /**\n     * @dev The liquidity parameters, such as:\n     * - tokenX: The address of token X\n     * - tokenY: The address of token Y\n     * - binStep: The bin step of the pair\n     * - amountX: The amount to send of token X\n     * - amountY: The amount to send of token Y\n     * - amountXMin: The min amount of token X added to liquidity\n     * - amountYMin: The min amount of token Y added to liquidity\n     * - activeIdDesired: The active id that user wants to add liquidity from\n     * - idSlippage: The number of id that are allowed to slip\n     * - deltaIds: The list of delta ids to add liquidity (`deltaId = activeId - desiredId`)\n     * - distributionX: The distribution of tokenX with sum(distributionX) = 1e18 (100%) or 0 (0%)\n     * - distributionY: The distribution of tokenY with sum(distributionY) = 1e18 (100%) or 0 (0%)\n     * - to: The address of the recipient\n     * - refundTo: The address of the recipient of the refunded tokens if too much tokens are sent\n     * - deadline: The deadline of the transaction\n     */\n    struct LiquidityParameters {\n        IERC20 tokenX;\n        IERC20 tokenY;\n        uint256 binStep;\n        uint256 amountX;\n        uint256 amountY;\n        uint256 amountXMin;\n        uint256 amountYMin;\n        uint256 activeIdDesired;\n        uint256 idSlippage;\n        int256[] deltaIds;\n        uint256[] distributionX;\n        uint256[] distributionY;\n        address to;\n        address refundTo;\n        uint256 deadline;\n    }\n\n    /**\n     * @dev The path parameters, such as:\n     * - pairBinSteps: The list of bin steps of the pairs to go through\n     * - versions: The list of versions of the pairs to go through\n     * - tokenPath: The list of tokens in the path to go through\n     */\n    struct Path {\n        uint256[] pairBinSteps;\n        Version[] versions;\n        IERC20[] tokenPath;\n    }\n\n    function getFactory() external view returns (ILBFactory);\n\n    function getFactoryV2_1() external view returns (ILBFactory);\n\n    function getLegacyFactory() external view returns (ILBLegacyFactory);\n\n    function getV1Factory() external view returns (IJoeFactory);\n\n    function getLegacyRouter() external view returns (ILBLegacyRouter);\n\n    function getWNATIVE() external view returns (IWNATIVE);\n\n    function getIdFromPrice(ILBPair LBPair, uint256 price) external view returns (uint24);\n\n    function getPriceFromId(ILBPair LBPair, uint24 id) external view returns (uint256);\n\n    function getSwapIn(ILBPair LBPair, uint128 amountOut, bool swapForY)\n        external\n        view\n        returns (uint128 amountIn, uint128 amountOutLeft, uint128 fee);\n\n    function getSwapOut(ILBPair LBPair, uint128 amountIn, bool swapForY)\n        external\n        view\n        returns (uint128 amountInLeft, uint128 amountOut, uint128 fee);\n\n    function createLBPair(IERC20 tokenX, IERC20 tokenY, uint24 activeId, uint16 binStep)\n        external\n        returns (ILBPair pair);\n\n    function addLiquidity(LiquidityParameters calldata liquidityParameters)\n        external\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        );\n\n    function addLiquidityNATIVE(LiquidityParameters calldata liquidityParameters)\n        external\n        payable\n        returns (\n            uint256 amountXAdded,\n            uint256 amountYAdded,\n            uint256 amountXLeft,\n            uint256 amountYLeft,\n            uint256[] memory depositIds,\n            uint256[] memory liquidityMinted\n        );\n\n    function removeLiquidity(\n        IERC20 tokenX,\n        IERC20 tokenY,\n        uint16 binStep,\n        uint256 amountXMin,\n        uint256 amountYMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountX, uint256 amountY);\n\n    function removeLiquidityNATIVE(\n        IERC20 token,\n        uint16 binStep,\n        uint256 amountTokenMin,\n        uint256 amountNATIVEMin,\n        uint256[] memory ids,\n        uint256[] memory amounts,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountToken, uint256 amountNATIVE);\n\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForNATIVE(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactNATIVEForTokens(uint256 amountOutMin, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256 amountOut);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapTokensForExactNATIVE(\n        uint256 amountOut,\n        uint256 amountInMax,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256[] memory amountsIn);\n\n    function swapNATIVEForExactTokens(uint256 amountOut, Path memory path, address to, uint256 deadline)\n        external\n        payable\n        returns (uint256[] memory amountsIn);\n\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactTokensForNATIVESupportingFeeOnTransferTokens(\n        uint256 amountIn,\n        uint256 amountOutMinNATIVE,\n        Path memory path,\n        address payable to,\n        uint256 deadline\n    ) external returns (uint256 amountOut);\n\n    function swapExactNATIVEForTokensSupportingFeeOnTransferTokens(\n        uint256 amountOutMin,\n        Path memory path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256 amountOut);\n\n    function sweep(IERC20 token, address to, uint256 amount) external;\n\n    function sweepLBToken(ILBToken _lbToken, address _to, uint256[] calldata _ids, uint256[] calldata _amounts)\n        external;\n}\n"
    },
    "contracts/interfaces/joe-v2/ILBToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Token Interface\n * @author Trader Joe\n * @notice Interface to interact with the LBToken.\n */\ninterface ILBToken {\n    error LBToken__AddressThisOrZero();\n    error LBToken__InvalidLength();\n    error LBToken__SelfApproval(address owner);\n    error LBToken__SpenderNotApproved(address from, address spender);\n    error LBToken__TransferExceedsBalance(address from, uint256 id, uint256 amount);\n    error LBToken__BurnExceedsBalance(address from, uint256 id, uint256 amount);\n\n    event TransferBatch(\n        address indexed sender, address indexed from, address indexed to, uint256[] ids, uint256[] amounts\n    );\n\n    event ApprovalForAll(address indexed account, address indexed sender, bool approved);\n\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function totalSupply(uint256 id) external view returns (uint256);\n\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    function isApprovedForAll(address owner, address spender) external view returns (bool);\n\n    function approveForAll(address spender, bool approved) external;\n\n    function batchTransferFrom(address from, address to, uint256[] calldata ids, uint256[] calldata amounts) external;\n}\n"
    },
    "contracts/interfaces/joe-v2/IPendingOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Pending Ownable Interface\n * @author Trader Joe\n * @notice Required interface of Pending Ownable contract used for LBFactory\n */\ninterface IPendingOwnable {\n    error PendingOwnable__AddressZero();\n    error PendingOwnable__NoPendingOwner();\n    error PendingOwnable__NotOwner();\n    error PendingOwnable__NotPendingOwner();\n    error PendingOwnable__PendingOwnerAlreadySet();\n\n    event PendingOwnerSet(address indexed pendingOwner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    function owner() external view returns (address);\n\n    function pendingOwner() external view returns (address);\n\n    function setPendingOwner(address pendingOwner) external;\n\n    function revokePendingOwner() external;\n\n    function becomeOwner() external;\n\n    function renounceOwnership() external;\n}\n"
    },
    "contracts/interfaces/joe-v2/IWNATIVE.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/**\n * @title WNATIVE Interface\n * @notice Required interface of Wrapped NATIVE contract\n */\ninterface IWNATIVE is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256) external;\n}\n"
    },
    "contracts/lib/joe-v2/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Constants Library\n * @author Trader Joe\n * @notice Set of constants for Liquidity Book contracts\n */\nlibrary Constants {\n    uint8 internal constant SCALE_OFFSET = 128;\n    uint256 internal constant SCALE = 1 << SCALE_OFFSET;\n\n    uint256 internal constant PRECISION = 1e18;\n    uint256 internal constant SQUARED_PRECISION = PRECISION * PRECISION;\n\n    uint256 internal constant MAX_FEE = 0.1e18; // 10%\n    uint256 internal constant MAX_PROTOCOL_SHARE = 2_500; // 25% of the fee\n\n    uint256 internal constant BASIS_POINT_MAX = 10_000;\n\n    /// @dev The expected return after a successful flash loan\n    bytes32 internal constant CALLBACK_SUCCESS = keccak256(\"LBPair.onFlashLoan\");\n}\n"
    },
    "contracts/lib/joe-v2/math/BitMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Bit Math Library\n * @author Trader Joe\n * @notice Helper contract used for bit calculations\n */\nlibrary BitMath {\n    /**\n     * @dev Returns the index of the closest bit on the right of x that is non null\n     * @param x The value as a uint256\n     * @param bit The index of the bit to start searching at\n     * @return id The index of the closest non null bit on the right of x.\n     * If there is no closest bit, it returns max(uint256)\n     */\n    function closestBitRight(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            uint256 shift = 255 - bit;\n            x <<= shift;\n\n            // can't overflow as it's non-zero and we shifted it by `_shift`\n            return (x == 0) ? type(uint256).max : mostSignificantBit(x) - shift;\n        }\n    }\n\n    /**\n     * @dev Returns the index of the closest bit on the left of x that is non null\n     * @param x The value as a uint256\n     * @param bit The index of the bit to start searching at\n     * @return id The index of the closest non null bit on the left of x.\n     * If there is no closest bit, it returns max(uint256)\n     */\n    function closestBitLeft(uint256 x, uint8 bit) internal pure returns (uint256 id) {\n        unchecked {\n            x >>= bit;\n\n            return (x == 0) ? type(uint256).max : leastSignificantBit(x) + bit;\n        }\n    }\n\n    /**\n     * @dev Returns the index of the most significant bit of x\n     * This function returns 0 if x is 0\n     * @param x The value as a uint256\n     * @return msb The index of the most significant bit of x\n     */\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 msb) {\n        assembly {\n            if gt(x, 0xffffffffffffffffffffffffffffffff) {\n                x := shr(128, x)\n                msb := 128\n            }\n            if gt(x, 0xffffffffffffffff) {\n                x := shr(64, x)\n                msb := add(msb, 64)\n            }\n            if gt(x, 0xffffffff) {\n                x := shr(32, x)\n                msb := add(msb, 32)\n            }\n            if gt(x, 0xffff) {\n                x := shr(16, x)\n                msb := add(msb, 16)\n            }\n            if gt(x, 0xff) {\n                x := shr(8, x)\n                msb := add(msb, 8)\n            }\n            if gt(x, 0xf) {\n                x := shr(4, x)\n                msb := add(msb, 4)\n            }\n            if gt(x, 0x3) {\n                x := shr(2, x)\n                msb := add(msb, 2)\n            }\n            if gt(x, 0x1) { msb := add(msb, 1) }\n        }\n    }\n\n    /**\n     * @dev Returns the index of the least significant bit of x\n     * This function returns 255 if x is 0\n     * @param x The value as a uint256\n     * @return lsb The index of the least significant bit of x\n     */\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 lsb) {\n        assembly {\n            let sx := shl(128, x)\n            if iszero(iszero(sx)) {\n                lsb := 128\n                x := sx\n            }\n            sx := shl(64, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 64)\n            }\n            sx := shl(32, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 32)\n            }\n            sx := shl(16, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 16)\n            }\n            sx := shl(8, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 8)\n            }\n            sx := shl(4, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 4)\n            }\n            sx := shl(2, x)\n            if iszero(iszero(sx)) {\n                x := sx\n                lsb := add(lsb, 2)\n            }\n            if iszero(iszero(shl(1, x))) { lsb := add(lsb, 1) }\n\n            lsb := sub(255, lsb)\n        }\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/Encoded.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Encoded Library\n * @author Trader Joe\n * @notice Helper contract used for decoding bytes32 sample\n */\nlibrary Encoded {\n    uint256 internal constant MASK_UINT1 = 0x1;\n    uint256 internal constant MASK_UINT8 = 0xff;\n    uint256 internal constant MASK_UINT12 = 0xfff;\n    uint256 internal constant MASK_UINT14 = 0x3fff;\n    uint256 internal constant MASK_UINT16 = 0xffff;\n    uint256 internal constant MASK_UINT20 = 0xfffff;\n    uint256 internal constant MASK_UINT24 = 0xffffff;\n    uint256 internal constant MASK_UINT40 = 0xffffffffff;\n    uint256 internal constant MASK_UINT64 = 0xffffffffffffffff;\n    uint256 internal constant MASK_UINT128 = 0xffffffffffffffffffffffffffffffff;\n\n    /**\n     * @notice Internal function to set a value in an encoded bytes32 using a mask and offset\n     * @dev This function can overflow\n     * @param encoded The previous encoded value\n     * @param value The value to encode\n     * @param mask The mask\n     * @param offset The offset\n     * @return newEncoded The new encoded value\n     */\n    function set(bytes32 encoded, uint256 value, uint256 mask, uint256 offset)\n        internal\n        pure\n        returns (bytes32 newEncoded)\n    {\n        assembly {\n            newEncoded := and(encoded, not(shl(offset, mask)))\n            newEncoded := or(newEncoded, shl(offset, and(value, mask)))\n        }\n    }\n\n    /**\n     * @notice Internal function to set a bool in an encoded bytes32 using an offset\n     * @dev This function can overflow\n     * @param encoded The previous encoded value\n     * @param boolean The bool to encode\n     * @param offset The offset\n     * @return newEncoded The new encoded value\n     */\n    function setBool(bytes32 encoded, bool boolean, uint256 offset) internal pure returns (bytes32 newEncoded) {\n        return set(encoded, boolean ? 1 : 0, MASK_UINT1, offset);\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample using a mask and offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param mask The mask\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decode(bytes32 encoded, uint256 mask, uint256 offset) internal pure returns (uint256 value) {\n        assembly {\n            value := and(shr(offset, encoded), mask)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a bool using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return boolean The decoded value as a bool\n     */\n    function decodeBool(bytes32 encoded, uint256 offset) internal pure returns (bool boolean) {\n        assembly {\n            boolean := and(shr(offset, encoded), MASK_UINT1)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint8 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint8(bytes32 encoded, uint256 offset) internal pure returns (uint8 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT8)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint12 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint16, since uint12 is not supported\n     */\n    function decodeUint12(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT12)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint14 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint16, since uint14 is not supported\n     */\n    function decodeUint14(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT14)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint16 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint16(bytes32 encoded, uint256 offset) internal pure returns (uint16 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT16)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint20 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value as a uint24, since uint20 is not supported\n     */\n    function decodeUint20(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT20)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint24 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint24(bytes32 encoded, uint256 offset) internal pure returns (uint24 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT24)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint40 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint40(bytes32 encoded, uint256 offset) internal pure returns (uint40 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT40)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint64 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint64(bytes32 encoded, uint256 offset) internal pure returns (uint64 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT64)\n        }\n    }\n\n    /**\n     * @notice Internal function to decode a bytes32 sample into a uint128 using an offset\n     * @dev This function can overflow\n     * @param encoded The encoded value\n     * @param offset The offset\n     * @return value The decoded value\n     */\n    function decodeUint128(bytes32 encoded, uint256 offset) internal pure returns (uint128 value) {\n        assembly {\n            value := and(shr(offset, encoded), MASK_UINT128)\n        }\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/LiquidityConfigurations.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {PackedUint128Math} from \"./PackedUint128Math.sol\";\nimport {Encoded} from \"./Encoded.sol\";\n\n/**\n * @title Liquidity Book Liquidity Configurations Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode the config of a pool and interact with the encoded bytes32.\n */\nlibrary LiquidityConfigurations {\n    using PackedUint128Math for bytes32;\n    using PackedUint128Math for uint128;\n    using Encoded for bytes32;\n\n    error LiquidityConfigurations__InvalidConfig();\n\n    uint256 private constant OFFSET_ID = 0;\n    uint256 private constant OFFSET_DISTRIBUTION_Y = 24;\n    uint256 private constant OFFSET_DISTRIBUTION_X = 88;\n\n    uint256 private constant PRECISION = 1e18;\n\n    /**\n     * @dev Encode the distributionX, distributionY and id into a single bytes32\n     * @param distributionX The distribution of the first token\n     * @param distributionY The distribution of the second token\n     * @param id The id of the pool\n     * @return config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     */\n    function encodeParams(uint64 distributionX, uint64 distributionY, uint24 id)\n        internal\n        pure\n        returns (bytes32 config)\n    {\n        config = config.set(distributionX, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_X);\n        config = config.set(distributionY, Encoded.MASK_UINT64, OFFSET_DISTRIBUTION_Y);\n        config = config.set(id, Encoded.MASK_UINT24, OFFSET_ID);\n    }\n\n    /**\n     * @dev Decode the distributionX, distributionY and id from a single bytes32\n     * @param config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     * @return distributionX The distribution of the first token\n     * @return distributionY The distribution of the second token\n     * @return id The id of the bin to add the liquidity to\n     */\n    function decodeParams(bytes32 config)\n        internal\n        pure\n        returns (uint64 distributionX, uint64 distributionY, uint24 id)\n    {\n        distributionX = config.decodeUint64(OFFSET_DISTRIBUTION_X);\n        distributionY = config.decodeUint64(OFFSET_DISTRIBUTION_Y);\n        id = config.decodeUint24(OFFSET_ID);\n\n        if (uint256(config) > type(uint152).max || distributionX > PRECISION || distributionY > PRECISION) {\n            revert LiquidityConfigurations__InvalidConfig();\n        }\n    }\n\n    /**\n     * @dev Get the amounts and id from a config and amountsIn\n     * @param config The encoded config as follows:\n     * [0 - 24[: id\n     * [24 - 88[: distributionY\n     * [88 - 152[: distributionX\n     * [152 - 256[: empty\n     * @param amountsIn The amounts to distribute as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return amounts The distributed amounts as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return id The id of the bin to add the liquidity to\n     */\n    function getAmountsAndId(bytes32 config, bytes32 amountsIn) internal pure returns (bytes32, uint24) {\n        (uint64 distributionX, uint64 distributionY, uint24 id) = decodeParams(config);\n\n        (uint128 x1, uint128 x2) = amountsIn.decode();\n\n        assembly {\n            x1 := div(mul(x1, distributionX), PRECISION)\n            x2 := div(mul(x2, distributionY), PRECISION)\n        }\n\n        return (x1.encode(x2), id);\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/PackedUint128Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"../Constants.sol\";\n\n/**\n * @title Liquidity Book Packed Uint128 Math Library\n * @author Trader Joe\n * @notice This library contains functions to encode and decode two uint128 into a single bytes32\n * and interact with the encoded bytes32.\n */\nlibrary PackedUint128Math {\n    error PackedUint128Math__AddOverflow();\n    error PackedUint128Math__SubUnderflow();\n    error PackedUint128Math__MultiplierTooLarge();\n\n    uint256 private constant OFFSET = 128;\n    uint256 private constant MASK_128 = 0xffffffffffffffffffffffffffffffff;\n    uint256 private constant MASK_128_PLUS_ONE = MASK_128 + 1;\n\n    /**\n     * @dev Encodes two uint128 into a single bytes32\n     * @param x1 The first uint128\n     * @param x2 The second uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     */\n    function encode(uint128 x1, uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := or(and(x1, MASK_128), shl(OFFSET, x2))\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first uint128\n     * @param x1 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     */\n    function encodeFirst(uint128 x1) internal pure returns (bytes32 z) {\n        assembly {\n            z := and(x1, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the second uint128\n     * @param x2 The uint128\n     * @return z The encoded bytes32 as follows:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     */\n    function encodeSecond(uint128 x2) internal pure returns (bytes32 z) {\n        assembly {\n            z := shl(OFFSET, x2)\n        }\n    }\n\n    /**\n     * @dev Encodes a uint128 into a single bytes32 as the first or second uint128\n     * @param x The uint128\n     * @param first Whether to encode as the first or second uint128\n     * @return z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x\n     */\n    function encode(uint128 x, bool first) internal pure returns (bytes32 z) {\n        return first ? encodeFirst(x) : encodeSecond(x);\n    }\n\n    /**\n     * @dev Decodes a bytes32 into two uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @return x1 The first uint128\n     * @return x2 The second uint128\n     */\n    function decode(bytes32 z) internal pure returns (uint128 x1, uint128 x2) {\n        assembly {\n            x1 := and(z, MASK_128)\n            x2 := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: x\n     * [128 - 256[: any\n     * @return x The first uint128\n     */\n    function decodeX(bytes32 z) internal pure returns (uint128 x) {\n        assembly {\n            x := and(z, MASK_128)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the second uint128\n     * @param z The encoded bytes32 as follows:\n     * [0 - 128[: any\n     * [128 - 256[: y\n     * @return y The second uint128\n     */\n    function decodeY(bytes32 z) internal pure returns (uint128 y) {\n        assembly {\n            y := shr(OFFSET, z)\n        }\n    }\n\n    /**\n     * @dev Decodes a bytes32 into a uint128 as the first or second uint128\n     * @param z The encoded bytes32 as follows:\n     * if first:\n     * [0 - 128[: x1\n     * [128 - 256[: empty\n     * else:\n     * [0 - 128[: empty\n     * [128 - 256[: x2\n     * @param first Whether to decode as the first or second uint128\n     * @return x The decoded uint128\n     */\n    function decode(bytes32 z, bool first) internal pure returns (uint128 x) {\n        return first ? decodeX(z) : decodeY(z);\n    }\n\n    /**\n     * @dev Adds two encoded bytes32, reverting on overflow on any of the uint128\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return z The sum of x and y encoded as follows:\n     * [0 - 128[: x1 + y1\n     * [128 - 256[: x2 + y2\n     */\n    function add(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        assembly {\n            z := add(x, y)\n        }\n\n        if (z < x || uint128(uint256(z)) < uint128(uint256(x))) {\n            revert PackedUint128Math__AddOverflow();\n        }\n    }\n\n    /**\n     * @dev Adds an encoded bytes32 and two uint128, reverting on overflow on any of the uint128\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y1 The first uint128\n     * @param y2 The second uint128\n     * @return z The sum of x and y encoded as follows:\n     * [0 - 128[: x1 + y1\n     * [128 - 256[: x2 + y2\n     */\n    function add(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\n        return add(x, encode(y1, y2));\n    }\n\n    /**\n     * @dev Subtracts two encoded bytes32, reverting on underflow on any of the uint128\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return z The difference of x and y encoded as follows:\n     * [0 - 128[: x1 - y1\n     * [128 - 256[: x2 - y2\n     */\n    function sub(bytes32 x, bytes32 y) internal pure returns (bytes32 z) {\n        assembly {\n            z := sub(x, y)\n        }\n\n        if (z > x || uint128(uint256(z)) > uint128(uint256(x))) {\n            revert PackedUint128Math__SubUnderflow();\n        }\n    }\n\n    /**\n     * @dev Subtracts an encoded bytes32 and two uint128, reverting on underflow on any of the uint128\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y1 The first uint128\n     * @param y2 The second uint128\n     * @return z The difference of x and y encoded as follows:\n     * [0 - 128[: x1 - y1\n     * [128 - 256[: x2 - y2\n     */\n    function sub(bytes32 x, uint128 y1, uint128 y2) internal pure returns (bytes32) {\n        return sub(x, encode(y1, y2));\n    }\n\n    /**\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return x1 < y1 || x2 < y2\n     */\n    function lt(bytes32 x, bytes32 y) internal pure returns (bool) {\n        (uint128 x1, uint128 x2) = decode(x);\n        (uint128 y1, uint128 y2) = decode(y);\n\n        return x1 < y1 || x2 < y2;\n    }\n\n    /**\n     * @dev Returns whether any of the uint128 of x is strictly greater than the corresponding uint128 of y\n     * @param x The first bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param y The second bytes32 encoded as follows:\n     * [0 - 128[: y1\n     * [128 - 256[: y2\n     * @return x1 < y1 || x2 < y2\n     */\n    function gt(bytes32 x, bytes32 y) internal pure returns (bool) {\n        (uint128 x1, uint128 x2) = decode(x);\n        (uint128 y1, uint128 y2) = decode(y);\n\n        return x1 > y1 || x2 > y2;\n    }\n\n    /**\n     * @dev Multiplies an encoded bytes32 by a uint128 then divides the result by 10_000, rounding down\n     * The result can't overflow as the multiplier needs to be smaller or equal to 10_000\n     * @param x The bytes32 encoded as follows:\n     * [0 - 128[: x1\n     * [128 - 256[: x2\n     * @param multiplier The uint128 to multiply by (must be smaller or equal to 10_000)\n     * @return z The product of x and multiplier encoded as follows:\n     * [0 - 128[: floor((x1 * multiplier) / 10_000)\n     * [128 - 256[: floor((x2 * multiplier) / 10_000)\n     */\n    function scalarMulDivBasisPointRoundDown(bytes32 x, uint128 multiplier) internal pure returns (bytes32 z) {\n        if (multiplier == 0) return 0;\n\n        uint256 BASIS_POINT_MAX = Constants.BASIS_POINT_MAX;\n        if (multiplier > BASIS_POINT_MAX) revert PackedUint128Math__MultiplierTooLarge();\n\n        (uint128 x1, uint128 x2) = decode(x);\n\n        assembly {\n            x1 := div(mul(x1, multiplier), BASIS_POINT_MAX)\n            x2 := div(mul(x2, multiplier), BASIS_POINT_MAX)\n        }\n\n        return encode(x1, x2);\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\n/**\n * @title Liquidity Book Safe Cast Library\n * @author Trader Joe\n * @notice This library contains functions to safely cast uint256 to different uint types.\n */\nlibrary SafeCast {\n    error SafeCast__Exceeds248Bits();\n    error SafeCast__Exceeds240Bits();\n    error SafeCast__Exceeds232Bits();\n    error SafeCast__Exceeds224Bits();\n    error SafeCast__Exceeds216Bits();\n    error SafeCast__Exceeds208Bits();\n    error SafeCast__Exceeds200Bits();\n    error SafeCast__Exceeds192Bits();\n    error SafeCast__Exceeds184Bits();\n    error SafeCast__Exceeds176Bits();\n    error SafeCast__Exceeds168Bits();\n    error SafeCast__Exceeds160Bits();\n    error SafeCast__Exceeds152Bits();\n    error SafeCast__Exceeds144Bits();\n    error SafeCast__Exceeds136Bits();\n    error SafeCast__Exceeds128Bits();\n    error SafeCast__Exceeds120Bits();\n    error SafeCast__Exceeds112Bits();\n    error SafeCast__Exceeds104Bits();\n    error SafeCast__Exceeds96Bits();\n    error SafeCast__Exceeds88Bits();\n    error SafeCast__Exceeds80Bits();\n    error SafeCast__Exceeds72Bits();\n    error SafeCast__Exceeds64Bits();\n    error SafeCast__Exceeds56Bits();\n    error SafeCast__Exceeds48Bits();\n    error SafeCast__Exceeds40Bits();\n    error SafeCast__Exceeds32Bits();\n    error SafeCast__Exceeds24Bits();\n    error SafeCast__Exceeds16Bits();\n    error SafeCast__Exceeds8Bits();\n\n    /**\n     * @dev Returns x on uint248 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint248\n     */\n    function safe248(uint256 x) internal pure returns (uint248 y) {\n        if ((y = uint248(x)) != x) revert SafeCast__Exceeds248Bits();\n    }\n\n    /**\n     * @dev Returns x on uint240 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint240\n     */\n    function safe240(uint256 x) internal pure returns (uint240 y) {\n        if ((y = uint240(x)) != x) revert SafeCast__Exceeds240Bits();\n    }\n\n    /**\n     * @dev Returns x on uint232 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint232\n     */\n    function safe232(uint256 x) internal pure returns (uint232 y) {\n        if ((y = uint232(x)) != x) revert SafeCast__Exceeds232Bits();\n    }\n\n    /**\n     * @dev Returns x on uint224 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint224\n     */\n    function safe224(uint256 x) internal pure returns (uint224 y) {\n        if ((y = uint224(x)) != x) revert SafeCast__Exceeds224Bits();\n    }\n\n    /**\n     * @dev Returns x on uint216 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint216\n     */\n    function safe216(uint256 x) internal pure returns (uint216 y) {\n        if ((y = uint216(x)) != x) revert SafeCast__Exceeds216Bits();\n    }\n\n    /**\n     * @dev Returns x on uint208 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint208\n     */\n    function safe208(uint256 x) internal pure returns (uint208 y) {\n        if ((y = uint208(x)) != x) revert SafeCast__Exceeds208Bits();\n    }\n\n    /**\n     * @dev Returns x on uint200 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint200\n     */\n    function safe200(uint256 x) internal pure returns (uint200 y) {\n        if ((y = uint200(x)) != x) revert SafeCast__Exceeds200Bits();\n    }\n\n    /**\n     * @dev Returns x on uint192 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint192\n     */\n    function safe192(uint256 x) internal pure returns (uint192 y) {\n        if ((y = uint192(x)) != x) revert SafeCast__Exceeds192Bits();\n    }\n\n    /**\n     * @dev Returns x on uint184 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint184\n     */\n    function safe184(uint256 x) internal pure returns (uint184 y) {\n        if ((y = uint184(x)) != x) revert SafeCast__Exceeds184Bits();\n    }\n\n    /**\n     * @dev Returns x on uint176 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint176\n     */\n    function safe176(uint256 x) internal pure returns (uint176 y) {\n        if ((y = uint176(x)) != x) revert SafeCast__Exceeds176Bits();\n    }\n\n    /**\n     * @dev Returns x on uint168 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint168\n     */\n    function safe168(uint256 x) internal pure returns (uint168 y) {\n        if ((y = uint168(x)) != x) revert SafeCast__Exceeds168Bits();\n    }\n\n    /**\n     * @dev Returns x on uint160 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint160\n     */\n    function safe160(uint256 x) internal pure returns (uint160 y) {\n        if ((y = uint160(x)) != x) revert SafeCast__Exceeds160Bits();\n    }\n\n    /**\n     * @dev Returns x on uint152 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint152\n     */\n    function safe152(uint256 x) internal pure returns (uint152 y) {\n        if ((y = uint152(x)) != x) revert SafeCast__Exceeds152Bits();\n    }\n\n    /**\n     * @dev Returns x on uint144 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint144\n     */\n    function safe144(uint256 x) internal pure returns (uint144 y) {\n        if ((y = uint144(x)) != x) revert SafeCast__Exceeds144Bits();\n    }\n\n    /**\n     * @dev Returns x on uint136 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint136\n     */\n    function safe136(uint256 x) internal pure returns (uint136 y) {\n        if ((y = uint136(x)) != x) revert SafeCast__Exceeds136Bits();\n    }\n\n    /**\n     * @dev Returns x on uint128 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint128\n     */\n    function safe128(uint256 x) internal pure returns (uint128 y) {\n        if ((y = uint128(x)) != x) revert SafeCast__Exceeds128Bits();\n    }\n\n    /**\n     * @dev Returns x on uint120 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint120\n     */\n    function safe120(uint256 x) internal pure returns (uint120 y) {\n        if ((y = uint120(x)) != x) revert SafeCast__Exceeds120Bits();\n    }\n\n    /**\n     * @dev Returns x on uint112 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint112\n     */\n    function safe112(uint256 x) internal pure returns (uint112 y) {\n        if ((y = uint112(x)) != x) revert SafeCast__Exceeds112Bits();\n    }\n\n    /**\n     * @dev Returns x on uint104 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint104\n     */\n    function safe104(uint256 x) internal pure returns (uint104 y) {\n        if ((y = uint104(x)) != x) revert SafeCast__Exceeds104Bits();\n    }\n\n    /**\n     * @dev Returns x on uint96 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint96\n     */\n    function safe96(uint256 x) internal pure returns (uint96 y) {\n        if ((y = uint96(x)) != x) revert SafeCast__Exceeds96Bits();\n    }\n\n    /**\n     * @dev Returns x on uint88 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint88\n     */\n    function safe88(uint256 x) internal pure returns (uint88 y) {\n        if ((y = uint88(x)) != x) revert SafeCast__Exceeds88Bits();\n    }\n\n    /**\n     * @dev Returns x on uint80 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint80\n     */\n    function safe80(uint256 x) internal pure returns (uint80 y) {\n        if ((y = uint80(x)) != x) revert SafeCast__Exceeds80Bits();\n    }\n\n    /**\n     * @dev Returns x on uint72 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint72\n     */\n    function safe72(uint256 x) internal pure returns (uint72 y) {\n        if ((y = uint72(x)) != x) revert SafeCast__Exceeds72Bits();\n    }\n\n    /**\n     * @dev Returns x on uint64 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint64\n     */\n    function safe64(uint256 x) internal pure returns (uint64 y) {\n        if ((y = uint64(x)) != x) revert SafeCast__Exceeds64Bits();\n    }\n\n    /**\n     * @dev Returns x on uint56 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint56\n     */\n    function safe56(uint256 x) internal pure returns (uint56 y) {\n        if ((y = uint56(x)) != x) revert SafeCast__Exceeds56Bits();\n    }\n\n    /**\n     * @dev Returns x on uint48 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint48\n     */\n    function safe48(uint256 x) internal pure returns (uint48 y) {\n        if ((y = uint48(x)) != x) revert SafeCast__Exceeds48Bits();\n    }\n\n    /**\n     * @dev Returns x on uint40 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint40\n     */\n    function safe40(uint256 x) internal pure returns (uint40 y) {\n        if ((y = uint40(x)) != x) revert SafeCast__Exceeds40Bits();\n    }\n\n    /**\n     * @dev Returns x on uint32 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint32\n     */\n    function safe32(uint256 x) internal pure returns (uint32 y) {\n        if ((y = uint32(x)) != x) revert SafeCast__Exceeds32Bits();\n    }\n\n    /**\n     * @dev Returns x on uint24 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint24\n     */\n    function safe24(uint256 x) internal pure returns (uint24 y) {\n        if ((y = uint24(x)) != x) revert SafeCast__Exceeds24Bits();\n    }\n\n    /**\n     * @dev Returns x on uint16 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint16\n     */\n    function safe16(uint256 x) internal pure returns (uint16 y) {\n        if ((y = uint16(x)) != x) revert SafeCast__Exceeds16Bits();\n    }\n\n    /**\n     * @dev Returns x on uint8 and check that it does not overflow\n     * @param x The value as an uint256\n     * @return y The value as an uint8\n     */\n    function safe8(uint256 x) internal pure returns (uint8 y) {\n        if ((y = uint8(x)) != x) revert SafeCast__Exceeds8Bits();\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/Uint128x128Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Constants} from \"../Constants.sol\";\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Uint128x128 Math Library\n * @author Trader Joe\n * @notice Helper contract used for power and log calculations\n */\nlibrary Uint128x128Math {\n    using BitMath for uint256;\n\n    error Uint128x128Math__LogUnderflow();\n    error Uint128x128Math__PowUnderflow(uint256 x, int256 y);\n\n    uint256 constant LOG_SCALE_OFFSET = 127;\n    uint256 constant LOG_SCALE = 1 << LOG_SCALE_OFFSET;\n    uint256 constant LOG_SCALE_SQUARED = LOG_SCALE * LOG_SCALE;\n\n    /**\n     * @notice Calculates the binary logarithm of x.\n     * @dev Based on the iterative approximation algorithm.\n     * https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n     * Requirements:\n     * - x must be greater than zero.\n     * Caveats:\n     * - The results are not perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation\n     * Also because x is converted to an unsigned 129.127-binary fixed-point number during the operation to optimize the multiplication\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the binary logarithm.\n     * @return result The binary logarithm as a signed 128.128-binary fixed-point number.\n     */\n    function log2(uint256 x) internal pure returns (int256 result) {\n        // Convert x to a unsigned 129.127-binary fixed-point number to optimize the multiplication.\n        // If we use an offset of 128 bits, y would need 129 bits and y**2 would would overflow and we would have to\n        // use mulDiv, by reducing x to 129.127-binary fixed-point number we assert that y will use 128 bits, and we\n        // can use the regular multiplication\n\n        if (x == 1) return -128;\n        if (x == 0) revert Uint128x128Math__LogUnderflow();\n\n        x >>= 1;\n\n        unchecked {\n            // This works because log2(x) = -log2(1/x).\n            int256 sign;\n            if (x >= LOG_SCALE) {\n                sign = 1;\n            } else {\n                sign = -1;\n                // Do the fixed-point inversion inline to save gas\n                x = LOG_SCALE_SQUARED / x;\n            }\n\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = (x >> LOG_SCALE_OFFSET).mostSignificantBit();\n\n            // The integer part of the logarithm as a signed 129.127-binary fixed-point number. The operation can't overflow\n            // because n is maximum 255, LOG_SCALE_OFFSET is 127 bits and sign is either 1 or -1.\n            result = int256(n) << LOG_SCALE_OFFSET;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y != LOG_SCALE) {\n                // Calculate the fractional part via the iterative approximation.\n                // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n                for (int256 delta = int256(1 << (LOG_SCALE_OFFSET - 1)); delta > 0; delta >>= 1) {\n                    y = (y * y) >> LOG_SCALE_OFFSET;\n\n                    // Is y^2 > 2 and so in the range [2,4)?\n                    if (y >= 1 << (LOG_SCALE_OFFSET + 1)) {\n                        // Add the 2^(-m) factor to the logarithm.\n                        result += delta;\n\n                        // Corresponds to z/2 on Wikipedia.\n                        y >>= 1;\n                    }\n                }\n            }\n            // Convert x back to unsigned 128.128-binary fixed-point number\n            result = (result * sign) << 1;\n        }\n    }\n\n    /**\n     * @notice Returns the value of x^y. It calculates `1 / x^abs(y)` if x is bigger than 2^128.\n     * At the end of the operations, we invert the result if needed.\n     * @param x The unsigned 128.128-binary fixed-point number for which to calculate the power\n     * @param y A relative number without any decimals, needs to be between ]2^21; 2^21[\n     */\n    function pow(uint256 x, int256 y) internal pure returns (uint256 result) {\n        bool invert;\n        uint256 absY;\n\n        if (y == 0) return Constants.SCALE;\n\n        assembly {\n            absY := y\n            if slt(absY, 0) {\n                absY := sub(0, absY)\n                invert := iszero(invert)\n            }\n        }\n\n        if (absY < 0x100000) {\n            result = Constants.SCALE;\n            assembly {\n                let squared := x\n                if gt(x, 0xffffffffffffffffffffffffffffffff) {\n                    squared := div(not(0), squared)\n                    invert := iszero(invert)\n                }\n\n                if and(absY, 0x1) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x2) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x4) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x8) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x10) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x20) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x40) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x80) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x100) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x200) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x400) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x800) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x1000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x2000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x4000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x8000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x10000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x20000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x40000) { result := shr(128, mul(result, squared)) }\n                squared := shr(128, mul(squared, squared))\n                if and(absY, 0x80000) { result := shr(128, mul(result, squared)) }\n            }\n        }\n\n        // revert if y is too big or if x^y underflowed\n        if (result == 0) revert Uint128x128Math__PowUnderflow(x, y);\n\n        return invert ? type(uint256).max / result : result;\n    }\n}\n"
    },
    "contracts/lib/joe-v2/math/Uint256x256Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {BitMath} from \"./BitMath.sol\";\n\n/**\n * @title Liquidity Book Uint256x256 Math Library\n * @author Trader Joe\n * @notice Helper contract used for full precision calculations\n */\nlibrary Uint256x256Math {\n    error Uint256x256Math__MulShiftOverflow();\n    error Uint256x256Math__MulDivOverflow();\n\n    /**\n     * @notice Calculates floor(x*y/denominator) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundDown(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        return _getEndOfDivRoundDown(x, y, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x*y/denominator) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The denominator cannot be zero\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function mulDivRoundUp(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        result = mulDivRoundDown(x, y, denominator);\n        if (mulmod(x, y, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundDown(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        (uint256 prod0, uint256 prod1) = _getMulProds(x, y);\n\n        if (prod0 != 0) result = prod0 >> offset;\n        if (prod1 != 0) {\n            // Make sure the result is less than 2^256.\n            if (prod1 >= 1 << offset) revert Uint256x256Math__MulShiftOverflow();\n\n            unchecked {\n                result += prod1 << (256 - offset);\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates floor(x * y / 2**offset) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param offset The offset as an uint256, can't be greater than 256\n     * @return result The result as an uint256\n     */\n    function mulShiftRoundUp(uint256 x, uint256 y, uint8 offset) internal pure returns (uint256 result) {\n        result = mulShiftRoundDown(x, y, offset);\n        if (mulmod(x, y, 1 << offset) != 0) result += 1;\n    }\n\n    /**\n     * @notice Calculates floor(x << offset / y) with full precision\n     * The result will be rounded down\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundDown(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n\n        prod0 = x << offset; // Least significant 256 bits of the product\n        unchecked {\n            prod1 = x >> (256 - offset); // Most significant 256 bits of the product\n        }\n\n        return _getEndOfDivRoundDown(x, 1 << offset, denominator, prod0, prod1);\n    }\n\n    /**\n     * @notice Calculates ceil(x << offset / y) with full precision\n     * The result will be rounded up\n     * @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n     * Requirements:\n     * - The offset needs to be strictly lower than 256\n     * - The result must fit within uint256\n     * Caveats:\n     * - This function does not work with fixed-point numbers\n     * @param x The multiplicand as an uint256\n     * @param offset The number of bit to shift x as an uint256\n     * @param denominator The divisor as an uint256\n     * @return result The result as an uint256\n     */\n    function shiftDivRoundUp(uint256 x, uint8 offset, uint256 denominator) internal pure returns (uint256 result) {\n        result = shiftDivRoundDown(x, offset, denominator);\n        if (mulmod(x, 1 << offset, denominator) != 0) result += 1;\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y` as 2 uint256\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @return prod0 The least significant 256 bits of the product\n     * @return prod1 The most significant 256 bits of the product\n     */\n    function _getMulProds(uint256 x, uint256 y) private pure returns (uint256 prod0, uint256 prod1) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n    }\n\n    /**\n     * @notice Helper function to return the result of `x * y / denominator` with full precision\n     * @param x The multiplicand as an uint256\n     * @param y The multiplier as an uint256\n     * @param denominator The divisor as an uint256\n     * @param prod0 The least significant 256 bits of the product\n     * @param prod1 The most significant 256 bits of the product\n     * @return result The result as an uint256\n     */\n    function _getEndOfDivRoundDown(uint256 x, uint256 y, uint256 denominator, uint256 prod0, uint256 prod1)\n        private\n        pure\n        returns (uint256 result)\n    {\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n        } else {\n            // Make sure the result is less than 2^256. Also prevents denominator == 0\n            if (prod1 >= denominator) revert Uint256x256Math__MulDivOverflow();\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1\n            // See https://cs.stackexchange.com/q/138556/92363\n            unchecked {\n                // Does not overflow because the denominator cannot be zero at this stage in the function\n                uint256 lpotdod = denominator & (~denominator + 1);\n                assembly {\n                    // Divide denominator by lpotdod.\n                    denominator := div(denominator, lpotdod)\n\n                    // Divide [prod1 prod0] by lpotdod.\n                    prod0 := div(prod0, lpotdod)\n\n                    // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one\n                    lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n                }\n\n                // Shift in bits from prod1 into prod0\n                prod0 |= prod1 * lpotdod;\n\n                // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n                // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n                // four bits. That is, denominator * inv = 1 mod 2^4\n                uint256 inverse = (3 * denominator) ^ 2;\n\n                // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n                // in modular arithmetic, doubling the correct bits in each step\n                inverse *= 2 - denominator * inverse; // inverse mod 2^8\n                inverse *= 2 - denominator * inverse; // inverse mod 2^16\n                inverse *= 2 - denominator * inverse; // inverse mod 2^32\n                inverse *= 2 - denominator * inverse; // inverse mod 2^64\n                inverse *= 2 - denominator * inverse; // inverse mod 2^128\n                inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n                // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n                // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n                // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n                // is no longer required.\n                result = prod0 * inverse;\n            }\n        }\n    }\n\n    /**\n     * @notice Calculates the square root of x\n     * @dev Credit to OpenZeppelin's Math library under MIT license\n     */\n    function sqrt(uint256 x) internal pure returns (uint256 sqrtX) {\n        if (x == 0) return 0;\n\n        uint256 msb = BitMath.mostSignificantBit(x);\n\n        assembly {\n            sqrtX := shl(shr(1, msb), 1)\n\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n            sqrtX := shr(1, add(sqrtX, div(x, sqrtX)))\n\n            x := div(x, sqrtX)\n        }\n\n        return sqrtX < x ? sqrtX : x;\n    }\n}\n"
    },
    "contracts/lib/joe-v2/PriceHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.10;\n\nimport {Uint128x128Math} from \"./math/Uint128x128Math.sol\";\nimport {Uint256x256Math} from \"./math/Uint256x256Math.sol\";\nimport {SafeCast} from \"./math/SafeCast.sol\";\nimport {Constants} from \"./Constants.sol\";\n\n/**\n * @title Liquidity Book Price Helper Library\n * @author Trader Joe\n * @notice This library contains functions to calculate prices\n */\nlibrary PriceHelper {\n    using Uint128x128Math for uint256;\n    using Uint256x256Math for uint256;\n    using SafeCast for uint256;\n\n    int256 private constant REAL_ID_SHIFT = 1 << 23;\n\n    /**\n     * @dev Calculates the price from the id and the bin step\n     * @param id The id\n     * @param binStep The bin step\n     * @return price The price as a 128.128-binary fixed-point number\n     */\n    function getPriceFromId(uint24 id, uint16 binStep) internal pure returns (uint256 price) {\n        uint256 base = getBase(binStep);\n        int256 exponent = getExponent(id);\n\n        price = base.pow(exponent);\n    }\n\n    /**\n     * @dev Calculates the id from the price and the bin step\n     * @param price The price as a 128.128-binary fixed-point number\n     * @param binStep The bin step\n     * @return id The id\n     */\n    function getIdFromPrice(uint256 price, uint16 binStep) internal pure returns (uint24 id) {\n        uint256 base = getBase(binStep);\n        int256 realId = price.log2() / base.log2();\n\n        unchecked {\n            id = uint256(REAL_ID_SHIFT + realId).safe24();\n        }\n    }\n\n    /**\n     * @dev Calculates the base from the bin step, which is `1 + binStep / BASIS_POINT_MAX`\n     * @param binStep The bin step\n     * @return base The base\n     */\n    function getBase(uint16 binStep) internal pure returns (uint256) {\n        unchecked {\n            return Constants.SCALE + (uint256(binStep) << Constants.SCALE_OFFSET) / Constants.BASIS_POINT_MAX;\n        }\n    }\n\n    /**\n     * @dev Calculates the exponent from the id, which is `id - REAL_ID_SHIFT`\n     * @param id The id\n     * @return exponent The exponent\n     */\n    function getExponent(uint24 id) internal pure returns (int256) {\n        unchecked {\n            return int256(uint256(id)) - REAL_ID_SHIFT;\n        }\n    }\n\n    /**\n     * @dev Converts a price with 18 decimals to a 128.128-binary fixed-point number\n     * @param price The price with 18 decimals\n     * @return price128x128 The 128.128-binary fixed-point number\n     */\n    function convertDecimalPriceTo128x128(uint256 price) internal pure returns (uint256) {\n        return price.shiftDivRoundDown(Constants.SCALE_OFFSET, Constants.PRECISION);\n    }\n\n    /**\n     * @dev Converts a 128.128-binary fixed-point number to a price with 18 decimals\n     * @param price128x128 The 128.128-binary fixed-point number\n     * @return price The price with 18 decimals\n     */\n    function convert128x128PriceToDecimal(uint256 price128x128) internal pure returns (uint256) {\n        return price128x128.mulShiftRoundDown(Constants.PRECISION, Constants.SCALE_OFFSET);\n    }\n}\n"
    },
    "contracts/lib/uniswap-v3/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint256 remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n\n        //TODO: our change\n        //https://ethereum.stackexchange.com/questions/96642/unary-operator-minus-cannot-be-applied-to-type-uint256\n//        uint256 twos = -denominator & denominator;\n        uint256 twos = denominator & (~denominator + 1);\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint256 inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv; // inverse mod 2**8\n        inv *= 2 - denominator * inv; // inverse mod 2**16\n        inv *= 2 - denominator * inv; // inverse mod 2**32\n        inv *= 2 - denominator * inv; // inverse mod 2**64\n        inv *= 2 - denominator * inv; // inverse mod 2**128\n        inv *= 2 - denominator * inv; // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n\n    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint256).max);\n            result++;\n        }\n    }\n}\n"
    },
    "contracts/token/sPrime.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\n// Last deployed from commit: a29177cf0be64d4ebf05a92383b563d93b070579;\n\npragma solidity ^0.8.17;\n\n// Importing necessary libraries and interfaces\nimport \"../interfaces/joe-v2/ILBRouter.sol\";\nimport \"../interfaces/joe-v2/ILBHooksBaseRewarder.sol\";\nimport \"../interfaces/ISPrimeTraderJoe.sol\";\nimport \"../interfaces/IPositionManager.sol\";\nimport \"../interfaces/IVPrimeController.sol\";\nimport \"../lib/joe-v2/math/SafeCast.sol\";\nimport \"../lib/uniswap-v3/FullMath.sol\";\nimport \"../lib/joe-v2/math/Uint256x256Math.sol\";\nimport \"../lib/joe-v2/math/LiquidityConfigurations.sol\";\nimport \"../lib/joe-v2/PriceHelper.sol\";\nimport \"../abstract/PendingOwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\nimport \"@redstone-finance/evm-connector/contracts/core/ProxyConnector.sol\";\n\n// SPrime contract declaration\ncontract SPrime is ISPrimeTraderJoe, ReentrancyGuardUpgradeable, PendingOwnableUpgradeable, ERC20Upgradeable, ProxyConnector {\n    using SafeERC20 for IERC20Metadata; // Using SafeERC20 for IERC20Metadata for safe token transfers\n    using SafeCast for uint256; // Using SafeCast for uint256 for safe type casting\n    using Uint256x256Math for uint256;\n    using PackedUint128Math for bytes32;\n\n    // Constants declaration\n    uint256 private constant _REBALANCE_MARGIN = 500;\n    uint256 private constant _DENOMINATOR = 10000;\n    uint256 private constant _MAX_SLIPPAGE = 500;\n    uint16 internal constant DEFAULT_BIN_STEP = 50;\n    uint256 public constant MAX_LOCK_TIME = 3 * 365 days;\n\n    // Mapping for storing pair information and user shares\n    mapping(address => LockDetails[]) public locks;\n\n    // Immutable variables for storing token and pair information\n    IERC20Metadata public tokenX;\n    IERC20Metadata public tokenY;\n    uint8 public tokenXDecimals;\n    uint8 public tokenYDecimals;\n    ILBPair public lbPair;\n    IPositionManager public positionManager;\n    IVPrimeController public vPrimeController;\n    address public traderJoeV2Router;\n\n    // Arrays for storing deltaIds and distributions\n    DepositForm[] private depositForm;\n\n    address public operator;\n    ILBHooksBaseRewarder public baseRewarder;\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    /**\n    * @dev initialize of the contract.\n    * @param tokenX_ The address of the token X.\n    * @param tokenY_ The address of the token Y.\n    * @param name_ The name of the SPrime token. ex: PRIME-USDC LP\n    * @param depositForm_ Pre-defined distributions and delta ids\n    * @param positionManager_ Position Manager contract for sPrime\n    * @param traderJoeV2Router_ Trader Joe V2 Router Address\n    */\n    function initialize(address tokenX_, address tokenY_, string memory name_, DepositForm[] calldata depositForm_, IPositionManager positionManager_, address traderJoeV2Router_) external initializer {\n        __PendingOwnable_init();\n        __ReentrancyGuard_init();\n        __ERC20_init(name_, \"sPrime\");\n\n        traderJoeV2Router = traderJoeV2Router_;\n        ILBFactory lbFactory = ILBRouter(traderJoeV2Router).getFactory();\n        ILBFactory.LBPairInformation memory pairInfo = lbFactory.getLBPairInformation(IERC20(tokenX_), IERC20(tokenY_), DEFAULT_BIN_STEP);\n\n        lbPair = pairInfo.LBPair;\n        tokenX = IERC20Metadata(address(lbPair.getTokenX()));\n        tokenY = IERC20Metadata(address(lbPair.getTokenY()));\n\n        tokenXDecimals = tokenX.decimals();\n        tokenYDecimals = tokenY.decimals();\n\n        for(uint256 i = 0 ; i < depositForm_.length ; i ++) {\n            depositForm.push(depositForm_[i]);\n        }\n\n        positionManager = positionManager_;\n    }\n\n    modifier onlyOperator() {\n        if (_msgSender() != operator) {\n            revert Unauthorized();\n        }\n        _;\n    }\n\n    function setVPrimeControllerAddress(IVPrimeController _vPrimeController) public onlyOwner {\n        vPrimeController = _vPrimeController;\n    }\n\n    function setOperator(\n        address _operator\n    ) public onlyOwner {\n        operator = _operator;\n    }\n\n    function setBaseRewarder(\n        ILBHooksBaseRewarder _baseRewarder\n    ) public onlyOwner {\n        baseRewarder = _baseRewarder;\n    }\n\n    /** Public View Functions */\n\n    function getLBPair() public view returns (ILBPair) {\n        return lbPair;\n    }\n\n    function getTokenX() public view returns (IERC20) {\n        return tokenX;\n    }\n\n    function getTokenY() public view returns (IERC20) {\n        return tokenY;\n    }\n\n    /**\n     * @dev Check if the active id is in the user position range\n     * @param user User Address.\n     * @return status bin status\n     */\n    function binInRange(address user) public view returns(bool) {\n        uint256 tokenId = getUserTokenId(user);\n        if (tokenId == 0) {\n            revert NoPosition();\n        }\n\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfigFromTokenId(tokenId);\n\n        uint256[] memory depositIds = depositConfig.depositIds;\n        uint256 activeId = lbPair.getActiveId();\n        if (depositIds[0] <= activeId && depositIds[depositIds.length - 1] >= activeId) {\n            return true;\n        }\n        return false;\n    }\n\n    /**\n     * @dev Returns the estimated USD value of the user position\n     * @param user User Address\n     * @param poolPrice Pool Price or oracle price for calculating proper token amount\n     * @return Total Value in tokenY amount for the user's position.\n     */\n    function getUserValueInTokenY(address user, uint256 poolPrice) public view returns (uint256) {\n        (,,,,uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(getUserTokenId(user));\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n        (uint256 amountX, uint256 amountY) = _getLiquidityTokenAmounts(depositConfig.depositIds, liquidityMinted, poolPrice);\n\n        amountY = amountY + FullMath.mulDiv(amountX, poolPrice, 1e8);\n\n        return amountY;\n    }\n\n    /**\n     * @dev Returns the estimated USD value of the user position\n     * @param user User Address\n     * @return Total Value in tokenY amount for the user's position.\n     */\n    function getUserValueInTokenY(address user) external view returns (uint256) {\n        uint256 poolPrice = getPoolPrice();\n        return getUserValueInTokenY(user, poolPrice);\n    }\n\n    /**\n    * @dev Returns the fully vested locked balance for an account.\n    * @dev Full business logic description can be found in Pool::getFullyVestedLockedBalance() docstring\n    * @param account The address of the account.\n    * @return fullyVestedBalance Fully vested locked balance\n    */\n    function getFullyVestedLockedBalance(address account) public view returns (uint256 fullyVestedBalance) {\n        uint256 length = locks[account].length;\n        for (uint256 i; i != length; ++i) {\n            LockDetails memory lock = locks[account][i];\n            if (lock.unlockTime > block.timestamp) {\n                fullyVestedBalance += FullMath.mulDiv(lock.amount, lock.lockPeriod, MAX_LOCK_TIME);\n            }\n        }\n    }\n\n    /**\n    * @dev Returns the total locked balance of an account.\n    * @param account The address of the account.\n    * @return The total locked balance of the account.\n    */\n    function getLockedBalance(address account) public view returns (uint256) {\n        uint256 lockedBalance;\n        uint256 length = locks[account].length;\n        for (uint256 i; i != length; ++i) {\n            LockDetails memory lock = locks[account][i];\n            if (lock.unlockTime > block.timestamp) {\n                lockedBalance += lock.amount;\n            }\n        }\n        return lockedBalance;\n    }\n\n    /**\n    * @dev Returns the token id for the user\n    * @param user The user address\n    * @return tokenId token id owned by the user\n    */\n    function getUserTokenId(address user) public view returns(uint256 tokenId){\n        if(positionManager.balanceOf(user) > 0) {\n            tokenId = positionManager.tokenOfOwnerByIndex(user, 0);\n        }\n    }\n\n    /** Internal Functions */\n    \n    /**\n    * @dev Returns the token balances for the specific bin.\n    * @param depositIds Deposited bin id list.\n    * @param liquidityMinted Liquidity minted for each bin.\n    * @param poolPrice Oracle Price\n    */\n    function _getLiquidityTokenAmounts(uint256[] memory depositIds, uint256[] memory liquidityMinted, uint256 poolPrice) internal view returns(uint256 amountX, uint256 amountY) {\n        if (depositIds.length != liquidityMinted.length) {\n            revert LengthMismatch();\n        }\n        poolPrice = FullMath.mulDiv(poolPrice, 10 ** tokenYDecimals, 1e8);\n        uint24 binId = lbPair.getIdFromPrice(PriceHelper.convertDecimalPriceTo128x128(poolPrice));\n\n        for (uint256 i; i < depositIds.length; ++i) {\n            uint24 id = depositIds[i].safe24();\n\n            uint256 liquidity = liquidityMinted[i];\n            (uint256 binReserveX, uint256 binReserveY) = lbPair.getBin(id);\n\n            // Get Current Pool price from id.\n            uint256 currentPrice = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(id));\n\n            uint256 totalSupply = lbPair.totalSupply(id);\n            uint256 xAmount = liquidity.mulDivRoundDown(binReserveX, totalSupply);\n            uint256 yAmount = liquidity.mulDivRoundDown(binReserveY, totalSupply);\n            if(binId > id) {\n                xAmount = xAmount + FullMath.mulDiv(yAmount, 10 ** 18, currentPrice);\n                yAmount = 0;\n            } else if(binId < id) {\n                yAmount = yAmount + FullMath.mulDiv(xAmount, currentPrice, 10 ** 18);\n                xAmount = 0;\n            } \n\n            amountX += xAmount;\n            amountY += yAmount;\n        }\n    }\n\n    /**\n     * @dev Returns the total weight of tokens in a liquidity pair.\n     * @param amountX Token X Amount.\n     * @param amountY Token Y Amount.\n     * @return weight The total weight of the tokens.\n     */\n    function _getTotalInTokenY(uint256 amountX, uint256 amountY) internal view returns(uint256 weight) {\n        uint256 amountXToY = _getTokenYFromTokenX(amountX);\n        weight = amountY + amountXToY;\n    }\n\n    function getPoolPrice() public view returns(uint256) {\n        uint256 price = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(lbPair.getActiveId()));\n        return FullMath.mulDiv(price, 1e8, 1e18);\n    }\n\n    /**\n     * @dev Returns the estimated token Y amount from token X.\n     * @param amountX Token X Amount.\n     * @return amountY Token Y Amount to return.\n     */\n    function _getTokenYFromTokenX(uint256 amountX) internal view returns(uint256 amountY) {\n        (uint128 reserveA, uint128 reserveB) = lbPair.getReserves();\n        if(reserveA > 0 || reserveB > 0) {\n            uint256 price = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(lbPair.getActiveId()));\n            // Swap For Y : Convert token X to token Y\n            amountY = amountX * price / 1e18;\n        } else {\n            amountY = 0;\n        }\n    }\n\n    /**\n    * @dev Returns the updated amounts of tokens.\n    * @return amountX The updated amount of token X.\n    * @return amountY The updated amount of token Y.\n    */\n    function _swapForEqualValues(uint256 amountX, uint256 amountY, uint256 swapSlippage) internal returns(uint256, uint256) {\n        uint256 amountXToY = _getTokenYFromTokenX(amountX);\n        bool swapTokenX = amountY < amountXToY;\n        uint256 diff = swapTokenX ? amountXToY - amountY : amountY - amountXToY;\n        // (amountXToY != 0 || amountX == 0) for excluding the initial LP deposit\n        if(FullMath.mulDiv(amountY, _REBALANCE_MARGIN, _DENOMINATOR) < diff && (amountXToY > 0 || amountX == 0)) {\n            uint256 amountIn;\n            {\n                uint256 price = PriceHelper.convert128x128PriceToDecimal(lbPair.getPriceFromId(lbPair.getActiveId()));\n                // Swap For X : Convert token Y to token X\n                amountIn = FullMath.mulDiv(diff / 2, 1e18, price);\n            }\n\n            uint256 amountOut = diff / 2; \n\n            (amountIn, amountOut) = swapTokenX ? (amountIn, amountOut) : (amountOut, amountIn);\n            IERC20[] memory tokenPathDynamic = new IERC20[](2);\n            if (swapTokenX) {\n                tokenPathDynamic[0] = tokenX;\n                tokenPathDynamic[1] = tokenY;\n                tokenX.safeApprove(traderJoeV2Router, 0);\n                tokenX.safeApprove(traderJoeV2Router, amountIn);\n            } else {\n                tokenPathDynamic[0] = tokenY;\n                tokenPathDynamic[1] = tokenX;\n                tokenY.safeApprove(traderJoeV2Router, 0);\n                tokenY.safeApprove(traderJoeV2Router, amountIn);\n            }\n\n            ILBRouter.Version[] memory versionsDynamic = new ILBRouter.Version[](1);\n            versionsDynamic[0] = ILBRouter.Version.V2_2;\n\n            uint256[] memory binStepsDynamic = new uint256[](1);\n            binStepsDynamic[0] = DEFAULT_BIN_STEP;\n\n            ILBRouter.Path memory path = ILBRouter.Path({\n                pairBinSteps: binStepsDynamic,\n                versions: versionsDynamic,\n                tokenPath: tokenPathDynamic\n            });\n            amountOut = ILBRouter(traderJoeV2Router).swapExactTokensForTokens(amountIn, amountOut * (_DENOMINATOR - swapSlippage) / _DENOMINATOR, path, address(this), block.timestamp);\n            (amountX, amountY) = swapTokenX ? (amountX - amountIn,amountY + amountOut) : (amountX + amountOut, amountY - amountIn);\n        }\n        return (amountX, amountY);\n    }\n\n    /**\n    * @dev Returns the liquidity configurations for the given range.\n    * @param centerId The active id of the pair.\n    * @return liquidityConfigs The liquidity configurations for the given range.\n    * @return depositIds Deposit ID list.\n    */\n    function _encodeDepositConfigs(uint256 centerId) internal view returns (bytes32[] memory liquidityConfigs, uint256[] memory depositIds) {\n        uint256 length = depositForm.length;\n        liquidityConfigs = new bytes32[](length);\n        depositIds = new uint256[](length);\n        for (uint256 i = 0; i < length; ++i) {\n            DepositForm memory config = depositForm[i];\n            int256 _id = int256(centerId) + config.deltaId;\n            if (!(_id >= 0 && uint256(_id) <= type(uint24).max)) {\n                revert Overflow();\n            }\n            depositIds[i] = uint256(_id);\n            liquidityConfigs[i] = LiquidityConfigurations.encodeParams(config.distributionX, config.distributionY, uint24(uint256(_id)));\n        }\n    }\n\n    /**\n    * @dev Withdraws tokens from the Liquidity Book Pair.\n    * @param depositIds Deposit ID list.\n    * @param liquidityMinted The amount of ids to withdraw.\n    * @param share sPrime amount to withdraw.\n    * @return balanceX The amount of token X received.\n    * @return balanceY The amount of token Y received.\n    */\n    function _withdrawFromLB(uint256[] memory depositIds, uint256[] memory liquidityMinted, uint256 share) internal returns (uint256 balanceX, uint256 balanceY, uint256[] memory liquidityAmounts) {\n        if (depositIds.length != liquidityMinted.length) {\n            revert LengthMismatch();\n        }\n\n        uint256 length;\n        uint256 totalShare = balanceOf(_msgSender());\n        // Get the lbPair address and the delta between the upper and lower range.\n        uint256 delta = depositIds.length;\n\n        uint256[] memory ids = new uint256[](delta);\n        uint256[] memory amounts = new uint256[](delta);\n        liquidityAmounts  = new uint256[](delta);\n\n        // Get the ids and amounts of the tokens to withdraw.\n        for (uint256 i; i < delta;) {\n            uint256 id = depositIds[i];\n            liquidityAmounts[i] = FullMath.mulDiv(liquidityMinted[i], share, totalShare);\n            if (liquidityAmounts[i] != 0) {\n                ids[length] = id;\n                amounts[length] = liquidityAmounts[i];\n\n                unchecked {\n                    ++length;\n                }\n            }\n\n            unchecked {\n                ++i;\n            }\n        }\n        uint256 balanceXBefore = tokenX.balanceOf(address(this));\n        uint256 balanceYBefore = tokenY.balanceOf(address(this));\n\n        // If the range is not empty, burn the tokens from the lbPair.\n        if (length > 0) {\n            // If the length is different than the delta, update the arrays, this allows to avoid the zero share error.\n            if (length != delta) {\n                assembly {\n                    mstore(ids, length)\n                    mstore(amounts, length)\n                }\n            }\n\n            lbPair.burn(address(this), address(this), ids, amounts);\n        }\n\n        // Get the amount of tokens in the sPrime contract.\n        balanceX = tokenX.balanceOf(address(this)) - balanceXBefore;\n        balanceY = tokenY.balanceOf(address(this)) - balanceYBefore;\n    }\n\n    /**\n     * @dev Deposits tokens into the lbPair.\n     * @param user The user address to receive sPrime.\n     * @param centerId The active Id.\n     */\n    function _depositToLB(address user, uint256 centerId) internal {\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n        if(depositConfig.depositIds.length == 0) {\n            (depositConfig.liquidityConfigs, depositConfig.depositIds) = _encodeDepositConfigs(centerId);\n        }\n\n        // Mint the liquidity tokens.\n        (bytes32 amountsReceived, bytes32 amountsLeft, uint256[] memory liquidityMinted) = lbPair.mint(address(this), depositConfig.liquidityConfigs, user);\n        \n        uint256 share = _getTotalInTokenY(amountsReceived.decodeX() - amountsLeft.decodeX(), amountsReceived.decodeY() - amountsLeft.decodeY());\n        uint256 tokenId = getUserTokenId(user);\n        if(tokenId == 0) {\n            tokenId = positionManager.mint(IPositionManager.MintParams({\n                recipient: user,\n                totalShare: share,\n                centerId: centerId,\n                liquidityMinted: liquidityMinted,\n                liquidityConfigs: depositConfig.liquidityConfigs,\n                depositIds: depositConfig.depositIds\n            }));\n        } else  {\n            positionManager.update(IPositionManager.UpdateParams({\n                tokenId: tokenId,\n                share: share,\n                liquidityAmounts: liquidityMinted,\n                isAdd: true\n            }));\n        }\n        _mint(user, share);\n    }\n\n    /**\n    * @dev Internal function to transfer tokens between addresses.\n    * @param from The address from which tokens are being transferred.\n    * @param to The address to which tokens are being transferred.\n    * @param amountX The amount of token X to transfer.\n    * @param amountY The amount of token Y to transfer.\n    */\n    function _transferTokens(address from, address to, uint256 amountX, uint256 amountY) internal {\n        if(from == address(this)) {\n            if(amountX > 0) tokenX.safeTransfer(to, amountX);\n            if(amountY > 0) tokenY.safeTransfer(to, amountY);\n        } else {\n            if(amountX > 0) tokenX.safeTransferFrom(from, to, amountX);\n            if(amountY > 0) tokenY.safeTransferFrom(from, to, amountY);\n        }\n    }\n\n\n    /** Public And External Functions */\n\n    /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param activeIdDesired The active id that user wants to add liquidity from\n    * @param idSlippage The number of id that are allowed to slip\n    * @param amountX The amount of token X to deposit.\n    * @param amountY The amount of token Y to deposit.\n    * @param isRebalance Rebalance the existing position with deposit.\n    * @param swapSlippage Slippage for the rebalance.\n    */\n    function deposit(uint256 activeIdDesired, uint256 idSlippage, uint256 amountX, uint256 amountY, bool isRebalance, uint256 swapSlippage) public nonReentrant {\n        _transferTokens(_msgSender(), address(this), amountX, amountY);\n\n        _deposit(_msgSender(), activeIdDesired, idSlippage, amountX, amountY, isRebalance, swapSlippage);\n\n        notifyVPrimeController(_msgSender());\n    }\n\n\n    function _deposit(address user, uint256 activeIdDesired, uint256 idSlippage, uint256 amountX, uint256 amountY, bool isRebalance, uint256 swapSlippage) internal {\n\n        if (swapSlippage > _MAX_SLIPPAGE) {\n            revert SlippageTooHigh();\n        }\n\n        uint256 tokenId = getUserTokenId(user);\n        uint256 activeId = lbPair.getActiveId();\n        if(tokenId > 0) {\n            (,,, uint256 share, uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(tokenId);\n            activeId = centerId;\n            if(isRebalance) { // Withdraw Position For Rebalance\n                IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n                (uint256 amountXBefore, uint256 amountYBefore, ) = _withdrawFromLB(depositConfig.depositIds, liquidityMinted, share);\n                \n                positionManager.burn(tokenId);   \n                _burn(user, share);\n\n                (amountX, amountY) = (amountX + amountXBefore, amountY + amountYBefore);\n                tokenId = 0;\n            }\n        }\n        (amountX, amountY) = _swapForEqualValues(amountX, amountY, swapSlippage);\n        \n        // Revert if active id moved without rebalancing\n        if (!(activeId == lbPair.getActiveId() || tokenId == 0)) {\n            revert BinIdChanged();\n        }\n        activeId = lbPair.getActiveId();\n\n        if (!(activeIdDesired + idSlippage >= activeId && activeId + idSlippage >= activeIdDesired)) {\n            revert SlippageTooHigh();\n        }\n\n        _transferTokens(address(this), address(lbPair), amountX, amountY);\n        _depositToLB(user, activeId);\n    }\n\n    /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param user The active id that user wants to add liquidity from\n    * @param percentForLocks sPrime amount % to lock\n    * @param lockPeriods Lock period to Lock for each amount\n    * @param amountX The amount of token X to deposit.\n    * @param amountY The amount of token Y to deposit.\n    * @param activeIdDesired Desired bin id.\n    * @param idSlippage Bin id slippage from the active id.\n    */\n    function mintForUserAndLock(address user, uint256[] calldata percentForLocks, uint256[] calldata lockPeriods, uint256 amountX, uint256 amountY, uint256 activeIdDesired, uint256 idSlippage) public onlyOperator nonReentrant {\n        if (percentForLocks.length != lockPeriods.length) {\n            revert LengthMismatch();\n        }\n        \n        uint256 oldBalance = balanceOf(user);\n        _transferTokens(_msgSender(), address(this), amountX, amountY);\n        _deposit(user, activeIdDesired, idSlippage, amountX, amountY, true, _MAX_SLIPPAGE);\n        if (balanceOf(user) < oldBalance) {\n            revert NegativeMint();\n        }\n\n        uint256 totalLock;\n        for(uint8 i = 0 ; i < lockPeriods.length ; i ++) {\n            totalLock += percentForLocks[i];\n        }\n        if (totalLock != 100) {\n            revert ShouldLock100Percent();\n        }\n        \n        uint256 balance = balanceOf(user) - oldBalance;\n        totalLock = 0;\n        for(uint8 i = 0 ; i < lockPeriods.length ; i ++) {\n            if (lockPeriods[i] > MAX_LOCK_TIME) {\n                revert MaxLockTimeExceeded();\n            }\n            // Should minus from total balance to avoid the round issue\n            uint256 amount = i == lockPeriods.length - 1 ? balance - totalLock : balance * percentForLocks[i] / 100;\n            locks[user].push(LockDetails({\n                lockPeriod: lockPeriods[i],\n                amount: amount,\n                unlockTime: block.timestamp + lockPeriods[i]\n            }));\n            totalLock += amount;\n        }\n\n        notifyVPrimeController(user);\n    }\n\n    /**\n    * @dev Users can use deposit function for depositing tokens to the specific bin.\n    * @param ids Depoisit Ids from TraderJoe\n    * @param amounts Minted LBT amount for each deposit id\n    * @param activeIdDesired The active id that user wants to add liquidity from\n    * @param idSlippage The number of id that are allowed to slip\n    * @param swapSlippage Slippage for the rebalance.\n    */\n    function migrateLiquidity(uint256[] calldata ids, uint256[] calldata amounts, uint256 activeIdDesired, uint256 idSlippage, uint256 swapSlippage) public nonReentrant {\n        uint256 balanceXBefore = tokenX.balanceOf(address(this));\n        uint256 balanceYBefore = tokenY.balanceOf(address(this));\n\n        lbPair.burn(_msgSender(), address(this), ids, amounts);\n\n        _deposit(_msgSender(), activeIdDesired, idSlippage, tokenX.balanceOf(address(this)) - balanceXBefore, tokenY.balanceOf(address(this)) - balanceYBefore, true, swapSlippage);\n\n        notifyVPrimeController(_msgSender());\n    }\n\n    /**\n    * @dev Users can use withdraw function for withdrawing their share.\n    * @param share Amount to withdraw\n    */\n    function withdraw(uint256 share) external nonReentrant {\n        uint256 tokenId = getUserTokenId(_msgSender());\n        if (tokenId == 0) {\n            revert NoPosition();\n        }\n\n        (,,,, uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(tokenId);\n        IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n\n        uint256 lockedBalance = getLockedBalance(_msgSender());\n        if (balanceOf(_msgSender()) < share + lockedBalance) {\n            revert BalanceIsLocked();\n        }\n\n        (uint256 amountX, uint256 amountY, uint256[] memory liquidityAmounts) = _withdrawFromLB(depositConfig.depositIds, liquidityMinted, share);\n\n        positionManager.update(IPositionManager.UpdateParams({\n            tokenId: tokenId,\n            share: share,\n            liquidityAmounts: liquidityAmounts,\n            isAdd: false\n        }));\n\n        // Burn Position NFT\n        if(balanceOf(_msgSender()) == share) {\n            positionManager.burn(tokenId);\n        }\n\n        // Send the tokens to the user.\n        _transferTokens(address(this), _msgSender(), amountX, amountY);\n\n        _burn(_msgSender(), share);\n\n        notifyVPrimeController(_msgSender());\n    }\n\n    /**\n    * @dev Locks a specified amount of balance for a specified lock period.\n    * @param amount The amount of balance to be locked.\n    * @param lockPeriod The duration for which the balance will be locked.\n    */\n    function lockBalance(uint256 amount, uint256 lockPeriod) public nonReentrant {\n        uint256 lockedBalance = getLockedBalance(_msgSender());\n        if (balanceOf(_msgSender()) < amount + lockedBalance) {\n            revert InsufficientBalance();\n        }\n        if (lockPeriod > MAX_LOCK_TIME) {\n            revert MaxLockTimeExceeded();\n        }\n        locks[_msgSender()].push(LockDetails({\n            lockPeriod: lockPeriod,\n            amount: amount,\n            unlockTime: block.timestamp + lockPeriod\n        }));\n\n        notifyVPrimeController(_msgSender());\n    }\n\n    /**\n    * @dev Claims the reward from TraderJoe v2.2 Base Reward Pool\n    * @param receiver User address that will receive the collected reward.\n    * @param ids Bin Id list to claim.\n    */\n    function claim(address receiver, uint256[] calldata ids) public onlyOwner nonReentrant {\n        baseRewarder.claim(address(this), ids);\n        IERC20Metadata rewardToken = IERC20Metadata(address(baseRewarder.getRewardToken()));\n        uint256 reward = rewardToken.balanceOf(address(this));\n        if(reward > 0) {\n            rewardToken.safeTransfer(receiver, reward);\n        }\n    }\n\n    /** Overrided Functions */\n\n    /**\n    * @dev The hook that happens before token transfer.\n    * @param from The address to transfer from.\n    * @param to The address to transfer to.\n    * @param amount The amount to transfer.\n    */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual override {\n        if(from != address(0) && to != address(0)) {\n            uint256 lockedBalance = getLockedBalance(from);\n            uint256 fromBalance = balanceOf(from);\n            if (fromBalance < amount + lockedBalance) {\n                revert InsufficientBalance();\n            }\n            if (getUserTokenId(to) != 0) {\n                revert UserAlreadyHasPosition();\n            }\n            \n            uint256 tokenId = getUserTokenId(from);\n\n            if(fromBalance == amount) {\n                positionManager.forceTransfer(from, to, tokenId);\n            } else {\n                (,,,,uint256 centerId, uint256[] memory liquidityMinted) = positionManager.positions(tokenId);\n                IPositionManager.DepositConfig memory depositConfig = positionManager.getDepositConfig(centerId);\n                for(uint256 i = 0 ; i < liquidityMinted.length ; i ++) {\n                    liquidityMinted[i] = FullMath.mulDiv(liquidityMinted[i], amount, fromBalance);\n                }\n\n                positionManager.update(IPositionManager.UpdateParams({\n                    tokenId: tokenId,\n                    share: amount,\n                    liquidityAmounts: liquidityMinted,\n                    isAdd: false\n                }));\n\n                positionManager.mint(IPositionManager.MintParams({\n                    recipient: to,\n                    totalShare: amount,\n                    centerId: centerId,\n                    liquidityMinted: liquidityMinted,\n                    liquidityConfigs: depositConfig.liquidityConfigs,\n                    depositIds: depositConfig.depositIds\n                }));\n            }\n        }\n    }\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        if(from != address(0) && to != address(0)) {\n            notifyVPrimeController(from);\n            notifyVPrimeController(to);\n        }\n    }\n\n    function containsOracleCalldata() public pure returns (bool) {\n        // Checking if the calldata ends with the RedStone marker\n        bool hasValidRedstoneMarker;\n        assembly {\n            let calldataLast32Bytes := calldataload(sub(calldatasize(), STANDARD_SLOT_BS))\n            hasValidRedstoneMarker := eq(\n                REDSTONE_MARKER_MASK,\n                and(calldataLast32Bytes, REDSTONE_MARKER_MASK)\n            )\n        }\n        return hasValidRedstoneMarker;\n    }\n\n    function notifyVPrimeController(address account) internal {\n        if(address(vPrimeController) != address(0)){\n            if(containsOracleCalldata()) {\n                proxyCalldata(\n                    address(vPrimeController),\n                    abi.encodeWithSignature\n                    (\"updateVPrimeSnapshot(address)\", account),\n                    false\n                );\n            } else {\n                vPrimeController.setUserNeedsUpdate(account);\n            }\n        }\n    }\n\n    function decimals() public view virtual override returns (uint8) {\n        return tokenYDecimals;\n    }\n\n    // CUSTOM ERRORS\n    error InsufficientBalance();\n    error BalanceIsLocked();\n    error NoPosition();\n    error LengthMismatch();\n    error MaxLockTimeExceeded();\n    error SlippageTooHigh();\n    error BinIdChanged();\n    error UserAlreadyHasPosition();\n    error NegativeMint();\n    error ShouldLock100Percent();\n    error Unauthorized();\n    error Overflow();\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 10
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}